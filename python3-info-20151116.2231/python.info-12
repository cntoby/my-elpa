This is python.info, produced by makeinfo version 5.2 from python.texi.

     Python 3.4.3, September 02, 2015

     Copyright © 1990-2015, Python Software Foundation

INFO-DIR-SECTION Python
START-INFO-DIR-ENTRY
* Python: (python.info). The Python reference manual.
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.3.1.


File: python.info,  Node: array --- Efficient arrays of numeric values,  Next: weakref --- Weak references,  Prev: bisect --- Array bisection algorithm,  Up: Data Types

5.8.7 ‘array’ — Efficient arrays of numeric values
--------------------------------------------------

This module defines an object type which can compactly represent an
array of basic values: characters, integers, floating point numbers.
Arrays are sequence types and behave very much like lists, except that
the type of objects stored in them is constrained.  The type is
specified at object creation time by using a `type code', which is a
single character.  The following type codes are defined:

Type code       C Type                   Python Type             Minimum size in bytes       Notes
                                                                                             
---------------------------------------------------------------------------------------------------------
                                                                                             
‘'b'’           signed char              int                     1
                                                                 
                                                                                             
‘'B'’           unsigned char            int                     1
                                                                 
                                                                                             
‘'u'’           Py_UNICODE               Unicode character       2                           (1)
                                                                                             
                                                                                             
‘'h'’           signed short             int                     2
                                                                 
                                                                                             
‘'H'’           unsigned short           int                     2
                                                                 
                                                                                             
‘'i'’           signed int               int                     2
                                                                 
                                                                                             
‘'I'’           unsigned int             int                     2
                                                                 
                                                                                             
‘'l'’           signed long              int                     4
                                                                 
                                                                                             
‘'L'’           unsigned long            int                     4
                                                                 
                                                                                             
‘'q'’           signed long long         int                     8                           (2)
                                                                                             
                                                                                             
‘'Q'’           unsigned long long       int                     8                           (2)
                                                                                             
                                                                                             
‘'f'’           float                    float                   4
                                                                 
                                                                                             
‘'d'’           double                   float                   8
                                                                 

Notes:

  1. The ‘'u'’ type code corresponds to Python’s obsolete unicode
     character (*note Py_UNICODE: 505. which is ‘wchar_t’).  Depending
     on the platform, it can be 16 bits or 32 bits.

     ‘'u'’ will be removed together with the rest of the *note
     Py_UNICODE: 505. API.

     Deprecated since version 3.3, will be removed in version 4.0.

  2. The ‘'q'’ and ‘'Q'’ type codes are available only if the platform C
     compiler used to build Python supports C ‘long long’, or, on
     Windows, ‘__int64’.

     New in version 3.3.

The actual representation of values is determined by the machine
architecture (strictly speaking, by the C implementation).  The actual
size can be accessed through the ‘itemsize’ attribute.

The module defines the following type:

 -- Class: array.array (typecode[, initializer])

     A new array whose items are restricted by `typecode', and
     initialized from the optional `initializer' value, which must be a
     list, a *note bytes-like object: 19f, or iterable over elements of
     the appropriate type.

     If given a list or string, the initializer is passed to the new
     array’s *note fromlist(): 1109, *note frombytes(): 110a, or *note
     fromunicode(): 110b. method (see below) to add initial items to the
     array.  Otherwise, the iterable initializer is passed to the *note
     extend(): 110c. method.

 -- Data: array.typecodes

     A string with all available type codes.

Array objects support the ordinary sequence operations of indexing,
slicing, concatenation, and multiplication.  When using slice
assignment, the assigned value must be an array object with the same
type code; in all other cases, *note TypeError: 309. is raised.  Array
objects also implement the buffer interface, and may be used wherever
*note bytes-like object: 19f.s are supported.

The following data items and methods are also supported:

 -- Attribute: array.typecode

     The typecode character used to create the array.

 -- Attribute: array.itemsize

     The length in bytes of one array item in the internal
     representation.

 -- Method: array.append (x)

     Append a new item with value `x' to the end of the array.

 -- Method: array.buffer_info ()

     Return a tuple ‘(address, length)’ giving the current memory
     address and the length in elements of the buffer used to hold
     array’s contents.  The size of the memory buffer in bytes can be
     computed as ‘array.buffer_info()[1] * array.itemsize’.  This is
     occasionally useful when working with low-level (and inherently
     unsafe) I/O interfaces that require memory addresses, such as
     certain ‘ioctl()’ operations.  The returned numbers are valid as
     long as the array exists and no length-changing operations are
     applied to it.

          Note: When using array objects from code written in C or C++
          (the only way to effectively make use of this information), it
          makes more sense to use the buffer interface supported by
          array objects.  This method is maintained for backward
          compatibility and should be avoided in new code.  The buffer
          interface is documented in *note Buffer Protocol: ddf.

 -- Method: array.byteswap ()

     "Byteswap" all items of the array.  This is only supported for
     values which are 1, 2, 4, or 8 bytes in size; for other types of
     values, *note RuntimeError: 7f0. is raised.  It is useful when
     reading data from a file written on a machine with a different byte
     order.

 -- Method: array.count (x)

     Return the number of occurrences of `x' in the array.

 -- Method: array.extend (iterable)

     Append items from `iterable' to the end of the array.  If
     `iterable' is another array, it must have `exactly' the same type
     code; if not, *note TypeError: 309. will be raised.  If `iterable'
     is not an array, it must be iterable and its elements must be the
     right type to be appended to the array.

 -- Method: array.frombytes (s)

     Appends items from the string, interpreting the string as an array
     of machine values (as if it had been read from a file using the
     *note fromfile(): 1114. method).

     New in version 3.2: *note fromstring(): 1115. is renamed to *note
     frombytes(): 110a. for clarity.

 -- Method: array.fromfile (f, n)

     Read `n' items (as machine values) from the *note file object: 56a.
     `f' and append them to the end of the array.  If less than `n'
     items are available, *note EOFError: 6d0. is raised, but the items
     that were available are still inserted into the array.  `f' must be
     a real built-in file object; something else with a ‘read()’ method
     won’t do.

 -- Method: array.fromlist (list)

     Append items from the list.  This is equivalent to ‘for x in list:
     a.append(x)’ except that if there is a type error, the array is
     unchanged.

 -- Method: array.fromstring ()

     Deprecated alias for *note frombytes(): 110a.

 -- Method: array.fromunicode (s)

     Extends this array with data from the given unicode string.  The
     array must be a type ‘'u'’ array; otherwise a *note ValueError:
     321. is raised.  Use ‘array.frombytes(unicodestring.encode(enc))’
     to append Unicode data to an array of some other type.

 -- Method: array.index (x)

     Return the smallest `i' such that `i' is the index of the first
     occurrence of `x' in the array.

 -- Method: array.insert (i, x)

     Insert a new item with value `x' in the array before position `i'.
     Negative values are treated as being relative to the end of the
     array.

 -- Method: array.pop ([i])

     Removes the item with the index `i' from the array and returns it.
     The optional argument defaults to ‘-1’, so that by default the last
     item is removed and returned.

 -- Method: array.remove (x)

     Remove the first occurrence of `x' from the array.

 -- Method: array.reverse ()

     Reverse the order of the items in the array.

 -- Method: array.tobytes ()

     Convert the array to an array of machine values and return the
     bytes representation (the same sequence of bytes that would be
     written to a file by the *note tofile(): 111c. method.)

     New in version 3.2: *note tostring(): 111d. is renamed to *note
     tobytes(): 111b. for clarity.

 -- Method: array.tofile (f)

     Write all items (as machine values) to the *note file object: 56a.
     `f'.

 -- Method: array.tolist ()

     Convert the array to an ordinary list with the same items.

 -- Method: array.tostring ()

     Deprecated alias for *note tobytes(): 111b.

 -- Method: array.tounicode ()

     Convert the array to a unicode string.  The array must be a type
     ‘'u'’ array; otherwise a *note ValueError: 321. is raised.  Use
     ‘array.tobytes().decode(enc)’ to obtain a unicode string from an
     array of some other type.

When an array object is printed or converted to a string, it is
represented as ‘array(typecode, initializer)’.  The `initializer' is
omitted if the array is empty, otherwise it is a string if the
`typecode' is ‘'u'’, otherwise it is a list of numbers.  The string is
guaranteed to be able to be converted back to an array with the same
type and value using *note eval(): 5d2, so long as the *note array(): 7.
function has been imported using ‘from array import array’.  Examples:

     array('l')
     array('u', 'hello \u2641')
     array('l', [1, 2, 3, 4, 5])
     array('d', [1.0, 2.0, 3.14])

See also
........

Module *note struct: f3.

     Packing and unpacking of heterogeneous binary data.

Module *note xdrlib: 12b.

     Packing and unpacking of External Data Representation (XDR) data as
     used in some remote procedure call systems.

The Numerical Python Documentation(1)

     The Numeric Python extension (NumPy) defines another array type;
     see ‘http://www.numpy.org/’ for further information about Numerical
     Python.

   ---------- Footnotes ----------

   (1) http://docs.scipy.org/doc/


File: python.info,  Node: weakref --- Weak references,  Next: types --- Dynamic type creation and names for built-in types,  Prev: array --- Efficient arrays of numeric values,  Up: Data Types

5.8.8 ‘weakref’ — Weak references
---------------------------------

`Source code:' Lib/weakref.py(1)

__________________________________________________________________

The *note weakref: 121. module allows the Python programmer to create
`weak references' to objects.

In the following, the term `referent' means the object which is referred
to by a weak reference.

A weak reference to an object is not enough to keep the object alive:
when the only remaining references to a referent are weak references,
*note garbage collection: af8. is free to destroy the referent and reuse
its memory for something else.  However, until the object is actually
destroyed the weak reference may return the object even if there are no
strong references to it.

A primary use for weak references is to implement caches or mappings
holding large objects, where it’s desired that a large object not be
kept alive solely because it appears in a cache or mapping.

For example, if you have a number of large binary image objects, you may
wish to associate a name with each.  If you used a Python dictionary to
map names to images, or images to names, the image objects would remain
alive just because they appeared as values or keys in the dictionaries.
The *note WeakKeyDictionary: 1122. and *note WeakValueDictionary: 1123.
classes supplied by the *note weakref: 121. module are an alternative,
using weak references to construct mappings that don’t keep objects
alive solely because they appear in the mapping objects.  If, for
example, an image object is a value in a *note WeakValueDictionary:
1123, then when the last remaining references to that image object are
the weak references held by weak mappings, garbage collection can
reclaim the object, and its corresponding entries in weak mappings are
simply deleted.

*note WeakKeyDictionary: 1122. and *note WeakValueDictionary: 1123. use
weak references in their implementation, setting up callback functions
on the weak references that notify the weak dictionaries when a key or
value has been reclaimed by garbage collection.  *note WeakSet: 72c.
implements the *note set: 5a4. interface, but keeps weak references to
its elements, just like a *note WeakKeyDictionary: 1122. does.

*note finalize: 2b2. provides a straight forward way to register a
cleanup function to be called when an object is garbage collected.  This
is simpler to use than setting up a callback function on a raw weak
reference, since the module automatically ensures that the finalizer
remains alive until the object is collected.

Most programs should find that using one of these weak container types
or *note finalize: 2b2. is all they need – it’s not usually necessary to
create your own weak references directly.  The low-level machinery is
exposed by the *note weakref: 121. module for the benefit of advanced
uses.

Not all objects can be weakly referenced; those objects which can
include class instances, functions written in Python (but not in C),
instance methods, sets, frozensets, some *note file objects: 56a, *note
generator: 374.s, type objects, sockets, arrays, deques, regular
expression pattern objects, and code objects.

Changed in version 3.2: Added support for thread.lock, threading.Lock,
and code objects.

Several built-in types such as *note list: 397. and *note dict: 380. do
not directly support weak references but can add support through
subclassing:

     class Dict(dict):
         pass

     obj = Dict(red=1, green=2, blue=3)   # this object is weak referenceable

Other built-in types such as *note tuple: 84e. and *note int: 185. do
not support weak references even when subclassed (This is an
implementation detail and may be different across various Python
implementations.).

Extension types can easily be made to support weak references; see *note
Weak Reference Support: 1124.

 -- Class: weakref.ref (object[, callback])

     Return a weak reference to `object'.  The original object can be
     retrieved by calling the reference object if the referent is still
     alive; if the referent is no longer alive, calling the reference
     object will cause *note None: 2c6. to be returned.  If `callback'
     is provided and not *note None: 2c6, and the returned weakref
     object is still alive, the callback will be called when the object
     is about to be finalized; the weak reference object will be passed
     as the only parameter to the callback; the referent will no longer
     be available.

     It is allowable for many weak references to be constructed for the
     same object.  Callbacks registered for each weak reference will be
     called from the most recently registered callback to the oldest
     registered callback.

     Exceptions raised by the callback will be noted on the standard
     error output, but cannot be propagated; they are handled in exactly
     the same way as exceptions raised from an object’s *note __del__():
     2c4. method.

     Weak references are *note hashable: bfd. if the `object' is
     hashable.  They will maintain their hash value even after the
     `object' was deleted.  If *note hash(): 39e. is called the first
     time only after the `object' was deleted, the call will raise *note
     TypeError: 309.

     Weak references support tests for equality, but not ordering.  If
     the referents are still alive, two references have the same
     equality relationship as their referents (regardless of the
     `callback').  If either referent has been deleted, the references
     are equal only if the reference objects are the same object.

     This is a subclassable type rather than a factory function.

      -- Attribute: __callback__

          This read-only attribute returns the callback currently
          associated to the weakref.  If there is no callback or if the
          referent of the weakref is no longer alive then this attribute
          will have value ‘None’.

     Changed in version 3.4: Added the *note __callback__: 2b4.
     attribute.

 -- Function: weakref.proxy (object[, callback])

     Return a proxy to `object' which uses a weak reference.  This
     supports use of the proxy in most contexts instead of requiring the
     explicit dereferencing used with weak reference objects.  The
     returned object will have a type of either ‘ProxyType’ or
     ‘CallableProxyType’, depending on whether `object' is callable.
     Proxy objects are not *note hashable: bfd. regardless of the
     referent; this avoids a number of problems related to their
     fundamentally mutable nature, and prevent their use as dictionary
     keys.  `callback' is the same as the parameter of the same name to
     the *note ref(): 2b3. function.

 -- Function: weakref.getweakrefcount (object)

     Return the number of weak references and proxies which refer to
     `object'.

 -- Function: weakref.getweakrefs (object)

     Return a list of all weak reference and proxy objects which refer
     to `object'.

 -- Class: weakref.WeakKeyDictionary ([dict])

     Mapping class that references keys weakly.  Entries in the
     dictionary will be discarded when there is no longer a strong
     reference to the key.  This can be used to associate additional
     data with an object owned by other parts of an application without
     adding attributes to those objects.  This can be especially useful
     with objects that override attribute accesses.

          Note: Caution: Because a *note WeakKeyDictionary: 1122. is
          built on top of a Python dictionary, it must not change size
          when iterating over it.  This can be difficult to ensure for a
          *note WeakKeyDictionary: 1122. because actions performed by
          the program during iteration may cause items in the dictionary
          to vanish "by magic" (as a side effect of garbage collection).

*note WeakKeyDictionary: 1122. objects have the following additional
methods.  These expose the internal references directly.  The references
are not guaranteed to be "live" at the time they are used, so the result
of calling the references needs to be checked before being used.  This
can be used to avoid creating references that will cause the garbage
collector to keep the keys around longer than needed.

 -- Method: WeakKeyDictionary.keyrefs ()

     Return an iterable of the weak references to the keys.

 -- Class: weakref.WeakValueDictionary ([dict])

     Mapping class that references values weakly.  Entries in the
     dictionary will be discarded when no strong reference to the value
     exists any more.

          Note: Caution: Because a *note WeakValueDictionary: 1123. is
          built on top of a Python dictionary, it must not change size
          when iterating over it.  This can be difficult to ensure for a
          *note WeakValueDictionary: 1123. because actions performed by
          the program during iteration may cause items in the dictionary
          to vanish "by magic" (as a side effect of garbage collection).

*note WeakValueDictionary: 1123. objects have the following additional
methods.  These method have the same issues as the and ‘keyrefs()’
method of *note WeakKeyDictionary: 1122. objects.

 -- Method: WeakValueDictionary.valuerefs ()

     Return an iterable of the weak references to the values.

 -- Class: weakref.WeakSet ([elements])

     Set class that keeps weak references to its elements.  An element
     will be discarded when no strong reference to it exists any more.

 -- Class: weakref.WeakMethod (method)

     A custom *note ref: 2b3. subclass which simulates a weak reference
     to a bound method (i.e., a method defined on a class and looked up
     on an instance).  Since a bound method is ephemeral, a standard
     weak reference cannot keep hold of it.  *note WeakMethod: 2b1. has
     special code to recreate the bound method until either the object
     or the original function dies:

          >>> class C:
          ...     def method(self):
          ...         print("method called!")
          ...
          >>> c = C()
          >>> r = weakref.ref(c.method)
          >>> r()
          >>> r = weakref.WeakMethod(c.method)
          >>> r()
          <bound method C.method of <__main__.C object at 0x7fc859830220>>
          >>> r()()
          method called!
          >>> del c
          >>> gc.collect()
          0
          >>> r()
          >>>

     New in version 3.4.

 -- Class: weakref.finalize (obj, func, *args, **kwargs)

     Return a callable finalizer object which will be called when `obj'
     is garbage collected.  Unlike an ordinary weak reference, a
     finalizer will always survive until the reference object is
     collected, greatly simplifying lifecycle management.

     A finalizer is considered `alive' until it is called (either
     explicitly or at garbage collection), and after that it is `dead'.
     Calling a live finalizer returns the result of evaluating
     ‘func(*arg, **kwargs)’, whereas calling a dead finalizer returns
     *note None: 2c6.

     Exceptions raised by finalizer callbacks during garbage collection
     will be shown on the standard error output, but cannot be
     propagated.  They are handled in the same way as exceptions raised
     from an object’s *note __del__(): 2c4. method or a weak reference’s
     callback.

     When the program exits, each remaining live finalizer is called
     unless its *note atexit: c. attribute has been set to false.  They
     are called in reverse order of creation.

     A finalizer will never invoke its callback during the later part of
     the interpreter shutdown when module globals are liable to have
     been replaced by *note None: 2c6.

      -- Method: __call__ ()

          If `self' is alive then mark it as dead and return the result
          of calling ‘func(*args, **kwargs)’.  If `self' is dead then
          return *note None: 2c6.

      -- Method: detach ()

          If `self' is alive then mark it as dead and return the tuple
          ‘(obj, func, args, kwargs)’.  If `self' is dead then return
          *note None: 2c6.

      -- Method: peek ()

          If `self' is alive then return the tuple ‘(obj, func, args,
          kwargs)’.  If `self' is dead then return *note None: 2c6.

      -- Attribute: alive

          Property which is true if the finalizer is alive, false
          otherwise.

      -- Attribute: atexit

          A writable boolean property which by default is true.  When
          the program exits, it calls all remaining live finalizers for
          which *note atexit: 112d. is true.  They are called in reverse
          order of creation.

          Note: It is important to ensure that `func', `args' and
          `kwargs' do not own any references to `obj', either directly
          or indirectly, since otherwise `obj' will never be garbage
          collected.  In particular, `func' should not be a bound method
          of `obj'.

     New in version 3.4.

 -- Data: weakref.ReferenceType

     The type object for weak references objects.

 -- Data: weakref.ProxyType

     The type object for proxies of objects which are not callable.

 -- Data: weakref.CallableProxyType

     The type object for proxies of callable objects.

 -- Data: weakref.ProxyTypes

     Sequence containing all the type objects for proxies.  This can
     make it simpler to test if an object is a proxy without being
     dependent on naming both proxy types.

 -- Exception: weakref.ReferenceError

     Exception raised when a proxy object is used but the underlying
     object has been collected.  This is the same as the standard *note
     ReferenceError: 8de. exception.

See also
........

PEP 0205(2) - Weak References

     The proposal and rationale for this feature, including links to
     earlier implementations and information about similar features in
     other languages.

* Menu:

* Weak Reference Objects:: 
* Example: Example<2>. 
* Finalizer Objects:: 
* Comparing finalizers with __del__() methods: Comparing finalizers with __del__ methods. 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/3.4/Lib/weakref.py

   (2) https://www.python.org/dev/peps/pep-0205


File: python.info,  Node: Weak Reference Objects,  Next: Example<2>,  Up: weakref --- Weak references

5.8.8.1 Weak Reference Objects
..............................

Weak reference objects have no methods and no attributes besides *note
ref.__callback__: 2b4.  A weak reference object allows the referent to
be obtained, if it still exists, by calling it:

     >>> import weakref
     >>> class Object:
     ...     pass
     ...
     >>> o = Object()
     >>> r = weakref.ref(o)
     >>> o2 = r()
     >>> o is o2
     True

If the referent no longer exists, calling the reference object returns
*note None: 2c6.:

     >>> del o, o2
     >>> print(r())
     None

Testing that a weak reference object is still live should be done using
the expression ‘ref() is not None’.  Normally, application code that
needs to use a reference object should follow this pattern:

     # r is a weak reference object
     o = r()
     if o is None:
         # referent has been garbage collected
         print("Object has been deallocated; can't frobnicate.")
     else:
         print("Object is still live!")
         o.do_something_useful()

Using a separate test for "liveness" creates race conditions in threaded
applications; another thread can cause a weak reference to become
invalidated before the weak reference is called; the idiom shown above
is safe in threaded applications as well as single-threaded
applications.

Specialized versions of *note ref: 2b3. objects can be created through
subclassing.  This is used in the implementation of the *note
WeakValueDictionary: 1123. to reduce the memory overhead for each entry
in the mapping.  This may be most useful to associate additional
information with a reference, but could also be used to insert
additional processing on calls to retrieve the referent.

This example shows how a subclass of *note ref: 2b3. can be used to
store additional information about an object and affect the value that’s
returned when the referent is accessed:

     import weakref

     class ExtendedRef(weakref.ref):
         def __init__(self, ob, callback=None, **annotations):
             super(ExtendedRef, self).__init__(ob, callback)
             self.__counter = 0
             for k, v in annotations.items():
                 setattr(self, k, v)

         def __call__(self):
             """Return a pair containing the referent and the number of
             times the reference has been called.
             """
             ob = super(ExtendedRef, self).__call__()
             if ob is not None:
                 self.__counter += 1
                 ob = (ob, self.__counter)
             return ob


File: python.info,  Node: Example<2>,  Next: Finalizer Objects,  Prev: Weak Reference Objects,  Up: weakref --- Weak references

5.8.8.2 Example
...............

This simple example shows how an application can use objects IDs to
retrieve objects that it has seen before.  The IDs of the objects can
then be used in other data structures without forcing the objects to
remain alive, but the objects can still be retrieved by ID if they do.

     import weakref

     _id2obj_dict = weakref.WeakValueDictionary()

     def remember(obj):
         oid = id(obj)
         _id2obj_dict[oid] = obj
         return oid

     def id2obj(oid):
         return _id2obj_dict[oid]


File: python.info,  Node: Finalizer Objects,  Next: Comparing finalizers with __del__ methods,  Prev: Example<2>,  Up: weakref --- Weak references

5.8.8.3 Finalizer Objects
.........................

The main benefit of using *note finalize: 2b2. is that it makes it
simple to register a callback without needing to preserve the returned
finalizer object.  For instance

     >>> import weakref
     >>> class Object:
     ...     pass
     ...
     >>> kenny = Object()
     >>> weakref.finalize(kenny, print, "You killed Kenny!")  #doctest:+ELLIPSIS
     <finalize object at ...; for 'Object' at ...>
     >>> del kenny
     You killed Kenny!

The finalizer can be called directly as well.  However the finalizer
will invoke the callback at most once.

     >>> def callback(x, y, z):
     ...     print("CALLBACK")
     ...     return x + y + z
     ...
     >>> obj = Object()
     >>> f = weakref.finalize(obj, callback, 1, 2, z=3)
     >>> assert f.alive
     >>> assert f() == 6
     CALLBACK
     >>> assert not f.alive
     >>> f()                     # callback not called because finalizer dead
     >>> del obj                 # callback not called because finalizer dead

You can unregister a finalizer using its *note detach(): 112a. method.
This kills the finalizer and returns the arguments passed to the
constructor when it was created.

     >>> obj = Object()
     >>> f = weakref.finalize(obj, callback, 1, 2, z=3)
     >>> f.detach()                                           #doctest:+ELLIPSIS
     (<__main__.Object object ...>, <function callback ...>, (1, 2), {'z': 3})
     >>> newobj, func, args, kwargs = _
     >>> assert not f.alive
     >>> assert newobj is obj
     >>> assert func(*args, **kwargs) == 6
     CALLBACK

Unless you set the *note atexit: 112d. attribute to *note False: 3c8, a
finalizer will be called when the program exits if it is still alive.
For instance

     >>> obj = Object()
     >>> weakref.finalize(obj, print, "obj dead or exiting")  #doctest:+ELLIPSIS
     <finalize object at ...; for 'Object' at ...>
     >>> exit()                                               #doctest:+SKIP
     obj dead or exiting


File: python.info,  Node: Comparing finalizers with __del__ methods,  Prev: Finalizer Objects,  Up: weakref --- Weak references

5.8.8.4 Comparing finalizers with ‘__del__()’ methods
.....................................................

Suppose we want to create a class whose instances represent temporary
directories.  The directories should be deleted with their contents when
the first of the following events occurs:

   * the object is garbage collected,

   * the object’s ‘remove()’ method is called, or

   * the program exits.

We might try to implement the class using a *note __del__(): 2c4. method
as follows:

     class TempDir:
         def __init__(self):
             self.name = tempfile.mkdtemp()

         def remove(self):
             if self.name is not None:
                 shutil.rmtree(self.name)
                 self.name = None

         @property
         def removed(self):
             return self.name is None

         def __del__(self):
             self.remove()

Starting with Python 3.4, *note __del__(): 2c4. methods no longer
prevent reference cycles from being garbage collected, and module
globals are no longer forced to *note None: 2c6. during interpreter
shutdown.  So this code should work without any issues on CPython.

However, handling of *note __del__(): 2c4. methods is notoriously
implementation specific, since it depends on internal details of the
interpreter’s garbage collector implementation.

A more robust alternative can be to define a finalizer which only
references the specific functions and objects that it needs, rather than
having access to the full state of the object:

     class TempDir:
         def __init__(self):
             self.name = tempfile.mkdtemp()
             self._finalizer = weakref.finalize(self, shutil.rmtree, self.name)

         def remove(self):
             self._finalizer()

         @property
         def removed(self):
             return not self._finalizer.alive

Defined like this, our finalizer only receives a reference to the
details it needs to clean up the directory appropriately.  If the object
never gets garbage collected the finalizer will still be called at exit.

The other advantage of weakref based finalizers is that they can be used
to register finalizers for classes where the definition is controlled by
a third party, such as running code when a module is unloaded:

     import weakref, sys
     def unloading_module():
         # implicit reference to the module globals from the function body
     weakref.finalize(sys.modules[__name__], unloading_module)

     Note: If you create a finalizer object in a daemonic thread just as
     the the program exits then there is the possibility that the
     finalizer does not get called at exit.  However, in a daemonic
     thread *note atexit.register(): 918, ‘try: ... finally: ...’ and
     ‘with: ...’ do not guarantee that cleanup occurs either.


File: python.info,  Node: types --- Dynamic type creation and names for built-in types,  Next: copy --- Shallow and deep copy operations,  Prev: weakref --- Weak references,  Up: Data Types

5.8.9 ‘types’ — Dynamic type creation and names for built-in types
------------------------------------------------------------------

`Source code:' Lib/types.py(1)

__________________________________________________________________

This module defines utility function to assist in dynamic creation of
new types.

It also defines names for some object types that are used by the
standard Python interpreter, but not exposed as builtins like *note int:
185. or *note str: 178. are.

Finally, it provides some additional type-related utility classes and
functions that are not fundamental enough to be builtins.

* Menu:

* Dynamic Type Creation:: 
* Standard Interpreter Types:: 
* Additional Utility Classes and Functions:: 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/3.4/Lib/types.py


File: python.info,  Node: Dynamic Type Creation,  Next: Standard Interpreter Types,  Up: types --- Dynamic type creation and names for built-in types

5.8.9.1 Dynamic Type Creation
.............................

 -- Function: types.new_class (name, bases=(), kwds=None,
          exec_body=None)

     Creates a class object dynamically using the appropriate metaclass.

     The first three arguments are the components that make up a class
     definition header: the class name, the base classes (in order), the
     keyword arguments (such as ‘metaclass’).

     The `exec_body' argument is a callback that is used to populate the
     freshly created class namespace.  It should accept the class
     namespace as its sole argument and update the namespace directly
     with the class contents.  If no callback is provided, it has the
     same effect as passing in ‘lambda ns: ns’.

     New in version 3.3.

 -- Function: types.prepare_class (name, bases=(), kwds=None)

     Calculates the appropriate metaclass and creates the class
     namespace.

     The arguments are the components that make up a class definition
     header: the class name, the base classes (in order) and the keyword
     arguments (such as ‘metaclass’).

     The return value is a 3-tuple: ‘metaclass, namespace, kwds’

     `metaclass' is the appropriate metaclass, `namespace' is the
     prepared class namespace and `kwds' is an updated copy of the
     passed in `kwds' argument with any ‘'metaclass'’ entry removed.  If
     no `kwds' argument is passed in, this will be an empty dict.

     New in version 3.3.

See also
........

*note Customizing class creation: c1f.

     Full details of the class creation process supported by these
     functions

PEP 3115(1) - Metaclasses in Python 3000

     Introduced the ‘__prepare__’ namespace hook

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-3115


File: python.info,  Node: Standard Interpreter Types,  Next: Additional Utility Classes and Functions,  Prev: Dynamic Type Creation,  Up: types --- Dynamic type creation and names for built-in types

5.8.9.2 Standard Interpreter Types
..................................

This module provides names for many of the types that are required to
implement a Python interpreter.  It deliberately avoids including some
of the types that arise only incidentally during processing such as the
‘listiterator’ type.

Typical use of these names is for *note isinstance(): 798. or *note
issubclass(): 799. checks.

Standard names are defined for the following types:

 -- Data: types.FunctionType
 -- Data: types.LambdaType

     The type of user-defined functions and functions created by *note
     lambda: 687. expressions.

 -- Data: types.GeneratorType

     The type of *note generator: 374.-iterator objects, produced by
     calling a generator function.

 -- Data: types.CodeType

     The type for code objects such as returned by *note compile(): 6fe.

 -- Data: types.MethodType

     The type of methods of user-defined class instances.

 -- Data: types.BuiltinFunctionType
 -- Data: types.BuiltinMethodType

     The type of built-in functions like *note len(): 358. or *note
     sys.exit(): 758, and methods of built-in classes.  (Here, the term
     "built-in" means "written in C".)

 -- Class: types.ModuleType (name, doc=None)

     The type of *note modules: c6c.  Constructor takes the name of the
     module to be created and optionally its *note docstring: d61.

      -- Attribute: __doc__

          The *note docstring: d61. of the module.  Defaults to ‘None’.

      -- Attribute: __loader__

          The *note loader: c7c. which loaded the module.  Defaults to
          ‘None’.

          Changed in version 3.4: Defaults to ‘None’.  Previously the
          attribute was optional.

      -- Attribute: __name__

          The name of the module.

      -- Attribute: __package__

          Which *note package: c72. a module belongs to.  If the module
          is top-level (i.e.  not a part of any specific package) then
          the attribute should be set to ‘''’, else it should be set to
          the name of the package (which can be *note __name__: 6cb. if
          the module is a package itself).  Defaults to ‘None’.

          Changed in version 3.4: Defaults to ‘None’.  Previously the
          attribute was optional.

 -- Data: types.TracebackType

     The type of traceback objects such as found in ‘sys.exc_info()[2]’.

 -- Data: types.FrameType

     The type of frame objects such as found in ‘tb.tb_frame’ if ‘tb’ is
     a traceback object.

 -- Data: types.GetSetDescriptorType

     The type of objects defined in extension modules with
     ‘PyGetSetDef’, such as ‘FrameType.f_locals’ or
     ‘array.array.typecode’.  This type is used as descriptor for object
     attributes; it has the same purpose as the *note property: 3ac.
     type, but for classes defined in extension modules.

 -- Data: types.MemberDescriptorType

     The type of objects defined in extension modules with
     ‘PyMemberDef’, such as ‘datetime.timedelta.days’.  This type is
     used as descriptor for simple C data members which use standard
     conversion functions; it has the same purpose as the *note
     property: 3ac. type, but for classes defined in extension modules.

     `CPython implementation detail:' In other implementations of
     Python, this type may be identical to ‘GetSetDescriptorType’.

 -- Class: types.MappingProxyType (mapping)

     Read-only proxy of a mapping.  It provides a dynamic view on the
     mapping’s entries, which means that when the mapping changes, the
     view reflects these changes.

     New in version 3.3.

      -- Describe: key in proxy

          Return ‘True’ if the underlying mapping has a key `key', else
          ‘False’.

      -- Describe: proxy[key]

          Return the item of the underlying mapping with key `key'.
          Raises a *note KeyError: 706. if `key' is not in the
          underlying mapping.

      -- Describe: iter(proxy)

          Return an iterator over the keys of the underlying mapping.
          This is a shortcut for ‘iter(proxy.keys())’.

      -- Describe: len(proxy)

          Return the number of items in the underlying mapping.

      -- Method: copy ()

          Return a shallow copy of the underlying mapping.

      -- Method: get (key[, default])

          Return the value for `key' if `key' is in the underlying
          mapping, else `default'.  If `default' is not given, it
          defaults to ‘None’, so that this method never raises a *note
          KeyError: 706.

      -- Method: items ()

          Return a new view of the underlying mapping’s items (‘(key,
          value)’ pairs).

      -- Method: keys ()

          Return a new view of the underlying mapping’s keys.

      -- Method: values ()

          Return a new view of the underlying mapping’s values.


File: python.info,  Node: Additional Utility Classes and Functions,  Prev: Standard Interpreter Types,  Up: types --- Dynamic type creation and names for built-in types

5.8.9.3 Additional Utility Classes and Functions
................................................

 -- Class: types.SimpleNamespace

     A simple *note object: 381. subclass that provides attribute access
     to its namespace, as well as a meaningful repr.

     Unlike *note object: 381, with ‘SimpleNamespace’ you can add and
     remove attributes.  If a ‘SimpleNamespace’ object is initialized
     with keyword arguments, those are directly added to the underlying
     namespace.

     The type is roughly equivalent to the following code:

          class SimpleNamespace:
              def __init__(self, **kwargs):
                  self.__dict__.update(kwargs)
              def __repr__(self):
                  keys = sorted(self.__dict__)
                  items = ("{}={!r}".format(k, self.__dict__[k]) for k in keys)
                  return "{}({})".format(type(self).__name__, ", ".join(items))
              def __eq__(self, other):
                  return self.__dict__ == other.__dict__

     ‘SimpleNamespace’ may be useful as a replacement for ‘class NS:
     pass’.  However, for a structured record type use *note
     namedtuple(): 66b. instead.

     New in version 3.3.

 -- Function: types.DynamicClassAttribute (fget=None, fset=None,
          fdel=None, doc=None)

     Route attribute access on a class to __getattr__.

     This is a descriptor, used to define attributes that act
     differently when accessed through an instance and through a class.
     Instance access remains normal, but access to an attribute through
     a class will be routed to the class’s __getattr__ method; this is
     done by raising AttributeError.

     This allows one to have properties active on an instance, and have
     virtual attributes on the class with the same name (see Enum for an
     example).

     New in version 3.4.


File: python.info,  Node: copy --- Shallow and deep copy operations,  Next: pprint --- Data pretty printer,  Prev: types --- Dynamic type creation and names for built-in types,  Up: Data Types

5.8.10 ‘copy’ — Shallow and deep copy operations
------------------------------------------------

Assignment statements in Python do not copy objects, they create
bindings between a target and an object.  For collections that are
mutable or contain mutable items, a copy is sometimes needed so one can
change one copy without changing the other.  This module provides
generic shallow and deep copy operations (explained below).

Interface summary:

 -- Function: copy.copy (x)

     Return a shallow copy of `x'.

 -- Function: copy.deepcopy (x)

     Return a deep copy of `x'.

 -- Exception: copy.error

     Raised for module specific errors.

The difference between shallow and deep copying is only relevant for
compound objects (objects that contain other objects, like lists or
class instances):

   * A `shallow copy' constructs a new compound object and then (to the
     extent possible) inserts `references' into it to the objects found
     in the original.

   * A `deep copy' constructs a new compound object and then,
     recursively, inserts `copies' into it of the objects found in the
     original.

Two problems often exist with deep copy operations that don’t exist with
shallow copy operations:

   * Recursive objects (compound objects that, directly or indirectly,
     contain a reference to themselves) may cause a recursive loop.

   * Because deep copy copies `everything' it may copy too much, e.g.,
     administrative data structures that should be shared even between
     copies.

The *note deepcopy(): 70a. function avoids these problems by:

   * keeping a "memo" dictionary of objects already copied during the
     current copying pass; and

   * letting user-defined classes override the copying operation or the
     set of components copied.

This module does not copy types like module, method, stack trace, stack
frame, file, socket, window, array, or any similar types.  It does
"copy" functions and classes (shallow and deeply), by returning the
original object unchanged; this is compatible with the way these are
treated by the *note pickle: c6. module.

Shallow copies of dictionaries can be made using *note dict.copy(): e77,
and of lists by assigning a slice of the entire list, for example,
‘copied_list = original_list[:]’.

Classes can use the same interfaces to control copying that they use to
control pickling.  See the description of module *note pickle: c6. for
information on these methods.  In fact, *note copy: 25. module uses the
registered pickle functions from *note copyreg: 26. module.

In order for a class to define its own copy implementation, it can
define special methods ‘__copy__()’ and ‘__deepcopy__()’.  The former is
called to implement the shallow copy operation; no additional arguments
are passed.  The latter is called to implement the deep copy operation;
it is passed one argument, the memo dictionary.  If the ‘__deepcopy__()’
implementation needs to make a deep copy of a component, it should call
the *note deepcopy(): 70a. function with the component as first argument
and the memo dictionary as second argument.

See also
........

Module *note pickle: c6.

     Discussion of the special methods used to support object state
     retrieval and restoration.


File: python.info,  Node: pprint --- Data pretty printer,  Next: reprlib --- Alternate repr implementation,  Prev: copy --- Shallow and deep copy operations,  Up: Data Types

5.8.11 ‘pprint’ — Data pretty printer
-------------------------------------

`Source code:' Lib/pprint.py(1)

__________________________________________________________________

The *note pprint: ce. module provides a capability to "pretty-print"
arbitrary Python data structures in a form which can be used as input to
the interpreter.  If the formatted structures include objects which are
not fundamental Python types, the representation may not be loadable.
This may be the case if objects such as files, sockets or classes are
included, as well as many other objects which are not representable as
Python literals.

The formatted representation keeps objects on a single line if it can,
and breaks them onto multiple lines if they don’t fit within the allowed
width.  Construct *note PrettyPrinter: 22b. objects explicitly if you
need to adjust the width constraint.

Dictionaries are sorted by key before the display is computed.

The *note pprint: ce. module defines one class:

 -- Class: pprint.PrettyPrinter (indent=1, width=80, depth=None,
          stream=None, *, compact=False)

     Construct a *note PrettyPrinter: 22b. instance.  This constructor
     understands several keyword parameters.  An output stream may be
     set using the `stream' keyword; the only method used on the stream
     object is the file protocol’s ‘write()’ method.  If not specified,
     the *note PrettyPrinter: 22b. adopts ‘sys.stdout’.  The amount of
     indentation added for each recursive level is specified by
     `indent'; the default is one.  Other values can cause output to
     look a little odd, but can make nesting easier to spot.  The number
     of levels which may be printed is controlled by `depth'; if the
     data structure being printed is too deep, the next contained level
     is replaced by ‘...’.  By default, there is no constraint on the
     depth of the objects being formatted.  The desired output width is
     constrained using the `width' parameter; the default is 80
     characters.  If a structure cannot be formatted within the
     constrained width, a best effort will be made.  If `compact' is
     false (the default) each item of a long sequence will be formatted
     on a separate line.  If `compact' is true, as many items as will
     fit within the `width' will be formatted on each output line.

     Changed in version 3.4: Added the `compact' parameter.

          >>> import pprint
          >>> stuff = ['spam', 'eggs', 'lumberjack', 'knights', 'ni']
          >>> stuff.insert(0, stuff[:])
          >>> pp = pprint.PrettyPrinter(indent=4)
          >>> pp.pprint(stuff)
          [   ['spam', 'eggs', 'lumberjack', 'knights', 'ni'],
              'spam',
              'eggs',
              'lumberjack',
              'knights',
              'ni']
          >>> pp = pprint.PrettyPrinter(width=41, compact=True)
          >>> pp.pprint(stuff)
          [['spam', 'eggs', 'lumberjack',
            'knights', 'ni'],
           'spam', 'eggs', 'lumberjack', 'knights',
           'ni']
          >>> tup = ('spam', ('eggs', ('lumberjack', ('knights', ('ni', ('dead',
          ... ('parrot', ('fresh fruit',))))))))
          >>> pp = pprint.PrettyPrinter(depth=6)
          >>> pp.pprint(tup)
          ('spam', ('eggs', ('lumberjack', ('knights', ('ni', ('dead', (...)))))))

The *note pprint: ce. module also provides several shortcut functions:

 -- Function: pprint.pformat (object, indent=1, width=80, depth=None, *,
          compact=False)

     Return the formatted representation of `object' as a string.
     `indent', `width', `depth' and `compact' will be passed to the
     *note PrettyPrinter: 22b. constructor as formatting parameters.

     Changed in version 3.4: Added the `compact' parameter.

 -- Function: pprint.pprint (object, stream=None, indent=1, width=80,
          depth=None, *, compact=False)

     Prints the formatted representation of `object' on `stream',
     followed by a newline.  If `stream' is ‘None’, ‘sys.stdout’ is
     used.  This may be used in the interactive interpreter instead of
     the *note print(): 21c. function for inspecting values (you can
     even reassign ‘print = pprint.pprint’ for use within a scope).
     `indent', `width', `depth' and `compact' will be passed to the
     *note PrettyPrinter: 22b. constructor as formatting parameters.

     Changed in version 3.4: Added the `compact' parameter.

          >>> import pprint
          >>> stuff = ['spam', 'eggs', 'lumberjack', 'knights', 'ni']
          >>> stuff.insert(0, stuff)
          >>> pprint.pprint(stuff)
          [<Recursion on list with id=...>,
           'spam',
           'eggs',
           'lumberjack',
           'knights',
           'ni']

 -- Function: pprint.isreadable (object)

     Determine if the formatted representation of `object' is
     "readable," or can be used to reconstruct the value using *note
     eval(): 5d2.  This always returns ‘False’ for recursive objects.

          >>> pprint.isreadable(stuff)
          False

 -- Function: pprint.isrecursive (object)

     Determine if `object' requires a recursive representation.

One more support function is also defined:

 -- Function: pprint.saferepr (object)

     Return a string representation of `object', protected against
     recursive data structures.  If the representation of `object'
     exposes a recursive entry, the recursive reference will be
     represented as ‘<Recursion on typename with id=number>’.  The
     representation is not otherwise formatted.

          >>> pprint.saferepr(stuff)
          "[<Recursion on list with id=...>, 'spam', 'eggs', 'lumberjack', 'knights', 'ni']"

* Menu:

* PrettyPrinter Objects:: 
* Example: Example<3>. 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/3.4/Lib/pprint.py


File: python.info,  Node: PrettyPrinter Objects,  Next: Example<3>,  Up: pprint --- Data pretty printer

5.8.11.1 PrettyPrinter Objects
..............................

*note PrettyPrinter: 22b. instances have the following methods:

 -- Method: PrettyPrinter.pformat (object)

     Return the formatted representation of `object'.  This takes into
     account the options passed to the *note PrettyPrinter: 22b.
     constructor.

 -- Method: PrettyPrinter.pprint (object)

     Print the formatted representation of `object' on the configured
     stream, followed by a newline.

The following methods provide the implementations for the corresponding
functions of the same names.  Using these methods on an instance is
slightly more efficient since new *note PrettyPrinter: 22b. objects
don’t need to be created.

 -- Method: PrettyPrinter.isreadable (object)

     Determine if the formatted representation of the object is
     "readable," or can be used to reconstruct the value using *note
     eval(): 5d2.  Note that this returns ‘False’ for recursive objects.
     If the `depth' parameter of the *note PrettyPrinter: 22b. is set
     and the object is deeper than allowed, this returns ‘False’.

 -- Method: PrettyPrinter.isrecursive (object)

     Determine if the object requires a recursive representation.

This method is provided as a hook to allow subclasses to modify the way
objects are converted to strings.  The default implementation uses the
internals of the *note saferepr(): 115a. implementation.

 -- Method: PrettyPrinter.format (object, context, maxlevels, level)

     Returns three values: the formatted version of `object' as a
     string, a flag indicating whether the result is readable, and a
     flag indicating whether recursion was detected.  The first argument
     is the object to be presented.  The second is a dictionary which
     contains the *note id(): 806. of objects that are part of the
     current presentation context (direct and indirect containers for
     `object' that are affecting the presentation) as the keys; if an
     object needs to be presented which is already represented in
     `context', the third return value should be ‘True’.  Recursive
     calls to the *note format(): 556. method should add additional
     entries for containers to this dictionary.  The third argument,
     `maxlevels', gives the requested limit to recursion; this will be
     ‘0’ if there is no requested limit.  This argument should be passed
     unmodified to recursive calls.  The fourth argument, `level', gives
     the current level; recursive calls should be passed a value less
     than that of the current call.


File: python.info,  Node: Example<3>,  Prev: PrettyPrinter Objects,  Up: pprint --- Data pretty printer

5.8.11.2 Example
................

To demonstrate several uses of the *note pprint(): ce. function and its
parameters, let’s fetch information about a project from PyPI(1):

     >>> import json
     >>> import pprint
     >>> from urllib.request import urlopen
     >>> with urlopen('http://pypi.python.org/pypi/Twisted/json') as url:
     ...     http_info = url.info()
     ...     raw_data = url.read().decode(http_info.get_content_charset())
     >>> project_info = json.loads(raw_data)

In its basic form, *note pprint(): ce. shows the whole object:

     >>> pprint.pprint(project_info)
     {'info': {'_pypi_hidden': False,
               '_pypi_ordering': 125,
               'author': 'Glyph Lefkowitz',
               'author_email': 'glyph@twistedmatrix.com',
               'bugtrack_url': '',
               'cheesecake_code_kwalitee_id': None,
               'cheesecake_documentation_id': None,
               'cheesecake_installability_id': None,
               'classifiers': ['Programming Language :: Python :: 2.6',
                               'Programming Language :: Python :: 2.7',
                               'Programming Language :: Python :: 2 :: Only'],
               'description': 'An extensible framework for Python programming, '
                              'with special focus\r\n'
                              'on event-based network programming and '
                              'multiprotocol integration.',
               'docs_url': '',
               'download_url': 'UNKNOWN',
               'home_page': 'http://twistedmatrix.com/',
               'keywords': '',
               'license': 'MIT',
               'maintainer': '',
               'maintainer_email': '',
               'name': 'Twisted',
               'package_url': 'http://pypi.python.org/pypi/Twisted',
               'platform': 'UNKNOWN',
               'release_url': 'http://pypi.python.org/pypi/Twisted/12.3.0',
               'requires_python': None,
               'stable_version': None,
               'summary': 'An asynchronous networking framework written in Python',
               'version': '12.3.0'},
      'urls': [{'comment_text': '',
                'downloads': 71844,
                'filename': 'Twisted-12.3.0.tar.bz2',
                'has_sig': False,
                'md5_digest': '6e289825f3bf5591cfd670874cc0862d',
                'packagetype': 'sdist',
                'python_version': 'source',
                'size': 2615733,
                'upload_time': '2012-12-26T12:47:03',
                'url': 'https://pypi.python.org/packages/source/T/Twisted/Twisted-12.3.0.tar.bz2'},
               {'comment_text': '',
                'downloads': 5224,
                'filename': 'Twisted-12.3.0.win32-py2.7.msi',
                'has_sig': False,
                'md5_digest': '6b778f5201b622a5519a2aca1a2fe512',
                'packagetype': 'bdist_msi',
                'python_version': '2.7',
                'size': 2916352,
                'upload_time': '2012-12-26T12:48:15',
                'url': 'https://pypi.python.org/packages/2.7/T/Twisted/Twisted-12.3.0.win32-py2.7.msi'}]}

The result can be limited to a certain `depth' (ellipsis is used for
deeper contents):

     >>> pprint.pprint(project_info, depth=2)
     {'info': {'_pypi_hidden': False,
               '_pypi_ordering': 125,
               'author': 'Glyph Lefkowitz',
               'author_email': 'glyph@twistedmatrix.com',
               'bugtrack_url': '',
               'cheesecake_code_kwalitee_id': None,
               'cheesecake_documentation_id': None,
               'cheesecake_installability_id': None,
               'classifiers': [...],
               'description': 'An extensible framework for Python programming, '
                              'with special focus\r\n'
                              'on event-based network programming and '
                              'multiprotocol integration.',
               'docs_url': '',
               'download_url': 'UNKNOWN',
               'home_page': 'http://twistedmatrix.com/',
               'keywords': '',
               'license': 'MIT',
               'maintainer': '',
               'maintainer_email': '',
               'name': 'Twisted',
               'package_url': 'http://pypi.python.org/pypi/Twisted',
               'platform': 'UNKNOWN',
               'release_url': 'http://pypi.python.org/pypi/Twisted/12.3.0',
               'requires_python': None,
               'stable_version': None,
               'summary': 'An asynchronous networking framework written in Python',
               'version': '12.3.0'},
      'urls': [{...}, {...}]}

Additionally, maximum character `width' can be suggested.  If a long
object cannot be split, the specified width will be exceeded:

     >>> pprint.pprint(project_info, depth=2, width=50)
     {'info': {'_pypi_hidden': False,
               '_pypi_ordering': 125,
               'author': 'Glyph Lefkowitz',
               'author_email': 'glyph@twistedmatrix.com',
               'bugtrack_url': '',
               'cheesecake_code_kwalitee_id': None,
               'cheesecake_documentation_id': None,
               'cheesecake_installability_id': None,
               'classifiers': [...],
               'description': 'An extensible '
                              'framework for '
                              'Python programming, '
                              'with special '
                              'focus\r\n'
                              'on event-based '
                              'network programming '
                              'and multiprotocol '
                              'integration.',
               'docs_url': '',
               'download_url': 'UNKNOWN',
               'home_page': 'http://twistedmatrix.com/',
               'keywords': '',
               'license': 'MIT',
               'maintainer': '',
               'maintainer_email': '',
               'name': 'Twisted',
               'package_url': 'http://pypi.python.org/pypi/Twisted',
               'platform': 'UNKNOWN',
               'release_url': 'http://pypi.python.org/pypi/Twisted/12.3.0',
               'requires_python': None,
               'stable_version': None,
               'summary': 'An asynchronous '
                          'networking framework '
                          'written in Python',
               'version': '12.3.0'},
      'urls': [{...}, {...}]}

   ---------- Footnotes ----------

   (1) https://pypi.python.org/pypi


File: python.info,  Node: reprlib --- Alternate repr implementation,  Next: enum --- Support for enumerations,  Prev: pprint --- Data pretty printer,  Up: Data Types

5.8.12 ‘reprlib’ — Alternate ‘repr()’ implementation
----------------------------------------------------

`Source code:' Lib/reprlib.py(1)

__________________________________________________________________

The *note reprlib: db. module provides a means for producing object
representations with limits on the size of the resulting strings.  This
is used in the Python debugger and may be useful in other contexts as
well.

This module provides a class, an instance, and a function:

 -- Class: reprlib.Repr

     Class which provides formatting services useful in implementing
     functions similar to the built-in *note repr(): 3db.; size limits
     for different object types are added to avoid the generation of
     representations which are excessively long.

 -- Data: reprlib.aRepr

     This is an instance of *note Repr: 1166. which is used to provide
     the *note repr(): 1168. function described below.  Changing the
     attributes of this object will affect the size limits used by *note
     repr(): 1168. and the Python debugger.

 -- Function: reprlib.repr (obj)

     This is the *note repr(): 1169. method of ‘aRepr’.  It returns a
     string similar to that returned by the built-in function of the
     same name, but with limits on most sizes.

In addition to size-limiting tools, the module also provides a decorator
for detecting recursive calls to *note __repr__(): 5a3. and substituting
a placeholder string instead.

 -- Function: @ reprlib.recursive_repr (fillvalue="...")

     Decorator for *note __repr__(): 5a3. methods to detect recursive
     calls within the same thread.  If a recursive call is made, the
     `fillvalue' is returned, otherwise, the usual *note __repr__():
     5a3. call is made.  For example:

          >>> class MyList(list):
          ...     @recursive_repr()
          ...     def __repr__(self):
          ...         return '<' + '|'.join(map(repr, self)) + '>'
          ...
          >>> m = MyList('abc')
          >>> m.append(m)
          >>> m.append('x')
          >>> print(m)
          <'a'|'b'|'c'|...|'x'>

     New in version 3.2.

* Menu:

* Repr Objects:: 
* Subclassing Repr Objects:: 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/3.4/Lib/reprlib.py


File: python.info,  Node: Repr Objects,  Next: Subclassing Repr Objects,  Up: reprlib --- Alternate repr implementation

5.8.12.1 Repr Objects
.....................

*note Repr: 1166. instances provide several attributes which can be used
to provide size limits for the representations of different object
types, and methods which format specific object types.

 -- Attribute: Repr.maxlevel

     Depth limit on the creation of recursive representations.  The
     default is ‘6’.

 -- Attribute: Repr.maxdict
 -- Attribute: Repr.maxlist
 -- Attribute: Repr.maxtuple
 -- Attribute: Repr.maxset
 -- Attribute: Repr.maxfrozenset
 -- Attribute: Repr.maxdeque
 -- Attribute: Repr.maxarray

     Limits on the number of entries represented for the named object
     type.  The default is ‘4’ for *note maxdict: 116d, ‘5’ for *note
     maxarray: 1173, and ‘6’ for the others.

 -- Attribute: Repr.maxlong

     Maximum number of characters in the representation for an integer.
     Digits are dropped from the middle.  The default is ‘40’.

 -- Attribute: Repr.maxstring

     Limit on the number of characters in the representation of the
     string.  Note that the "normal" representation of the string is
     used as the character source: if escape sequences are needed in the
     representation, these may be mangled when the representation is
     shortened.  The default is ‘30’.

 -- Attribute: Repr.maxother

     This limit is used to control the size of object types for which no
     specific formatting method is available on the *note Repr: 1166.
     object.  It is applied in a similar manner as *note maxstring:
     1175.  The default is ‘20’.

 -- Method: Repr.repr (obj)

     The equivalent to the built-in *note repr(): 3db. that uses the
     formatting imposed by the instance.

 -- Method: Repr.repr1 (obj, level)

     Recursive implementation used by *note repr(): 1169.  This uses the
     type of `obj' to determine which formatting method to call, passing
     it `obj' and `level'.  The type-specific methods should call *note
     repr1(): 1177. to perform recursive formatting, with ‘level - 1’
     for the value of `level' in the recursive call.

 -- Method: Repr.repr_TYPE (obj, level)

     Formatting methods for specific types are implemented as methods
     with a name based on the type name.  In the method name, `TYPE' is
     replaced by ‘'_'.join(type(obj).__name__.split())’.  Dispatch to
     these methods is handled by *note repr1(): 1177.  Type-specific
     methods which need to recursively format a value should call
     ‘self.repr1(subobj, level - 1)’.


File: python.info,  Node: Subclassing Repr Objects,  Prev: Repr Objects,  Up: reprlib --- Alternate repr implementation

5.8.12.2 Subclassing Repr Objects
.................................

The use of dynamic dispatching by *note Repr.repr1(): 1177. allows
subclasses of *note Repr: 1166. to add support for additional built-in
object types or to modify the handling of types already supported.  This
example shows how special support for file objects could be added:

     import reprlib
     import sys

     class MyRepr(reprlib.Repr):

         def repr_TextIOWrapper(self, obj, level):
             if obj.name in {'<stdin>', '<stdout>', '<stderr>'}:
                 return obj.name
             return repr(obj)

     aRepr = MyRepr()
     print(aRepr.repr(sys.stdin))         # prints '<stdin>'


File: python.info,  Node: enum --- Support for enumerations,  Prev: reprlib --- Alternate repr implementation,  Up: Data Types

5.8.13 ‘enum’ — Support for enumerations
----------------------------------------

New in version 3.4.

`Source code:' Lib/enum.py(1)

__________________________________________________________________

An enumeration is a set of symbolic names (members) bound to unique,
constant values.  Within an enumeration, the members can be compared by
identity, and the enumeration itself can be iterated over.

* Menu:

* Module Contents: Module Contents<2>. 
* Creating an Enum:: 
* Programmatic access to enumeration members and their attributes:: 
* Duplicating enum members and values:: 
* Ensuring unique enumeration values:: 
* Iteration:: 
* Comparisons: Comparisons<3>. 
* Allowed members and attributes of enumerations:: 
* Restricted subclassing of enumerations:: 
* Pickling:: 
* Functional API:: 
* Derived Enumerations:: 
* Interesting examples:: 
* How are Enums different?:: 

   ---------- Footnotes ----------

   (1) https://hg.python.org/cpython/file/3.4/Lib/enum.py


File: python.info,  Node: Module Contents<2>,  Next: Creating an Enum,  Up: enum --- Support for enumerations

5.8.13.1 Module Contents
........................

This module defines two enumeration classes that can be used to define
unique sets of names and values: *note Enum: 10d6. and *note IntEnum:
117d.  It also defines one decorator, *note unique(): 117e.

 -- Class: enum.Enum

     Base class for creating enumerated constants.  See section *note
     Functional API: 117f. for an alternate construction syntax.

 -- Class: enum.IntEnum

     Base class for creating enumerated constants that are also
     subclasses of *note int: 185.

 -- Function: enum.unique ()

     Enum class decorator that ensures only one name is bound to any one
     value.


File: python.info,  Node: Creating an Enum,  Next: Programmatic access to enumeration members and their attributes,  Prev: Module Contents<2>,  Up: enum --- Support for enumerations

5.8.13.2 Creating an Enum
.........................

Enumerations are created using the *note class: 6ce. syntax, which makes
them easy to read and write.  An alternative creation method is
described in *note Functional API: 117f.  To define an enumeration,
subclass *note Enum: 10d6. as follows:

     >>> from enum import Enum
     >>> class Color(Enum):
     ...     red = 1
     ...     green = 2
     ...     blue = 3
     ...

     Note: Nomenclature

        - The class ‘Color’ is an `enumeration' (or `enum')

        - The attributes ‘Color.red’, ‘Color.green’, etc., are
          `enumeration members' (or `enum members').

        - The enum members have `names' and `values' (the name of
          ‘Color.red’ is ‘red’, the value of ‘Color.blue’ is ‘3’, etc.)

     Note: Even though we use the *note class: 6ce. syntax to create
     Enums, Enums are not normal Python classes.  See *note How are
     Enums different?: 1181. for more details.

Enumeration members have human readable string representations:

     >>> print(Color.red)
     Color.red

...while their ‘repr’ has more information:

     >>> print(repr(Color.red))
     <Color.red: 1>

The `type' of an enumeration member is the enumeration it belongs to:

     >>> type(Color.red)
     <enum 'Color'>
     >>> isinstance(Color.green, Color)
     True
     >>>

Enum members also have a property that contains just their item name:

     >>> print(Color.red.name)
     red

Enumerations support iteration, in definition order:

     >>> class Shake(Enum):
     ...     vanilla = 7
     ...     chocolate = 4
     ...     cookies = 9
     ...     mint = 3
     ...
     >>> for shake in Shake:
     ...     print(shake)
     ...
     Shake.vanilla
     Shake.chocolate
     Shake.cookies
     Shake.mint

Enumeration members are hashable, so they can be used in dictionaries
and sets:

     >>> apples = {}
     >>> apples[Color.red] = 'red delicious'
     >>> apples[Color.green] = 'granny smith'
     >>> apples == {Color.red: 'red delicious', Color.green: 'granny smith'}
     True


File: python.info,  Node: Programmatic access to enumeration members and their attributes,  Next: Duplicating enum members and values,  Prev: Creating an Enum,  Up: enum --- Support for enumerations

5.8.13.3 Programmatic access to enumeration members and their attributes
........................................................................

Sometimes it’s useful to access members in enumerations programmatically
(i.e.  situations where ‘Color.red’ won’t do because the exact color is
not known at program-writing time).  ‘Enum’ allows such access:

     >>> Color(1)
     <Color.red: 1>
     >>> Color(3)
     <Color.blue: 3>

If you want to access enum members by `name', use item access:

     >>> Color['red']
     <Color.red: 1>
     >>> Color['green']
     <Color.green: 2>

If you have an enum member and need its ‘name’ or ‘value’:

     >>> member = Color.red
     >>> member.name
     'red'
     >>> member.value
     1


File: python.info,  Node: Duplicating enum members and values,  Next: Ensuring unique enumeration values,  Prev: Programmatic access to enumeration members and their attributes,  Up: enum --- Support for enumerations

5.8.13.4 Duplicating enum members and values
............................................

Having two enum members with the same name is invalid:

     >>> class Shape(Enum):
     ...     square = 2
     ...     square = 3
     ...
     Traceback (most recent call last):
     ...
     TypeError: Attempted to reuse key: 'square'

However, two enum members are allowed to have the same value.  Given two
members A and B with the same value (and A defined first), B is an alias
to A. By-value lookup of the value of A and B will return A. By-name
lookup of B will also return A:

     >>> class Shape(Enum):
     ...     square = 2
     ...     diamond = 1
     ...     circle = 3
     ...     alias_for_square = 2
     ...
     >>> Shape.square
     <Shape.square: 2>
     >>> Shape.alias_for_square
     <Shape.square: 2>
     >>> Shape(2)
     <Shape.square: 2>

     Note: Attempting to create a member with the same name as an
     already defined attribute (another member, a method, etc.)  or
     attempting to create an attribute with the same