This is python.info, produced by makeinfo version 5.2 from python.texi.

     Python 3.4.3, September 02, 2015

     Copyright © 1990-2015, Python Software Foundation

INFO-DIR-SECTION Python
START-INFO-DIR-ENTRY
* Python: (python.info). The Python reference manual.
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.3.1.


File: python.info,  Node: Multiple Inheritance,  Up: Inheritance

2.9.5.1 Multiple Inheritance
............................

Python supports a form of multiple inheritance as well.  A class
definition with multiple base classes looks like this:

     class DerivedClassName(Base1, Base2, Base3):
         <statement-1>
         .
         .
         .
         <statement-N>

For most purposes, in the simplest cases, you can think of the search
for attributes inherited from a parent class as depth-first,
left-to-right, not searching twice in the same class where there is an
overlap in the hierarchy.  Thus, if an attribute is not found in
‘DerivedClassName’, it is searched for in ‘Base1’, then (recursively) in
the base classes of ‘Base1’, and if it was not found there, it was
searched for in ‘Base2’, and so on.

In fact, it is slightly more complex than that; the method resolution
order changes dynamically to support cooperative calls to *note super():
311.  This approach is known in some other multiple-inheritance
languages as call-next-method and is more powerful than the super call
found in single-inheritance languages.

Dynamic ordering is necessary because all cases of multiple inheritance
exhibit one or more diamond relationships (where at least one of the
parent classes can be accessed through multiple paths from the
bottommost class).  For example, all classes inherit from *note object:
381, so any case of multiple inheritance provides more than one path to
reach *note object: 381.  To keep the base classes from being accessed
more than once, the dynamic algorithm linearizes the search order in a
way that preserves the left-to-right ordering specified in each class,
that calls each parent only once, and that is monotonic (meaning that a
class can be subclassed without affecting the precedence order of its
parents).  Taken together, these properties make it possible to design
reliable and extensible classes with multiple inheritance.  For more
detail, see ‘https://www.python.org/download/releases/2.3/mro/’.


File: python.info,  Node: Private Variables,  Next: Odds and Ends,  Prev: Inheritance,  Up: Classes

2.9.6 Private Variables
-----------------------

"Private" instance variables that cannot be accessed except from inside
an object don’t exist in Python.  However, there is a convention that is
followed by most Python code: a name prefixed with an underscore (e.g.
‘_spam’) should be treated as a non-public part of the API (whether it
is a function, a method or a data member).  It should be considered an
implementation detail and subject to change without notice.

Since there is a valid use-case for class-private members (namely to
avoid name clashes of names with names defined by subclasses), there is
limited support for such a mechanism, called `name mangling'.  Any
identifier of the form ‘__spam’ (at least two leading underscores, at
most one trailing underscore) is textually replaced with
‘_classname__spam’, where ‘classname’ is the current class name with
leading underscore(s) stripped.  This mangling is done without regard to
the syntactic position of the identifier, as long as it occurs within
the definition of a class.

Name mangling is helpful for letting subclasses override methods without
breaking intraclass method calls.  For example:

     class Mapping:
         def __init__(self, iterable):
             self.items_list = []
             self.__update(iterable)

         def update(self, iterable):
             for item in iterable:
                 self.items_list.append(item)

         __update = update   # private copy of original update() method

     class MappingSubclass(Mapping):

         def update(self, keys, values):
             # provides new signature for update()
             # but does not break __init__()
             for item in zip(keys, values):
                 self.items_list.append(item)

Note that the mangling rules are designed mostly to avoid accidents; it
still is possible to access or modify a variable that is considered
private.  This can even be useful in special circumstances, such as in
the debugger.

Notice that code passed to ‘exec()’ or ‘eval()’ does not consider the
classname of the invoking class to be the current class; this is similar
to the effect of the ‘global’ statement, the effect of which is likewise
restricted to code that is byte-compiled together.  The same restriction
applies to ‘getattr()’, ‘setattr()’ and ‘delattr()’, as well as when
referencing ‘__dict__’ directly.


File: python.info,  Node: Odds and Ends,  Next: Exceptions Are Classes Too,  Prev: Private Variables,  Up: Classes

2.9.7 Odds and Ends
-------------------

Sometimes it is useful to have a data type similar to the Pascal
"record" or C "struct", bundling together a few named data items.  An
empty class definition will do nicely:

     class Employee:
         pass

     john = Employee() # Create an empty employee record

     # Fill the fields of the record
     john.name = 'John Doe'
     john.dept = 'computer lab'
     john.salary = 1000

A piece of Python code that expects a particular abstract data type can
often be passed a class that emulates the methods of that data type
instead.  For instance, if you have a function that formats some data
from a file object, you can define a class with methods ‘read()’ and
‘readline()’ that get the data from a string buffer instead, and pass it
as an argument.

Instance method objects have attributes, too: ‘m.__self__’ is the
instance object with the method ‘m()’, and ‘m.__func__’ is the function
object corresponding to the method.


File: python.info,  Node: Exceptions Are Classes Too,  Next: Iterators,  Prev: Odds and Ends,  Up: Classes

2.9.8 Exceptions Are Classes Too
--------------------------------

User-defined exceptions are identified by classes as well.  Using this
mechanism it is possible to create extensible hierarchies of exceptions.

There are two new valid (semantic) forms for the *note raise: 69d.
statement:

     raise Class

     raise Instance

In the first form, ‘Class’ must be an instance of *note type: 8c1. or of
a class derived from it.  The first form is a shorthand for:

     raise Class()

A class in an *note except: 563. clause is compatible with an exception
if it is the same class or a base class thereof (but not the other way
around — an except clause listing a derived class is not compatible with
a base class).  For example, the following code will print B, C, D in
that order:

     class B(Exception):
         pass
     class C(B):
         pass
     class D(C):
         pass

     for cls in [B, C, D]:
         try:
             raise cls()
         except D:
             print("D")
         except C:
             print("C")
         except B:
             print("B")

Note that if the except clauses were reversed (with ‘except B’ first),
it would have printed B, B, B — the first matching except clause is
triggered.

When an error message is printed for an unhandled exception, the
exception’s class name is printed, then a colon and a space, and finally
the instance converted to a string using the built-in function *note
str(): 178.


File: python.info,  Node: Iterators,  Next: Generators,  Prev: Exceptions Are Classes Too,  Up: Classes

2.9.9 Iterators
---------------

By now you have probably noticed that most container objects can be
looped over using a *note for: 688. statement:

     for element in [1, 2, 3]:
         print(element)
     for element in (1, 2, 3):
         print(element)
     for key in {'one':1, 'two':2}:
         print(key)
     for char in "123":
         print(char)
     for line in open("myfile.txt"):
         print(line, end='')

This style of access is clear, concise, and convenient.  The use of
iterators pervades and unifies Python.  Behind the scenes, the *note
for: 688. statement calls *note iter(): 79a. on the container object.
The function returns an iterator object that defines the method *note
__next__(): 6c7. which accesses elements in the container one at a time.
When there are no more elements, *note __next__(): 6c7. raises a *note
StopIteration: 7a5. exception which tells the *note for: 688. loop to
terminate.  You can call the *note __next__(): 6c7. method using the
*note next(): 6c6. built-in function; this example shows how it all
works:

     >>> s = 'abc'
     >>> it = iter(s)
     >>> it
     <iterator object at 0x00A1DB50>
     >>> next(it)
     'a'
     >>> next(it)
     'b'
     >>> next(it)
     'c'
     >>> next(it)
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
         next(it)
     StopIteration

Having seen the mechanics behind the iterator protocol, it is easy to
add iterator behavior to your classes.  Define an *note __iter__(): 79b.
method which returns an object with a *note __next__(): 6c7. method.  If
the class defines ‘__next__()’, then *note __iter__(): 79b. can just
return ‘self’:

     class Reverse:
         """Iterator for looping over a sequence backwards."""
         def __init__(self, data):
             self.data = data
             self.index = len(data)
         def __iter__(self):
             return self
         def __next__(self):
             if self.index == 0:
                 raise StopIteration
             self.index = self.index - 1
             return self.data[self.index]

     >>> rev = Reverse('spam')
     >>> iter(rev)
     <__main__.Reverse object at 0x00A1DB50>
     >>> for char in rev:
     ...     print(char)
     ...
     m
     a
     p
     s


File: python.info,  Node: Generators,  Next: Generator Expressions,  Prev: Iterators,  Up: Classes

2.9.10 Generators
-----------------

*note Generator: 374.s are a simple and powerful tool for creating
iterators.  They are written like regular functions but use the *note
yield: 21b. statement whenever they want to return data.  Each time
*note next(): 6c6. is called on it, the generator resumes where it left
off (it remembers all the data values and which statement was last
executed).  An example shows that generators can be trivially easy to
create:

     def reverse(data):
         for index in range(len(data)-1, -1, -1):
             yield data[index]

     >>> for char in reverse('golf'):
     ...     print(char)
     ...
     f
     l
     o
     g

Anything that can be done with generators can also be done with
class-based iterators as described in the previous section.  What makes
generators so compact is that the *note __iter__(): 79b. and *note
__next__(): ac7. methods are created automatically.

Another key feature is that the local variables and execution state are
automatically saved between calls.  This made the function easier to
write and much more clear than an approach using instance variables like
‘self.index’ and ‘self.data’.

In addition to automatic method creation and saving program state, when
generators terminate, they automatically raise *note StopIteration: 7a5.
In combination, these features make it easy to create iterators with no
more effort than writing a regular function.


File: python.info,  Node: Generator Expressions,  Prev: Generators,  Up: Classes

2.9.11 Generator Expressions
----------------------------

Some simple generators can be coded succinctly as expressions using a
syntax similar to list comprehensions but with parentheses instead of
brackets.  These expressions are designed for situations where the
generator is used right away by an enclosing function.  Generator
expressions are more compact but less versatile than full generator
definitions and tend to be more memory friendly than equivalent list
comprehensions.

Examples:

     >>> sum(i*i for i in range(10))                 # sum of squares
     285

     >>> xvec = [10, 20, 30]
     >>> yvec = [7, 5, 3]
     >>> sum(x*y for x,y in zip(xvec, yvec))         # dot product
     260

     >>> from math import pi, sin
     >>> sine_table = {x: sin(x*pi/180) for x in range(0, 91)}

     >>> unique_words = set(word  for line in page  for word in line.split())

     >>> valedictorian = max((student.gpa, student.name) for student in graduates)

     >>> data = 'golf'
     >>> list(data[i] for i in range(len(data)-1, -1, -1))
     ['f', 'l', 'o', 'g']


File: python.info,  Node: Brief Tour of the Standard Library,  Next: Brief Tour of the Standard Library -- Part II,  Prev: Classes,  Up: The Python Tutorial

2.10 Brief Tour of the Standard Library
=======================================

* Menu:

* Operating System Interface:: 
* File Wildcards:: 
* Command Line Arguments:: 
* Error Output Redirection and Program Termination:: 
* String Pattern Matching:: 
* Mathematics:: 
* Internet Access:: 
* Dates and Times:: 
* Data Compression:: 
* Performance Measurement:: 
* Quality Control:: 
* Batteries Included:: 


File: python.info,  Node: Operating System Interface,  Next: File Wildcards,  Up: Brief Tour of the Standard Library

2.10.1 Operating System Interface
---------------------------------

The *note os: c0. module provides dozens of functions for interacting
with the operating system:

     >>> import os
     >>> os.getcwd()      # Return the current working directory
     'C:\\Python34'
     >>> os.chdir('/server/accesslogs')   # Change current working directory
     >>> os.system('mkdir today')   # Run the command mkdir in the system shell
     0

Be sure to use the ‘import os’ style instead of ‘from os import *’.
This will keep *note os.open(): 217. from shadowing the built-in *note
open(): 1a2. function which operates much differently.

The built-in *note dir(): 7a8. and *note help(): 157. functions are
useful as interactive aids for working with large modules like *note os:
c0.:

     >>> import os
     >>> dir(os)
     <returns a list of all module functions>
     >>> help(os)
     <returns an extensive manual page created from the module's docstrings>

For daily file and directory management tasks, the *note shutil: e4.
module provides a higher level interface that is easier to use:

     >>> import shutil
     >>> shutil.copyfile('data.db', 'archive.db')
     'archive.db'
     >>> shutil.move('/build/executables', 'installdir')
     'installdir'


File: python.info,  Node: File Wildcards,  Next: Command Line Arguments,  Prev: Operating System Interface,  Up: Brief Tour of the Standard Library

2.10.2 File Wildcards
---------------------

The *note glob: 89. module provides a function for making file lists
from directory wildcard searches:

     >>> import glob
     >>> glob.glob('*.py')
     ['primes.py', 'random.py', 'quote.py']


File: python.info,  Node: Command Line Arguments,  Next: Error Output Redirection and Program Termination,  Prev: File Wildcards,  Up: Brief Tour of the Standard Library

2.10.3 Command Line Arguments
-----------------------------

Common utility scripts often need to process command line arguments.
These arguments are stored in the *note sys: f8. module’s `argv'
attribute as a list.  For instance the following output results from
running ‘python demo.py one two three’ at the command line:

     >>> import sys
     >>> print(sys.argv)
     ['demo.py', 'one', 'two', 'three']

The *note getopt: 86. module processes `sys.argv' using the conventions
of the Unix *note getopt(): 86. function.  More powerful and flexible
command line processing is provided by the *note argparse: 6. module.


File: python.info,  Node: Error Output Redirection and Program Termination,  Next: String Pattern Matching,  Prev: Command Line Arguments,  Up: Brief Tour of the Standard Library

2.10.4 Error Output Redirection and Program Termination
-------------------------------------------------------

The *note sys: f8. module also has attributes for `stdin', `stdout', and
`stderr'.  The latter is useful for emitting warnings and error messages
to make them visible even when `stdout' has been redirected:

     >>> sys.stderr.write('Warning, log file not found starting a new one\n')
     Warning, log file not found starting a new one

The most direct way to terminate a script is to use ‘sys.exit()’.


File: python.info,  Node: String Pattern Matching,  Next: Mathematics,  Prev: Error Output Redirection and Program Termination,  Up: Brief Tour of the Standard Library

2.10.5 String Pattern Matching
------------------------------

The *note re: d9. module provides regular expression tools for advanced
string processing.  For complex matching and manipulation, regular
expressions offer succinct, optimized solutions:

     >>> import re
     >>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
     ['foot', 'fell', 'fastest']
     >>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')
     'cat in the hat'

When only simple capabilities are needed, string methods are preferred
because they are easier to read and debug:

     >>> 'tea for too'.replace('too', 'two')
     'tea for two'


File: python.info,  Node: Mathematics,  Next: Internet Access,  Prev: String Pattern Matching,  Up: Brief Tour of the Standard Library

2.10.6 Mathematics
------------------

The *note math: ae. module gives access to the underlying C library
functions for floating point math:

     >>> import math
     >>> math.cos(math.pi / 4)
     0.70710678118654757
     >>> math.log(1024, 2)
     10.0

The *note random: d8. module provides tools for making random
selections:

     >>> import random
     >>> random.choice(['apple', 'pear', 'banana'])
     'apple'
     >>> random.sample(range(100), 10)   # sampling without replacement
     [30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
     >>> random.random()    # random float
     0.17970987693706186
     >>> random.randrange(6)    # random integer chosen from range(6)
     4

The SciPy project <‘http://scipy.org’> has many other modules for
numerical computations.


File: python.info,  Node: Internet Access,  Next: Dates and Times,  Prev: Mathematics,  Up: Brief Tour of the Standard Library

2.10.7 Internet Access
----------------------

There are a number of modules for accessing the internet and processing
internet protocols.  Two of the simplest are *note urllib.request: 119.
for retrieving data from URLs and *note smtplib: e8. for sending mail:

     >>> from urllib.request import urlopen
     >>> for line in urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl'):
     ...     line = line.decode('utf-8')  # Decoding the binary data to text.
     ...     if 'EST' in line or 'EDT' in line:  # look for Eastern Time
     ...         print(line)

     <BR>Nov. 25, 09:43:32 PM EST

     >>> import smtplib
     >>> server = smtplib.SMTP('localhost')
     >>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',
     ... """To: jcaesar@example.org
     ... From: soothsayer@example.org
     ...
     ... Beware the Ides of March.
     ... """)
     >>> server.quit()

(Note that the second example needs a mailserver running on localhost.)


File: python.info,  Node: Dates and Times,  Next: Data Compression,  Prev: Internet Access,  Up: Brief Tour of the Standard Library

2.10.8 Dates and Times
----------------------

The *note datetime: 2f. module supplies classes for manipulating dates
and times in both simple and complex ways.  While date and time
arithmetic is supported, the focus of the implementation is on efficient
member extraction for output formatting and manipulation.  The module
also supports objects that are timezone aware.

     >>> # dates are easily constructed and formatted
     >>> from datetime import date
     >>> now = date.today()
     >>> now
     datetime.date(2003, 12, 2)
     >>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")
     '12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'

     >>> # dates support calendar arithmetic
     >>> birthday = date(1964, 7, 31)
     >>> age = now - birthday
     >>> age.days
     14368


File: python.info,  Node: Data Compression,  Next: Performance Measurement,  Prev: Dates and Times,  Up: Brief Tour of the Standard Library

2.10.9 Data Compression
-----------------------

Common data archiving and compression formats are directly supported by
modules including: *note zlib: 13c, *note gzip: 8b, *note bz2: 14, *note
lzma: a9, *note zipfile: 13a. and *note tarfile: fc.

     >>> import zlib
     >>> s = b'witch which has which witches wrist watch'
     >>> len(s)
     41
     >>> t = zlib.compress(s)
     >>> len(t)
     37
     >>> zlib.decompress(t)
     b'witch which has which witches wrist watch'
     >>> zlib.crc32(s)
     226805979


File: python.info,  Node: Performance Measurement,  Next: Quality Control,  Prev: Data Compression,  Up: Brief Tour of the Standard Library

2.10.10 Performance Measurement
-------------------------------

Some Python users develop a deep interest in knowing the relative
performance of different approaches to the same problem.  Python
provides a measurement tool that answers those questions immediately.

For example, it may be tempting to use the tuple packing and unpacking
feature instead of the traditional approach to swapping arguments.  The
*note timeit: 105. module quickly demonstrates a modest performance
advantage:

     >>> from timeit import Timer
     >>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
     0.57535828626024577
     >>> Timer('a,b = b,a', 'a=1; b=2').timeit()
     0.54962537085770791

In contrast to *note timeit: 105.’s fine level of granularity, the *note
profile: cf. and *note pstats: d0. modules provide tools for identifying
time critical sections in larger blocks of code.


File: python.info,  Node: Quality Control,  Next: Batteries Included,  Prev: Performance Measurement,  Up: Brief Tour of the Standard Library

2.10.11 Quality Control
-----------------------

One approach for developing high quality software is to write tests for
each function as it is developed and to run those tests frequently
during the development process.

The *note doctest: 65. module provides a tool for scanning a module and
validating tests embedded in a program’s docstrings.  Test construction
is as simple as cutting-and-pasting a typical call along with its
results into the docstring.  This improves the documentation by
providing the user with an example and it allows the doctest module to
make sure the code remains true to the documentation:

     def average(values):
         """Computes the arithmetic mean of a list of numbers.

         >>> print(average([20, 30, 70]))
         40.0
         """
         return sum(values) / len(values)

     import doctest
     doctest.testmod()   # automatically validate the embedded tests

The *note unittest: 114. module is not as effortless as the *note
doctest: 65. module, but it allows a more comprehensive set of tests to
be maintained in a separate file:

     import unittest

     class TestStatisticalFunctions(unittest.TestCase):

         def test_average(self):
             self.assertEqual(average([20, 30, 70]), 40.0)
             self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
             with self.assertRaises(ZeroDivisionError):
                 average([])
             with self.assertRaises(TypeError):
                 average(20, 30, 70)

     unittest.main() # Calling from the command line invokes all tests


File: python.info,  Node: Batteries Included,  Prev: Quality Control,  Up: Brief Tour of the Standard Library

2.10.12 Batteries Included
--------------------------

Python has a "batteries included" philosophy.  This is best seen through
the sophisticated and robust capabilities of its larger packages.  For
example:

   * The *note xmlrpc.client: 138. and *note xmlrpc.server: 139. modules
     make implementing remote procedure calls into an almost trivial
     task.  Despite the modules names, no direct knowledge or handling
     of XML is needed.

   * The *note email: 67. package is a library for managing email
     messages, including MIME and other RFC 2822-based message
     documents.  Unlike *note smtplib: e8. and *note poplib: cc. which
     actually send and receive messages, the email package has a
     complete toolset for building or decoding complex message
     structures (including attachments) and for implementing internet
     encoding and header protocols.

   * The *note xml.dom: 12d. and *note xml.sax: 134. packages provide
     robust support for parsing this popular data interchange format.
     Likewise, the *note csv: 29. module supports direct reads and
     writes in a common database format.  Together, these modules and
     packages greatly simplify data interchange between Python
     applications and other tools.

   * Internationalization is supported by a number of modules including
     *note gettext: 88, *note locale: a5, and the *note codecs: 1c.
     package.


File: python.info,  Node: Brief Tour of the Standard Library -- Part II,  Next: What Now?,  Prev: Brief Tour of the Standard Library,  Up: The Python Tutorial

2.11 Brief Tour of the Standard Library – Part II
=================================================

This second tour covers more advanced modules that support professional
programming needs.  These modules rarely occur in small scripts.

* Menu:

* Output Formatting:: 
* Templating:: 
* Working with Binary Data Record Layouts:: 
* Multi-threading: Multi-threading<2>. 
* Logging:: 
* Weak References:: 
* Tools for Working with Lists:: 
* Decimal Floating Point Arithmetic:: 


File: python.info,  Node: Output Formatting,  Next: Templating,  Up: Brief Tour of the Standard Library -- Part II

2.11.1 Output Formatting
------------------------

The *note reprlib: db. module provides a version of *note repr(): 3db.
customized for abbreviated displays of large or deeply nested
containers:

     >>> import reprlib
     >>> reprlib.repr(set('supercalifragilisticexpialidocious'))
     "set(['a', 'c', 'd', 'e', 'f', 'g', ...])"

The *note pprint: ce. module offers more sophisticated control over
printing both built-in and user defined objects in a way that is
readable by the interpreter.  When the result is longer than one line,
the "pretty printer" adds line breaks and indentation to more clearly
reveal data structure:

     >>> import pprint
     >>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',
     ...     'yellow'], 'blue']]]
     ...
     >>> pprint.pprint(t, width=30)
     [[[['black', 'cyan'],
        'white',
        ['green', 'red']],
       [['magenta', 'yellow'],
        'blue']]]

The *note textwrap: 102. module formats paragraphs of text to fit a
given screen width:

     >>> import textwrap
     >>> doc = """The wrap() method is just like fill() except that it returns
     ... a list of strings instead of one big string with newlines to separate
     ... the wrapped lines."""
     ...
     >>> print(textwrap.fill(doc, width=40))
     The wrap() method is just like fill()
     except that it returns a list of strings
     instead of one big string with newlines
     to separate the wrapped lines.

The *note locale: a5. module accesses a database of culture specific
data formats.  The grouping attribute of locale’s format function
provides a direct way of formatting numbers with group separators:

     >>> import locale
     >>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')
     'English_United States.1252'
     >>> conv = locale.localeconv()          # get a mapping of conventions
     >>> x = 1234567.8
     >>> locale.format("%d", x, grouping=True)
     '1,234,567'
     >>> locale.format_string("%s%.*f", (conv['currency_symbol'],
     ...                      conv['frac_digits'], x), grouping=True)
     '$1,234,567.80'


File: python.info,  Node: Templating,  Next: Working with Binary Data Record Layouts,  Prev: Output Formatting,  Up: Brief Tour of the Standard Library -- Part II

2.11.2 Templating
-----------------

The *note string: f1. module includes a versatile *note Template: 5aa.
class with a simplified syntax suitable for editing by end-users.  This
allows users to customize their applications without having to alter the
application.

The format uses placeholder names formed by ‘$’ with valid Python
identifiers (alphanumeric characters and underscores).  Surrounding the
placeholder with braces allows it to be followed by more alphanumeric
letters with no intervening spaces.  Writing ‘$$’ creates a single
escaped ‘$’:

     >>> from string import Template
     >>> t = Template('${village}folk send $$10 to $cause.')
     >>> t.substitute(village='Nottingham', cause='the ditch fund')
     'Nottinghamfolk send $10 to the ditch fund.'

The *note substitute(): aec. method raises a *note KeyError: 706. when a
placeholder is not supplied in a dictionary or a keyword argument.  For
mail-merge style applications, user supplied data may be incomplete and
the *note safe_substitute(): aed. method may be more appropriate — it
will leave placeholders unchanged if data is missing:

     >>> t = Template('Return the $item to $owner.')
     >>> d = dict(item='unladen swallow')
     >>> t.substitute(d)
     Traceback (most recent call last):
       ...
     KeyError: 'owner'
     >>> t.safe_substitute(d)
     'Return the unladen swallow to $owner.'

Template subclasses can specify a custom delimiter.  For example, a
batch renaming utility for a photo browser may elect to use percent
signs for placeholders such as the current date, image sequence number,
or file format:

     >>> import time, os.path
     >>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']
     >>> class BatchRename(Template):
     ...     delimiter = '%'
     >>> fmt = input('Enter rename style (%d-date %n-seqnum %f-format):  ')
     Enter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f

     >>> t = BatchRename(fmt)
     >>> date = time.strftime('%d%b%y')
     >>> for i, filename in enumerate(photofiles):
     ...     base, ext = os.path.splitext(filename)
     ...     newname = t.substitute(d=date, n=i, f=ext)
     ...     print('{0} --> {1}'.format(filename, newname))

     img_1074.jpg --> Ashley_0.jpg
     img_1076.jpg --> Ashley_1.jpg
     img_1077.jpg --> Ashley_2.jpg

Another application for templating is separating program logic from the
details of multiple output formats.  This makes it possible to
substitute custom templates for XML files, plain text reports, and HTML
web reports.


File: python.info,  Node: Working with Binary Data Record Layouts,  Next: Multi-threading<2>,  Prev: Templating,  Up: Brief Tour of the Standard Library -- Part II

2.11.3 Working with Binary Data Record Layouts
----------------------------------------------

The *note struct: f3. module provides *note pack(): 65d. and *note
unpack(): af0. functions for working with variable length binary record
formats.  The following example shows how to loop through header
information in a ZIP file without using the *note zipfile: 13a. module.
Pack codes ‘"H"’ and ‘"I"’ represent two and four byte unsigned numbers
respectively.  The ‘"<"’ indicates that they are standard size and in
little-endian byte order:

     import struct

     with open('myfile.zip', 'rb') as f:
         data = f.read()

     start = 0
     for i in range(3):                      # show the first 3 file headers
         start += 14
         fields = struct.unpack('<IIIHH', data[start:start+16])
         crc32, comp_size, uncomp_size, filenamesize, extra_size = fields

         start += 16
         filename = data[start:start+filenamesize]
         start += filenamesize
         extra = data[start:start+extra_size]
         print(filename, hex(crc32), comp_size, uncomp_size)

         start += extra_size + comp_size     # skip to the next header


File: python.info,  Node: Multi-threading<2>,  Next: Logging,  Prev: Working with Binary Data Record Layouts,  Up: Brief Tour of the Standard Library -- Part II

2.11.4 Multi-threading
----------------------

Threading is a technique for decoupling tasks which are not sequentially
dependent.  Threads can be used to improve the responsiveness of
applications that accept user input while other tasks run in the
background.  A related use case is running I/O in parallel with
computations in another thread.

The following code shows how the high level *note threading: 103. module
can run tasks in background while the main program continues to run:

     import threading, zipfile

     class AsyncZip(threading.Thread):
         def __init__(self, infile, outfile):
             threading.Thread.__init__(self)
             self.infile = infile
             self.outfile = outfile
         def run(self):
             f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)
             f.write(self.infile)
             f.close()
             print('Finished background zip of:', self.infile)

     background = AsyncZip('mydata.txt', 'myarchive.zip')
     background.start()
     print('The main program continues to run in foreground.')

     background.join()    # Wait for the background task to finish
     print('Main program waited until background was done.')

The principal challenge of multi-threaded applications is coordinating
threads that share data or other resources.  To that end, the threading
module provides a number of synchronization primitives including locks,
events, condition variables, and semaphores.

While those tools are powerful, minor design errors can result in
problems that are difficult to reproduce.  So, the preferred approach to
task coordination is to concentrate all access to a resource in a single
thread and then use the *note queue: d6. module to feed that thread with
requests from other threads.  Applications using *note Queue: af3.
objects for inter-thread communication and coordination are easier to
design, more readable, and more reliable.


File: python.info,  Node: Logging,  Next: Weak References,  Prev: Multi-threading<2>,  Up: Brief Tour of the Standard Library -- Part II

2.11.5 Logging
--------------

The *note logging: a6. module offers a full featured and flexible
logging system.  At its simplest, log messages are sent to a file or to
‘sys.stderr’:

     import logging
     logging.debug('Debugging information')
     logging.info('Informational message')
     logging.warning('Warning:config file %s not found', 'server.conf')
     logging.error('Error occurred')
     logging.critical('Critical error -- shutting down')

This produces the following output:

     WARNING:root:Warning:config file server.conf not found
     ERROR:root:Error occurred
     CRITICAL:root:Critical error -- shutting down

By default, informational and debugging messages are suppressed and the
output is sent to standard error.  Other output options include routing
messages through email, datagrams, sockets, or to an HTTP Server.  New
filters can select different routing based on message priority: ‘DEBUG’,
‘INFO’, ‘WARNING’, ‘ERROR’, and ‘CRITICAL’.

The logging system can be configured directly from Python or can be
loaded from a user editable configuration file for customized logging
without altering the application.


File: python.info,  Node: Weak References,  Next: Tools for Working with Lists,  Prev: Logging,  Up: Brief Tour of the Standard Library -- Part II

2.11.6 Weak References
----------------------

Python does automatic memory management (reference counting for most
objects and *note garbage collection: af8. to eliminate cycles).  The
memory is freed shortly after the last reference to it has been
eliminated.

This approach works fine for most applications but occasionally there is
a need to track objects only as long as they are being used by something
else.  Unfortunately, just tracking them creates a reference that makes
them permanent.  The *note weakref: 121. module provides tools for
tracking objects without creating a reference.  When the object is no
longer needed, it is automatically removed from a weakref table and a
callback is triggered for weakref objects.  Typical applications include
caching objects that are expensive to create:

     >>> import weakref, gc
     >>> class A:
     ...     def __init__(self, value):
     ...         self.value = value
     ...     def __repr__(self):
     ...         return str(self.value)
     ...
     >>> a = A(10)                   # create a reference
     >>> d = weakref.WeakValueDictionary()
     >>> d['primary'] = a            # does not create a reference
     >>> d['primary']                # fetch the object if it is still alive
     10
     >>> del a                       # remove the one reference
     >>> gc.collect()                # run garbage collection right away
     0
     >>> d['primary']                # entry was automatically removed
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
         d['primary']                # entry was automatically removed
       File "C:/python34/lib/weakref.py", line 46, in __getitem__
         o = self.data[key]()
     KeyError: 'primary'


File: python.info,  Node: Tools for Working with Lists,  Next: Decimal Floating Point Arithmetic,  Prev: Weak References,  Up: Brief Tour of the Standard Library -- Part II

2.11.7 Tools for Working with Lists
-----------------------------------

Many data structure needs can be met with the built-in list type.
However, sometimes there is a need for alternative implementations with
different performance trade-offs.

The *note array: 7. module provides an *note array(): 6b8. object that
is like a list that stores only homogeneous data and stores it more
compactly.  The following example shows an array of numbers stored as
two byte unsigned binary numbers (typecode ‘"H"’) rather than the usual
16 bytes per entry for regular lists of Python int objects:

     >>> from array import array
     >>> a = array('H', [4000, 10, 700, 22222])
     >>> sum(a)
     26932
     >>> a[1:3]
     array('H', [10, 700])

The *note collections: 1e. module provides a *note deque(): 589. object
that is like a list with faster appends and pops from the left side but
slower lookups in the middle.  These objects are well suited for
implementing queues and breadth first tree searches:

     >>> from collections import deque
     >>> d = deque(["task1", "task2", "task3"])
     >>> d.append("task4")
     >>> print("Handling", d.popleft())
     Handling task1

     unsearched = deque([starting_node])
     def breadth_first_search(unsearched):
         node = unsearched.popleft()
         for m in gen_moves(node):
             if is_goal(m):
                 return m
             unsearched.append(m)

In addition to alternative list implementations, the library also offers
other tools such as the *note bisect: 12. module with functions for
manipulating sorted lists:

     >>> import bisect
     >>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]
     >>> bisect.insort(scores, (300, 'ruby'))
     >>> scores
     [(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]

The *note heapq: 8d. module provides functions for implementing heaps
based on regular lists.  The lowest valued entry is always kept at
position zero.  This is useful for applications which repeatedly access
the smallest element but do not want to run a full list sort:

     >>> from heapq import heapify, heappop, heappush
     >>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
     >>> heapify(data)                      # rearrange the list into heap order
     >>> heappush(data, -5)                 # add a new entry
     >>> [heappop(data) for i in range(3)]  # fetch the three smallest entries
     [-5, 0, 1]


File: python.info,  Node: Decimal Floating Point Arithmetic,  Prev: Tools for Working with Lists,  Up: Brief Tour of the Standard Library -- Part II

2.11.8 Decimal Floating Point Arithmetic
----------------------------------------

The *note decimal: 34. module offers a *note Decimal: 3d4. datatype for
decimal floating point arithmetic.  Compared to the built-in *note
float: 327. implementation of binary floating point, the class is
especially helpful for

   * financial applications and other uses which require exact decimal
     representation,

   * control over precision,

   * control over rounding to meet legal or regulatory requirements,

   * tracking of significant decimal places, or

   * applications where the user expects the results to match
     calculations done by hand.

For example, calculating a 5% tax on a 70 cent phone charge gives
different results in decimal floating point and binary floating point.
The difference becomes significant if the results are rounded to the
nearest cent:

     >>> from decimal import *
     >>> round(Decimal('0.70') * Decimal('1.05'), 2)
     Decimal('0.74')
     >>> round(.70 * 1.05, 2)
     0.73

The *note Decimal: 3d4. result keeps a trailing zero, automatically
inferring four place significance from multiplicands with two place
significance.  Decimal reproduces mathematics as done by hand and avoids
issues that can arise when binary floating point cannot exactly
represent decimal quantities.

Exact representation enables the *note Decimal: 3d4. class to perform
modulo calculations and equality tests that are unsuitable for binary
floating point:

     >>> Decimal('1.00') % Decimal('.10')
     Decimal('0.00')
     >>> 1.00 % 0.10
     0.09999999999999995

     >>> sum([Decimal('0.1')]*10) == Decimal('1.0')
     True
     >>> sum([0.1]*10) == 1.0
     False

The *note decimal: 34. module provides arithmetic with as much precision
as needed:

     >>> getcontext().prec = 36
     >>> Decimal(1) / Decimal(7)
     Decimal('0.142857142857142857142857142857142857')


File: python.info,  Node: What Now?,  Next: Interactive Input Editing and History Substitution,  Prev: Brief Tour of the Standard Library -- Part II,  Up: The Python Tutorial

2.12 What Now?
==============

Reading this tutorial has probably reinforced your interest in using
Python — you should be eager to apply Python to solving your real-world
problems.  Where should you go to learn more?

This tutorial is part of Python’s documentation set.  Some other
documents in the set are:

   * *note The Python Standard Library: 9f1.:

     You should browse through this manual, which gives complete (though
     terse) reference material about types, functions, and the modules
     in the standard library.  The standard Python distribution includes
     a `lot' of additional code.  There are modules to read Unix
     mailboxes, retrieve documents via HTTP, generate random numbers,
     parse command-line options, write CGI programs, compress data, and
     many other tasks.  Skimming through the Library Reference will give
     you an idea of what’s available.

   * *note Installing Python Modules: 16b. explains how to install
     additional modules written by other Python users.

   * *note The Python Language Reference: 9f2.: A detailed explanation
     of Python’s syntax and semantics.  It’s heavy reading, but is
     useful as a complete guide to the language itself.

More Python resources:

   * ‘https://www.python.org’: The major Python Web site.  It contains
     code, documentation, and pointers to Python-related pages around
     the Web.  This Web site is mirrored in various places around the
     world, such as Europe, Japan, and Australia; a mirror may be faster
     than the main site, depending on your geographical location.

   * ‘https://docs.python.org’: Fast access to Python’s documentation.

   * ‘https://pypi.python.org/pypi’: The Python Package Index,
     previously also nicknamed the Cheese Shop, is an index of
     user-created Python modules that are available for download.  Once
     you begin releasing code, you can register it here so that others
     can find it.

   * ‘http://code.activestate.com/recipes/langs/python/’: The Python
     Cookbook is a sizable collection of code examples, larger modules,
     and useful scripts.  Particularly notable contributions are
     collected in a book also titled Python Cookbook (O’Reilly &
     Associates, ISBN 0-596-00797-3.)

   * ‘http://scipy.org’: The Scientific Python project includes modules
     for fast array computations and manipulations plus a host of
     packages for such things as linear algebra, Fourier transforms,
     non-linear solvers, random number distributions, statistical
     analysis and the like.

For Python-related questions and problem reports, you can post to the
newsgroup ‘comp.lang.python’, or send them to the mailing list at
<python-list@python.org>.  The newsgroup and mailing list are gatewayed,
so messages posted to one will automatically be forwarded to the other.
There are around 120 postings a day (with peaks up to several hundred),
asking (and answering) questions, suggesting new features, and
announcing new modules.  Before posting, be sure to check the list of
*note Frequently Asked Questions: b00. (also called the FAQ). Mailing
list archives are available at ‘https://mail.python.org/pipermail/’.
The FAQ answers many of the questions that come up again and again, and
may already contain the solution for your problem.


File: python.info,  Node: Interactive Input Editing and History Substitution,  Next: Floating Point Arithmetic Issues and Limitations,  Prev: What Now?,  Up: The Python Tutorial

2.13 Interactive Input Editing and History Substitution
=======================================================

Some versions of the Python interpreter support editing of the current
input line and history substitution, similar to facilities found in the
Korn shell and the GNU Bash shell.  This is implemented using the GNU
Readline(1) library, which supports various styles of editing.  This
library has its own documentation which we won’t duplicate here.

* Menu:

* Tab Completion and History Editing:: 
* Alternatives to the Interactive Interpreter:: 

   ---------- Footnotes ----------

   (1) http://tiswww.case.edu/php/chet/readline/rltop.html


File: python.info,  Node: Tab Completion and History Editing,  Next: Alternatives to the Interactive Interpreter,  Up: Interactive Input Editing and History Substitution

2.13.1 Tab Completion and History Editing
-----------------------------------------

Completion of variable and module names is *note automatically enabled:
285. at interpreter startup so that the ‘Tab’ key invokes the completion
function; it looks at Python statement names, the current local
variables, and the available module names.  For dotted expressions such
as ‘string.a’, it will evaluate the expression up to the final ‘'.'’ and
then suggest completions from the attributes of the resulting object.
Note that this may execute application-defined code if an object with a
*note __getattr__(): 560. method is part of the expression.  The default
configuration also saves your history into a file named
‘.python_history’ in your user directory.  The history will be available
again during the next interactive interpreter session.


File: python.info,  Node: Alternatives to the Interactive Interpreter,  Prev: Tab Completion and History Editing,  Up: Interactive Input Editing and History Substitution

2.13.2 Alternatives to the Interactive Interpreter
--------------------------------------------------

This facility is an enormous step forward compared to earlier versions
of the interpreter; however, some wishes are left: It would be nice if
the proper indentation were suggested on continuation lines (the parser
knows if an indent token is required next).  The completion mechanism
might use the interpreter’s symbol table.  A command to check (or even
suggest) matching parentheses, quotes, etc., would also be useful.

One alternative enhanced interactive interpreter that has been around
for quite some time is IPython(1), which features tab completion, object
exploration and advanced history management.  It can also be thoroughly
customized and embedded into other applications.  Another similar
enhanced interactive environment is bpython(2).

   ---------- Footnotes ----------

   (1) http://ipython.scipy.org/

   (2) http://www.bpython-interpreter.org/


File: python.info,  Node: Floating Point Arithmetic Issues and Limitations,  Next: Appendix,  Prev: Interactive Input Editing and History Substitution,  Up: The Python Tutorial

2.14 Floating Point Arithmetic: Issues and Limitations
======================================================

Floating-point numbers are represented in computer hardware as base 2
(binary) fractions.  For example, the decimal fraction

     0.125

has value 1/10 + 2/100 + 5/1000, and in the same way the binary fraction

     0.001

has value 0/2 + 0/4 + 1/8.  These two fractions have identical values,
the only real difference being that the first is written in base 10
fractional notation, and the second in base 2.

Unfortunately, most decimal fractions cannot be represented exactly as
binary fractions.  A consequence is that, in general, the decimal
floating-point numbers you enter are only approximated by the binary
floating-point numbers actually stored in the machine.

The problem is easier to understand at first in base 10.  Consider the
fraction 1/3.  You can approximate that as a base 10 fraction:

     0.3

or, better,

     0.33

or, better,

     0.333

and so on.  No matter how many digits you’re willing to write down, the
result will never be exactly 1/3, but will be an increasingly better
approximation of 1/3.

In the same way, no matter how many base 2 digits you’re willing to use,
the decimal value 0.1 cannot be represented exactly as a base 2
fraction.  In base 2, 1/10 is the infinitely repeating fraction

     0.0001100110011001100110011001100110011001100110011...

Stop at any finite number of bits, and you get an approximation.  On
most machines today, floats are approximated using a binary fraction
with the numerator using the first 53 bits starting with the most
significant bit and with the denominator as a power of two.  In the case
of 1/10, the binary fraction is ‘3602879701896397 / 2 ** 55’ which is
close to but not exactly equal to the true value of 1/10.

Many users are not aware of the approximation because of the way values
are displayed.  Python only prints a decimal approximation to the true
decimal value of the binary approximation stored by the machine.  On
most machines, if Python were to print the true decimal value of the
binary approximation stored for 0.1, it would have to display

     >>> 0.1
     0.1000000000000000055511151231257827021181583404541015625

That is more digits than most people find useful, so Python keeps the
number of digits manageable by displaying a rounded value instead

     >>> 1 / 10
     0.1

Just remember, even though the printed result looks like the exact value
of 1/10, the actual stored value is the nearest representable binary
fraction.

Interestingly, there are many different decimal numbers that share the
same nearest approximate binary fraction.  For example, the numbers
‘0.1’ and ‘0.10000000000000001’ and
‘0.1000000000000000055511151231257827021181583404541015625’ are all
approximated by ‘3602879701896397 / 2 ** 55’.  Since all of these
decimal values share the same approximation, any one of them could be
displayed while still preserving the invariant ‘eval(repr(x)) == x’.

Historically, the Python prompt and built-in *note repr(): 3db. function
would choose the one with 17 significant digits, ‘0.10000000000000001’.
Starting with Python 3.1, Python (on most systems) is now able to choose
the shortest of these and simply display ‘0.1’.

Note that this is in the very nature of binary floating-point: this is
not a bug in Python, and it is not a bug in your code either.  You’ll
see the same kind of thing in all languages that support your hardware’s
floating-point arithmetic (although some languages may not `display' the
difference by default, or in all output modes).

For more pleasant output, you may wish to use string formatting to
produce a limited number of significant digits:

     >>> format(math.pi, '.12g')  # give 12 significant digits
     '3.14159265359'

     >>> format(math.pi, '.2f')   # give 2 digits after the point
     '3.14'

     >>> repr(math.pi)
     '3.141592653589793'

It’s important to realize that this is, in a real sense, an illusion:
you’re simply rounding the `display' of the true machine value.

One illusion may beget another.  For example, since 0.1 is not exactly
1/10, summing three values of 0.1 may not yield exactly 0.3, either:

     >>> .1 + .1 + .1 == .3
     False

Also, since the 0.1 cannot get any closer to the exact value of 1/10 and
0.3 cannot get any closer to the exact value of 3/10, then pre-rounding
with *note round(): 6d1. function cannot help:

     >>> round(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)
     False

Though the numbers cannot be made closer to their intended exact values,
the *note round(): 6d1. function can be useful for post-rounding so that
results with inexact values become comparable to one another:

     >>> round(.1 + .1 + .1, 10) == round(.3, 10)
     True

Binary floating-point arithmetic holds many surprises like this.  The
problem with "0.1" is explained in precise detail below, in the
"Representation Error" section.  See The Perils of Floating Point(1) for
a more complete account of other common surprises.

As that says near the end, "there are no easy answers."  Still, don’t be
unduly wary of floating-point!  The errors in Python float operations
are inherited from the floating-point hardware, and on most machines are
on the order of no more than 1 part in 2**53 per operation.  That’s more
than adequate for most tasks, but you do need to keep in mind that it’s
not decimal arithmetic and that every float operation can suffer a new
rounding error.

While pathological cases do exist, for most casual use of floating-point
arithmetic you’ll see the result you expect in the end if you simply
round the display of your final results to the number of decimal digits
you expect.  *note str(): 178. usually suffices, and for finer control
see the *note str.format(): 557. method’s format specifiers in *note
Format String Syntax: 78a.

For use cases which require exact decimal representation, try using the
*note decimal: 34. module which implements decimal arithmetic suitable
for accounting applications and high-precision applications.

Another form of exact arithmetic is supported by the *note fractions:
82. module which implements arithmetic based on rational numbers (so the
numbers like 1/3 can be represented exactly).

If you are a heavy user of floating point operations you should take a
look at the Numerical Python package and many other packages for
mathematical and statistical operations supplied by the SciPy project.
See <‘http://scipy.org’>.

Python provides tools that may help on those rare occasions when you
really `do' want to know the exact value of a float.  The *note
float.as_integer_ratio(): b0b. method expresses the value of a float as
a fraction:

     >>> x = 3.14159
     >>> x.as_integer_ratio()
     (3537115888337719, 1125899906842624)

Since the ratio is exact, it can be used to losslessly recreate the
original value:

     >>> x == 3537115888337719 / 1125899906842624
     True

The *note float.hex(): b0c. method expresses a float in hexadecimal
(base 16), again giving the exact value stored by your computer:

     >>> x.hex()
     '0x1.921f9f01b866ep+1'

This precise hexadecimal representation can be used to reconstruct the
float value exactly:

     >>> x == float.fromhex('0x1.921f9f01b866ep+1')
     True

Since the representation is exact, it is useful for reliably porting
values across different versions of Python (platform independence) and
exchanging data with other languages that support the same format (such
as Java and C99).

Another helpful tool is the *note math.fsum(): 7b7. function which helps
mitigate loss-of-precision during summation.  It tracks "lost digits" as
values are added onto a running total.  That can make a difference in
overall accuracy so that the errors do not accumulate to the point where
they affect the final total:

     >>> sum([0.1] * 10) == 1.0
     False
     >>> math.fsum([0.1] * 10) == 1.0
     True

* Menu:

* Representation Error:: 

   ---------- Footnotes ----------

   (1) http://www.lahey.com/float.htm


File: python.info,  Node: Representation Error,  Up: Floating Point Arithmetic Issues and Limitations

2.14.1 Representation Error
---------------------------

This section explains the "0.1" example in detail, and shows how you can
perform an exact analysis of cases like this yourself.  Basic
familiarity with binary floating-point representation is assumed.

`Representation error' refers to the fact that some (most, actually)
decimal fractions cannot be represented exactly as binary (base 2)
fractions.  This is the chief reason why Python (or Perl, C, C++, Java,
Fortran, and many others) often won’t display the exact decimal number
you expect.

Why is that?  1/10 is not exactly representable as a binary fraction.
Almost all machines today (November 2000) use IEEE-754 floating point
arithmetic, and almost all platforms map Python floats to IEEE-754
"double precision".  754 doubles contain 53 bits of precision, so on
input the computer strives to convert 0.1 to the closest fraction it can
of the form `J'/2**`N' where `J' is an integer containing exactly 53
bits.  Rewriting

     1 / 10 ~= J / (2**N)

as

     J ~= 2**N / 10

and recalling that `J' has exactly 53 bits (is ‘>= 2**52’ but ‘<
2**53’), the best value for `N' is 56:

     >>> 2**52 <=  2**56 // 10  < 2**53
     True

That is, 56 is the only value for `N' that leaves `J' with exactly 53
bits.  The best possible value for `J' is then that quotient rounded:

     >>> q, r = divmod(2**56, 10)
     >>> r
     6

Since the remainder is more than half of 10, the best approximation is
obtained by rounding up:

     >>> q+1
     7205759403792794

Therefore the best possible approximation to 1/10 in 754 double
precision is:

     7205759403792794 / 2 ** 56

Dividing both the numerator and denominator by two reduces the fraction
to:

     3602879701896397 / 2 ** 55

Note that since we rounded up, this is actually a little bit larger than
1/10; if we had not rounded up, the quotient would have been a little
bit smaller than 1/10.  But in no case can it be `exactly' 1/10!

So the computer never "sees" 1/10: what it sees is the exact fraction
given above, the best 754 double approximation it can get:

     >>> 0.1 * 2 ** 55
     3602879701896397.0

If we multiply that fraction by 10**55, we can see the value out to 55
decimal digits:

     >>> 3602879701896397 * 10 ** 55 // 2 ** 55
     1000000000000000055511151231257827021181583404541015625

meaning that the exact number stored in the computer is equal to the
decimal value 0.1000000000000000055511151231257827021181583404541015625.
Instead of displaying the full decimal value, many languages (including
older versions of Python), round the result to 17 significant digits:

     >>> format(0.1, '.17f')
     '0.10000000000000001'

The *note fractions: 82. and *note decimal: 34. modules make these
calculations easy:

     >>> from decimal import Decimal
     >>> from fractions import Fraction

     >>> Fraction.from_float(0.1)
     Fraction(3602879701896397, 36028797018963968)

     >>> (0.1).as_integer_ratio()
     (3602879701896397, 36028797018963968)

     >>> Decimal.from_float(0.1)
     Decimal('0.1000000000000000055511151231257827021181583404541015625')

     >>> format(Decimal.from_float(0.1), '.17')
     '0.10000000000000001'


File: python.info,  Node: Appendix,  Prev: Floating Point Arithmetic Issues and Limitations,  Up: The Python Tutorial

2.15 Appendix
=============

* Menu:

* Interactive Mode: Interactive Mode<2>. 


File: python.info,  Node: Interactive Mode<2>,  Up: Appendix

2.15.1 Interactive Mode
-----------------------

* Menu:

* Error Handling:: 
* Executable Python Scripts:: 
* The Interactive Startup File:: 
* The Customization Modules:: 


File: python.info,  Node: Error Handling,  Next: Executable Python Scripts,  Up: Interactive Mode<2>

2.15.1.1 Error Handling
.......................

When an error occurs, the interpreter prints an error message and a
stack trace.  In interactive mode, it then returns to the primary
prompt; when input came from a file, it exits with a nonzero exit status
after printing the stack trace.  (Exceptions handled by an *note except:
563. clause in a *note try: 7ee. statement are not errors in this
context.)  Some errors are unconditionally fatal and cause an exit with
a nonzero exit; this applies to internal inconsistencies and some cases
of running out of memory.  All error messages are written to the
standard error stream; normal output from executed commands is written
to standard output.

Typing the interrupt character (usually Control-C or DEL) to the primary
or secondary prompt cancels the input and returns to the primary prompt.
(1)  Typing an interrupt while a command is executing raises the *note
KeyboardInterrupt: 6c0. exception, which may be handled by a *note try:
7ee. statement.

   ---------- Footnotes ----------

   (1) A problem with the GNU Readline package may prevent this.


File: python.info,  Node: Executable Python Scripts,  Next: The Interactive Startup File,  Prev: Error Handling,  Up: Interactive Mode<2>

2.15.1.2 Executable Python Scripts
..................................

On BSD’ish Unix systems, Python scripts can be made directly executable,
like shell scripts, by putting the line

     #!/usr/bin/env python3.4

(assuming that the interpreter is on the user’s ‘PATH’) at the beginning
of the script and giving the file an executable mode.  The ‘#!’ must be
the first two characters of the file.  On some platforms, this first
line must end with a Unix-style line ending (‘'\n'’), not a Windows
(‘'\r\n'’) line ending.  Note that the hash, or pound, character, ‘'#'’,
is used to start a comment in Python.

The script can be given an executable mode, or permission, using the
‘chmod’ command.

     $ chmod +x myscript.py

On Windows systems, there is no notion of an "executable mode".  The
Python installer automatically associates ‘.py’ files with ‘python.exe’
so that a double-click on a Python file will run it as a script.  The
extension can also be ‘.pyw’, in that case, the console window that
normally appears is suppressed.


File: python.info,  Node: The Interactive Startup File,  Next: The Customization Modules,  Prev: Executable Python Scripts,  Up: Interactive Mode<2>

2.15.1.3 The Interactive Startup File
.....................................

When you use Python interactively, it is frequently handy to have some
standard commands executed every time the interpreter is started.  You
can do this by setting an environment variable named *note
PYTHONSTARTUP: 284. to the name of a file containing your start-up
commands.  This is similar to the ‘.profile’ feature of the Unix shells.

This file is only read in interactive sessions, not when Python reads
commands from a script, and not when ‘/dev/tty’ is given as the explicit
source of commands (which otherwise behaves like an interactive
session).  It is executed in the same namespace where interactive
commands are executed, so that objects that it defines or imports can be
used without qualification in the interactive session.  You can also
change the prompts ‘sys.ps1’ and ‘sys.ps2’ in this file.

If you want to read an additional start-up file from the current
directory, you can program this in the global start-up file using code
like ‘if os.path.isfile('.pythonrc.py'):
exec(open('.pythonrc.py').read())’.  If you want to use the startup file
in a script, you must do this explicitly in the script:

     import os
     filename = os.environ.get('PYTHONSTARTUP')
     if filename and os.path.isfile(filename):
         with open(filename) as fobj:
            startup_file = fobj.read()
         exec(startup_file)


File: python.info,  Node: The Customization Modules,  Prev: The Interactive Startup File,  Up: Interactive Mode<2>

2.15.1.4 The Customization Modules
..................................

Python provides two hooks to let you customize it: ‘sitecustomize’ and
‘usercustomize’.  To see how it works, you need first to find the
location of your user site-packages directory.  Start Python and run
this code:

     >>> import site
     >>> site.getusersitepackages()
     '/home/user/.local/lib/python3.4/site-packages'

Now you can create a file named ‘usercustomize.py’ in that directory and
put anything you want in it.  It will affect every invocation of Python,
unless it is started with the *note -s: 786. option to disable the
automatic import.

‘sitecustomize’ works in the same way, but is typically created by an
administrator of the computer in the global site-packages directory, and
is imported before ‘usercustomize’.  See the documentation of the *note
site: e6. module for more details.


File: python.info,  Node: Python Setup and Usage,  Next: The Python Language Reference,  Prev: The Python Tutorial,  Up: Top

3 Python Setup and Usage
************************

This part of the documentation is devoted to general information on the
setup of the Python environment on different platform, the invocation of
the interpreter and things that make working with Python easier.

* Menu:

* Command line and environment:: 
* Using Python on Unix platforms:: 
* Using Python on Windows:: 
* Using Python on a Macintosh:: 
* Additional Tools and Scripts:: 


File: python.info,  Node: Command line and environment,  Next: Using Python on Unix platforms,  Up: Python Setup and Usage

3.1 Command line and environment
================================

The CPython interpreter scans the command line and the environment for
various settings.

`CPython implementation detail:' Other implementations’ command line
schemes may differ.  See *note Alternate Implementations: b20. for
further resources.

* Menu:

* Command line:: 
* Environment variables:: 


File: python.info,  Node: Command line,  Next: Environment variables,  Up: Command line and environment

3.1.1 Command line
------------------

When invoking Python, you may specify any of these options:

     python [-bBdEhiIOqsSuvVWx?] [-c command | -m module-name | script | - ] [args]

The most common use case is, of course, a simple invocation of a script:

     python myscript.py

* Menu:

* Interface options:: 
* Generic options:: 
* Miscellaneous options:: 
* Options you shouldn't use:: 


File: python.info,  Node: Interface options,  Next: Generic options,  Up: Command line

3.1.1.1 Interface options
.........................

The interpreter interface resembles that of the UNIX shell, but provides
some additional methods of invocation:

   * When called with standard input connected to a tty device, it
     prompts for commands and executes them until an EOF (an end-of-file
     character, you can produce that with `Ctrl-D' on UNIX or `Ctrl-Z,
     Enter' on Windows) is read.

   * When called with a file name argument or with a file as standard
     input, it reads and executes a script from that file.

   * When called with a directory name argument, it reads and executes
     an appropriately named script from that directory.

   * When called with ‘-c command’, it executes the Python statement(s)
     given as `command'.  Here `command' may contain multiple statements
     separated by newlines.  Leading whitespace is significant in Python
     statements!

   * When called with ‘-m module-name’, the given module is located on
     the Python module path and executed as a script.

In non-interactive mode, the entire input is parsed before it is
executed.

An interface option terminates the list of options consumed by the
interpreter, all consecutive arguments will end up in *note sys.argv:
64d. – note that the first element, subscript zero (‘sys.argv[0]’), is a
string reflecting the program’s source.

 -- Program Option: - c <command>

     Execute the Python code in `command'.  `command' can be one or more
     statements separated by newlines, with significant leading
     whitespace as in normal module code.

     If this option is given, the first element of *note sys.argv: 64d.
     will be ‘"-c"’ and the current directory will be added to the start
     of *note sys.path: 2d5. (allowing modules in that directory to be
     imported as top level modules).

 -- Program Option: - m <module-name>

     Search *note sys.path: 2d5. for the named module and execute its
     contents as the *note __main__: 1. module.

     Since the argument is a `module' name, you must not give a file
     extension (‘.py’).  The ‘module-name’ should be a valid Python
     module name, but the implementation may not always enforce this
     (e.g.  it may allow you to use a name that includes a hyphen).

     Package names (including namespace packages) are also permitted.
     When a package name is supplied instead of a normal module, the
     interpreter will execute ‘<pkg>.__main__’ as the main module.  This
     behaviour is deliberately similar to the handling of directories
     and zipfiles that are passed to the interpreter as the script
     argument.

          Note: This option cannot be used with built-in modules and
          extension modules written in C, since they do not have Python
          module files.  However, it can still be used for precompiled
          modules, even if the original source file is not available.

     If this option is given, the first element of *note sys.argv: 64d.
     will be the full path to the module file (while the module file is
     being located, the first element will be set to ‘"-m"’).  As with
     the *note -c: 738. option, the current directory will be added to
     the start of *note sys.path: 2d5.

     Many standard library modules contain code that is invoked on their
     execution as a script.  An example is the *note timeit: 105.
     module:

          python -mtimeit -s 'setup here' 'benchmarked code here'
          python -mtimeit -h # for details

     See also
.............

     *note runpy.run_module(): b24.

          Equivalent functionality directly available to Python code

     PEP 338(1) – Executing modules as scripts

     Changed in version 3.1: Supply the package name to run a ‘__main__’
     submodule.

     Changed in version 3.4: namespace packages are also supported

 -- Describe: -

     Read commands from standard input (*note sys.stdin: 692.).  If
     standard input is a terminal, *note -i: 8ab. is implied.

     If this option is given, the first element of *note sys.argv: 64d.
     will be ‘"-"’ and the current directory will be added to the start
     of *note sys.path: 2d5.

 -- Describe: <script>

     Execute the Python code contained in `script', which must be a
     filesystem path (absolute or relative) referring to either a Python
     file, a directory containing a ‘__main__.py’ file, or a zipfile
     containing a ‘__main__.py’ file.

     If this option is given, the first element of *note sys.argv: 64d.
     will be the script name as given on the command line.

     If the script name refers directly to a Python file, the directory
     containing that file is added to the start of *note sys.path: 2d5,
     and the file is executed as the *note __main__: 1. module.

     If the script name refers to a directory or zipfile, the script
     name is added to the start of *note sys.path: 2d5. and the
     ‘__main__.py’ file in that location is executed as the *note
     __main__: 1. module.

     See also
.............

     *note runpy.run_path(): 722.

          Equivalent functionality directly available to Python code

If no interface option is given, *note -i: 8ab. is implied,
‘sys.argv[0]’ is an empty string (‘""’) and the current directory will
be added to the start of *note sys.path: 2d5.  Also, tab-completion and
history editing is automatically enabled, if available on your platform
(see *note Readline configuration: 285.).

See also
........

*note Invoking the Interpreter: 9fd.

Changed in version 3.4: Automatic enabling of tab-completion and history
editing.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0338


File: python.info,  Node: Generic options,  Next: Miscellaneous options,  Prev: Interface options,  Up: Command line

3.1.1.2 Generic options
.......................

 -- Program Option: - ?
 -- Program Option: - h
 -- Program Option: - -help

     Print a short description of all command line options.

 -- Program Option: - V
 -- Program Option: - -version

     Print the Python version number and exit.  Example output could be:

          Python 3.0


File: python.info,  Node: Miscellaneous options,  Next: Options you shouldn't use,  Prev: Generic options,  Up: Command line

3.1.1.3 Miscellaneous options
.............................

 -- Program Option: - b

     Issue a warning when comparing str and bytes.  Issue an error when
     the option is given twice (‘-bb’).

 -- Program Option: - B

     If given, Python won’t try to write ‘.pyc’ or ‘.pyo’ files on the
     import of source modules.  See also *note PYTHONDONTWRITEBYTECODE:
     7b0.

 -- Program Option: - d

     Turn on parser debugging output (for wizards only, depending on
     compilation options).  See also *note PYTHONDEBUG: b2a.

 -- Program Option: - E

     Ignore all ‘PYTHON*’ environment variables, e.g.  *note PYTHONPATH:
     30e. and *note PYTHONHOME: b2c, that might be set.

 -- Program Option: - i

     When a script is passed as first argument or the *note -c: 738.
     option is used, enter interactive mode after executing the script
     or the command, even when *note sys.stdin: 692. does not appear to
     be a terminal.  The *note PYTHONSTARTUP: 284. file is not read.

     This can be useful to inspect global variables or a stack trace
     when a script raises an exception.  See also *note PYTHONINSPECT:
     8aa.

 -- Program Option: - I

     Run Python in isolated mode.  This also implies -E and -s.  In
     isolated mode *note sys.path: 2d5. contains neither the script’s
     directory nor the user’s site-packages directory.  All ‘PYTHON*’
     environment variables are ignored, too.  Further restrictions may
     be imposed to prevent the user from injecting malicious code.

     New in version 3.4.

 -- Program Option: - O

     Turn on basic optimizations.  This changes the filename extension
     for compiled (*note bytecode: b2e.) files from ‘.pyc’ to ‘.pyo’.
     See also *note PYTHONOPTIMIZE: b2f.

 -- Program Option: - OO

     Discard docstrings in addition to the *note -O: 891. optimizations.

 -- Program Option: - q

     Don’t display the copyright and version messages even in
     interactive mode.

     New in version 3.2.

 -- Program Option: - R

     Kept for compatibility.  On Python 3.3 and greater, hash
     randomization is turned on by default.

     On previous versions of Python, this option turns on hash
     randomization, so that the *note __hash__(): 39f. values of str,
     bytes and datetime are "salted" with an unpredictable random value.
     Although they remain constant within an individual Python process,
     they are not predictable between repeated invocations of Python.

     Hash randomization is intended to provide protection against a
     denial-of-service caused by carefully-chosen inputs that exploit
     the worst case performance of a dict construction, O(n^2)
     complexity.  See
     ‘http://www.ocert.org/advisories/ocert-2011-003.html’ for details.

     *note PYTHONHASHSEED: 3a0. allows you to set a fixed value for the
     hash seed secret.

     New in version 3.2.3.

 -- Program Option: - s

     Don’t add the *note user site-packages directory: b31. to *note
     sys.path: 2d5.

     See also
.............

     PEP 370(1) – Per user site-packages directory

 -- Program Option: - S

     Disable the import of the module *note site: e6. and the
     site-dependent manipulations of *note sys.path: 2d5. that it
     entails.  Also disable these manipulations if *note site: e6. is
     explicitly imported later (call *note site.main(): b32. if you want
     them to be triggered).

 -- Program Option: - u

     Force the binary layer of the stdout and stderr streams (which is
     available as their ‘buffer’ attribute) to be unbuffered.  The text
     I/O layer will still be line-buffered if writing to the console, or
     block-buffered if redirected to a non-interactive file.

     See also *note PYTHONUNBUFFERED: b33.

 -- Program Option: - v

     Print a message each time a module is initialized, showing the
     place (filename or built-in module) from which it is loaded.  When
     given twice (‘-vv’), print a message for each file that is checked
     for when searching for a module.  Also provides information on
     module cleanup at exit.  See also *note PYTHONVERBOSE: b34.

 -- Program Option: - W arg

     Warning control.  Python’s warning machinery by default prints
     warning messages to *note sys.stderr: 5ac.  A typical warning
     message has the following form:

          file:line: category: message

     By default, each warning is printed once for each source line where
     it occurs.  This option controls how often warnings are printed.

     Multiple *note -W: 6e4. options may be given; when a warning
     matches more than one option, the action for the last matching
     option is performed.  Invalid *note -W: 6e4. options are ignored
     (though, a warning message is printed about invalid options when
     the first warning is issued).

     Warnings can also be controlled from within a Python program using
     the *note warnings: 11f. module.

     The simplest form of argument is one of the following action
     strings (or a unique abbreviation):

     ‘ignore’

          Ignore all warnings.

     ‘default’

          Explicitly request the default behavior (printing each warning
          once per source line).

     ‘all’

          Print a warning each time it occurs (this may generate many
          messages if a warning is triggered repeatedly for the same
          source line, such as inside a loop).

     ‘module’

          Print each warning only the first time it occurs in each
          module.

     ‘once’

          Print each warning only the first time it occurs in the
          program.

     ‘error’

          Raise an exception instead of printing a warning message.

     The full form of argument is:

          action:message:category:module:line

     Here, `action' is as explained above but only applies to messages
     that match the remaining fields.  Empty fields match all values;
     trailing empty fields may be omitted.  The `message' field matches
     the start of the warning message printed; this match is
     case-insensitive.  The `category' field matches the warning
     category.  This must be a class name; the match tests whether the
     actual warning category of the message is a subclass of the
     specified warning category.  The full class name must be given.
     The `module' field matches the (fully-qualified) module name; this
     match is case-sensitive.  The `line' field matches the line number,
     where zero matches all line numbers and is thus equivalent to an
     omitted line number.

     See also
.............

     *note warnings: 11f. – the warnings module

     PEP 230(2) – Warning framework

     *note PYTHONWARNINGS: 566.

 -- Program Option: - x

     Skip the first line of the source, allowing use of non-Unix forms
     of ‘#!cmd’.  This is intended for a DOS specific hack only.

          Note: The line numbers in error messages will be off by one.

 -- Program Option: - X

     Reserved for various implementation-specific options.  CPython
     currently defines the following possible values:

        * ‘-X faulthandler’ to enable *note faulthandler: 7b.;

        * ‘-X showrefcount’ to enable the output of the total reference
          count and memory blocks (only works on debug builds);

        * ‘-X tracemalloc’ to start tracing Python memory allocations
          using the *note tracemalloc: 10e. module.  By default, only
          the most recent frame is stored in a traceback of a trace.
          Use ‘-X tracemalloc=NFRAME’ to start tracing with a traceback
          limit of `NFRAME' frames.  See the *note tracemalloc.start():
          b36. for more information.

     It also allows to pass arbitrary values and retrieve them through
     the *note sys._xoptions: b37. dictionary.

     Changed in version 3.2: It is now allowed to pass *note -X: 3a6.
     with CPython.

     New in version 3.3: The ‘-X faulthandler’ option.

     New in version 3.4: The ‘-X showrefcount’ and ‘-X tracemalloc’
     options.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0370

   (2) https://www.python.org/dev/peps/pep-0230


File: python.info,  Node: Options you shouldn't use,  Prev: Miscellaneous options,  Up: Command line

3.1.1.4 Options you shouldn’t use
.................................

 -- Program Option: - J

     Reserved for use by Jython(1).

   ---------- Footnotes ----------

   (1) http://www.jython.org/


File: python.info,  Node: Environment variables,  Prev: Command line,  Up: Command line and environment

3.1.2 Environment variables
---------------------------

These environment variables influence Python’s behavior, they are
processed before the command-line switches other than -E or -I. It is
customary that command-line switches override environmental variables
where there is a conflict.

 -- Environment Variable: PYTHONHOME

     Change the location of the standard Python libraries.  By default,
     the libraries are searched in ‘`prefix'/lib/python`version'’ and
     ‘`exec_prefix'/lib/python`version'’, where ‘`prefix'’ and
     ‘`exec_prefix'’ are installation-dependent directories, both
     defaulting to ‘/usr/local’.

     When *note PYTHONHOME: b2c. is set to a single directory, its value
     replaces both ‘`prefix'’ and ‘`exec_prefix'’.  To specify different
     values for these, set *note PYTHONHOME: b2c. to
     ‘`prefix':`exec_prefix'’.

 -- Environment Variable: PYTHONPATH

     Augment the default search path for module files.  The format is
     the same as the shell’s ‘PATH’: one or more directory pathnames
     separated by *note os.pathsep: b3b. (e.g.  colons on Unix or
     semicolons on Windows).  Non-existent directories are silently
     ignored.

     In addition to normal directories, individual *note PYTHONPATH:
     30e. entries may refer to zipfiles containing pure Python modules
     (in either source or compiled form).  Extension modules cannot be
     imported from zipfiles.

     The default search path is installation dependent, but generally
     begins with ‘`prefix'/lib/python`version'’ (see *note PYTHONHOME:
     b2c. above).  It is `always' appended to *note PYTHONPATH: 30e.

     An additional directory will be inserted in the search path in
     front of *note PYTHONPATH: 30e. as described above under *note
     Interface options: b23.  The search path can be manipulated from
     within a Python program as the variable *note sys.path: 2d5.

 -- Environment Variable: PYTHONSTARTUP

     If this is the name of a readable file, the Python commands in that
     file are executed before the first prompt is displayed in
     interactive mode.  The file is executed in the same namespace where
     interactive commands are executed so that objects defined or
     imported in it can be used without qualification in the interactive
     session.  You can also change the prompts *note sys.ps1: b3c. and
     *note sys.ps2: b3d. and the hook *note sys.__interactivehook__:
     283. in this file.

 -- Environment Variable: PYTHONOPTIMIZE

     If this is set to a non-empty string it is equivalent to specifying
     the *note -O: 891. option.  If set to an integer, it is equivalent
     to specifying *note -O: 891. multiple times.

 -- Environment Variable: PYTHONDEBUG

     If this is set to a non-empty string it is equivalent to specifying
     the *note -d: b29. option.  If set to an integer, it is equivalent
     to specifying *note -d: b29. multiple times.

 -- Environment Variable: PYTHONINSPECT

     If this is set to a non-empty string it is equivalent to specifying
     the *note -i: 8ab. option.

     This variable can also be modified by Python code using *note
     os.environ: 554. to force inspect mode on program termination.

 -- Environment Variable: PYTHONUNBUFFERED

     If this is set to a non-empty string it is equivalent to specifying
     the *note -u: 8ac. option.

 -- Environment Variable: PYTHONVERBOSE

     If this is set to a non-empty string it is equivalent to specifying
     the *note -v: 808. option.  If set to an integer, it is equivalent
     to specifying *note -v: 808. multiple times.

 -- Environment Variable: PYTHONCASEOK

     If this is set, Python ignores case in *note import: 674.
     statements.  This only works on Windows and OS X.

 -- Environment Variable: PYTHONDONTWRITEBYTECODE

     If this is set to a non-empty string, Python won’t try to write
     ‘.pyc’ or ‘.pyo’ files on the import of source modules.  This is
     equivalent to specifying the *note -B: 7af. option.

 -- Environment Variable: PYTHONHASHSEED

     If this variable is not set or set to ‘random’, a random value is
     used to seed the hashes of str, bytes and datetime objects.

     If *note PYTHONHASHSEED: 3a0. is set to an integer value, it is
     used as a fixed seed for generating the hash() of the types covered
     by the hash randomization.

     Its purpose is to allow repeatable hashing, such as for selftests
     for the interpreter itself, or to allow a cluster of python
     processes to share hash values.

     The integer must be a decimal number in the range [0,4294967295].
     Specifying the value 0 will disable hash randomization.

     New in version 3.2.3.

 -- Environment Variable: PYTHONIOENCODING

     If this is set before running the interpreter, it overrides the
     encoding used for stdin/stdout/stderr, in the syntax
     ‘encodingname:errorhandler’.  Both the ‘encodingname’ and the
     ‘:errorhandler’ parts are optional and have the same meaning as in
     *note str.encode(): 690.

     For stderr, the ‘:errorhandler’ part is ignored; the handler will
     always be ‘'backslashreplace'’.

     Changed in version 3.4: The ‘encodingname’ part is now optional.

 -- Environment Variable: PYTHONNOUSERSITE

     If this is set, Python won’t add the *note user site-packages
     directory: b31. to *note sys.path: 2d5.

     See also
.............

     PEP 370(1) – Per user site-packages directory

 -- Environment Variable: PYTHONUSERBASE

     Defines the *note user base directory: b3e, which is used to
     compute the path of the *note user site-packages directory: b31.
     and *note Distutils installation paths: b3f. for ‘python setup.py
     install --user’.

     See also
.............

     PEP 370(2) – Per user site-packages directory

 -- Environment Variable: PYTHONEXECUTABLE

     If this environment variable is set, ‘sys.argv[0]’ will be set to
     its value instead of the value got through the C runtime.  Only
     works on Mac OS X.

 -- Environment Variable: PYTHONWARNINGS

     This is equivalent to the *note -W: 6e4. option.  If set to a comma
     separated string, it is equivalent to specifying *note -W: 6e4.
     multiple times.

 -- Environment Variable: PYTHONFAULTHANDLER

     If this environment variable is set to a non-empty string, *note
     faulthandler.enable(): 3a4. is called at startup: install a handler
     for ‘SIGSEGV’, ‘SIGFPE’, ‘SIGABRT’, ‘SIGBUS’ and ‘SIGILL’ signals
     to dump the Python traceback.  This is equivalent to *note -X: 3a6.
     ‘faulthandler’ option.

     New in version 3.3.

 -- Environment Variable: PYTHONTRACEMALLOC

     If this environment variable is set to a non-empty string, start
     tracing Python memory allocations using the *note tracemalloc: 10e.
     module.  The value of the variable is the maximum number of frames
     stored in a traceback of a trace.  For example,
     ‘PYTHONTRACEMALLOC=1’ stores only the most recent frame.  See the
     *note tracemalloc.start(): b36. for more information.

     New in version 3.4.

 -- Environment Variable: PYTHONASYNCIODEBUG

     If this environment variable is set to a non-empty string, enable
     the *note debug mode: b43. of the *note asyncio: a. module.

     New in version 3.4.

* Menu:

* Debug-mode variables:: 

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0370

   (2) https://www.python.org/dev/peps/pep-0370


File: python.info,  Node: Debug-mode variables,  Up: Environment variables

3.1.2.1 Debug-mode variables
............................

Setting these variables only has an effect in a debug build of Python,
that is, if Python was configured with the ‘--with-pydebug’ build
option.

 -- Environment Variable: PYTHONTHREADDEBUG

     If set, Python will print threading debug info.

 -- Environment Variable: PYTHONDUMPREFS

     If set, Python will dump objects and reference counts still alive
     after shutting down the interpreter.

 -- Environment Variable: PYTHONMALLOCSTATS

     If set, Python will print memory allocation statistics every time a
     new object arena is created, and on shutdown.


File: python.info,  Node: Using Python on Unix platforms,  Next: Using Python on Windows,  Prev: Command line and environment,  Up: Python Setup and Usage

3.2 Using Python on Unix platforms
==================================

* Menu:

* Getting and installing the latest version of Python:: 
* Building Python:: 
* Python-related paths and files:: 
* Miscellaneous:: 
* Editors:: 


File: python.info,  Node: Getting and installing the latest version of Python,  Next: Building Python,  Up: Using Python on Unix platforms

3.2.1 Getting and installing the latest version of Python
---------------------------------------------------------

* Menu:

* On Linux:: 
* On FreeBSD and OpenBSD:: 
* On OpenSolaris:: 


File: python.info,  Node: On Linux,  Next: On FreeBSD and OpenBSD,  Up: Getting and installing the latest version of Python

3.2.1.1 On Linux
................

Python comes preinstalled on most Linux distributions, and is available
as a package on all others.  However there are certain features you
might want to use that are not available on your distro’s package.  You
can easily compile the latest version of Python from source.

In the event that Python doesn’t come preinstalled and isn’t in the
repositories as well, you can easily make packages for your own distro.
Have a look at the following links:

See also
........

‘http://www.debian.org/doc/manuals/maint-guide/first.en.html’

     for Debian users

‘http://en.opensuse.org/Portal:Packaging’

     for OpenSuse users

‘http://docs.fedoraproject.org/en-US/Fedora_Draft_Documentation/0.1/html/RPM_Guide/ch-creating-rpms.html’

     for Fedora users

‘http://www.slackbook.org/html/package-management-making-packages.html’

     for Slackware users


File: python.info,  Node: On FreeBSD and OpenBSD,  Next: On OpenSolaris,  Prev: On Linux,  Up: Getting and installing the latest version of Python

3.2.1.2 On FreeBSD and OpenBSD
..............................

   * FreeBSD users, to add the package use:

          pkg_add -r python

   * OpenBSD users use:

          pkg_add ftp://ftp.openbsd.org/pub/OpenBSD/4.2/packages/<insert your architecture here>/python-<version>.tgz

     For example i386 users get the 2.5.1 version of Python using:

          pkg_add ftp://ftp.openbsd.org/pub/OpenBSD/4.2/packages/i386/python-2.5.1p2.tgz


File: python.info,  Node: On OpenSolaris,  Prev: On FreeBSD and OpenBSD,  Up: Getting and installing the latest version of Python

3.2.1.3 On OpenSolaris
......................

You can get Python from OpenCSW(1). Various versions of Python are
available and can be installed with e.g.  ‘pkgutil -i python27’.

   ---------- Footnotes ----------

   (1) http://www.opencsw.org/


File: python.info,  Node: Building Python,  Next: Python-related paths and files,  Prev: Getting and installing the latest version of Python,  Up: Using Python on Unix platforms

3.2.2 Building Python
---------------------

If you want to compile CPython yourself, first thing you should do is
get the source(1).  You can download either the latest release’s source
or just grab a fresh clone(2).  (If you want to contribute patches, you
will need a clone.)

The build process consists in the usual

     ./configure
     make
     make install

invocations.  Configuration options and caveats for specific Unix
platforms are extensively documented in the README(3) file in the root
of the Python source tree.

     Warning: ‘make install’ can overwrite or masquerade the ‘python3’
     binary.  ‘make altinstall’ is therefore recommended instead of
     ‘make install’ since it only installs
     ‘`exec_prefix'/bin/python`version'’.

   ---------- Footnotes ----------

   (1) https://www.python.org/download/source/

   (2) 
https://docs.python.org/devguide/setup.html#getting-the-source-code

   (3) https://hg.python.org/cpython/file/3.4/README


File: python.info,  Node: Python-related paths and files,  Next: Miscellaneous,  Prev: Building Python,  Up: Using Python on Unix platforms

3.2.3 Python-related paths and files
------------------------------------

These are subject to difference depending on local installation
conventions; ‘prefix’ (‘${prefix}’) and ‘exec_prefix’ (‘${exec_prefix}’)
are installation-dependent and should be interpreted as for GNU
software; they may be the same.

For example, on most Linux systems, the default for both is ‘/usr’.

File/directory                                      Meaning
                                                    
---------------------------------------------------------------------------------------------------
                                                    
‘`exec_prefix'/bin/python3’                         Recommended location of the interpreter.
                                                    
                                                    
‘`prefix'/lib/python`version'’,                     Recommended locations of the directories
‘`exec_prefix'/lib/python`version'’                 containing the standard modules.
                                                    
                                                    
‘`prefix'/include/python`version'’,                 Recommended locations of the directories
‘`exec_prefix'/include/python`version'’             containing the include files needed for
                                                    developing Python extensions and embedding
                                                    the interpreter.
                                                    


File: python.info,  Node: Miscellaneous,  Next: Editors,  Prev: Python-related paths and files,  Up: Using Python on Unix platforms

3.2.4 Miscellaneous
-------------------

To easily use Python scripts on Unix, you need to make them executable,
e.g.  with

     $ chmod +x script

and put an appropriate Shebang line at the top of the script.  A good
choice is usually

     #!/usr/bin/env python3

which searches for the Python interpreter in the whole ‘PATH’.  However,
some Unices may not have the ‘env’ command, so you may need to hardcode
‘/usr/bin/python3’ as the interpreter path.

To use shell commands in your Python scripts, look at the *note
subprocess: f4. module.


File: python.info,  Node: Editors,  Prev: Miscellaneous,  Up: Using Python on Unix platforms

3.2.5 Editors
-------------

Vim and Emacs are excellent editors which support Python very well.  For
more information on how to code in Python in these editors, look at:

   * ‘http://www.vim.org/scripts/script.php?script_id=790’

   * ‘http://sourceforge.net/projects/python-mode’

Geany is an excellent IDE with support for a lot of languages.  For more
information, read: ‘http://www.geany.org/’

Komodo edit is another extremely good IDE. It also has support for a lot
of languages.  For more information, read ‘http://komodoide.com/’.


File: python.info,  Node: Using Python on Windows,  Next: Using Python on a Macintosh,  Prev: Using Python on Unix platforms,  Up: Python Setup and Usage

3.3 Using Python on Windows
===========================

This document aims to give an overview of Windows-specific behaviour you
should know about when using Python on Microsoft Windows.

* Menu:

* Installing Python:: 
* Alternative bundles:: 
* Configuring Python:: 
* Python Launcher for Windows:: 
* Additional modules:: 
* Compiling Python on Windows:: 
* Other resources:: 


File: python.info,  Node: Installing Python,  Next: Alternative bundles,  Up: Using Python on Windows

3.3.1 Installing Python
-----------------------

Unlike most Unix systems and services, Windows does not require Python
natively and thus does not pre-install a version of Python.  However,
the CPython team has compiled Windows installers (MSI packages) with
every release(1) for many years.

With ongoing development of Python, some platforms that used to be
supported earlier are no longer supported (due to the lack of users or
developers).  Check PEP 11(2) for details on all unsupported platforms.

   * Windows CE(3) is still supported.

   * The Cygwin(4) installer offers to install the Python interpreter as
     well (cf.  Cygwin package source(5), Maintainer releases(6))

See Python for Windows(7) for detailed information about platforms with
pre-compiled installers.

See also
........

Python on XP(8)

     "7 Minutes to "Hello World!""  by Richard Dooling, 2006

Installing on Windows(9)

     in "Dive into Python: Python from novice to pro(10)" by Mark
     Pilgrim, 2004, ISBN 1-59059-356-1

For Windows users(11)

     in "Installing Python" in "A Byte of Python(12)" by Swaroop C H,
     2003

   ---------- Footnotes ----------

   (1) https://www.python.org/download/releases/

   (2) https://www.python.org/dev/peps/pep-0011

   (3) http://pythonce.sourceforge.net/

   (4) http://cygwin.com/

   (5) 
ftp://ftp.uni-erlangen.de/pub/pc/gnuwin32/cygwin/mirrors/cygnus/release/python

   (6) http://www.tishler.net/jason/software/python/

   (7) https://www.python.org/download/windows/

   (8) 
http://www.richarddooling.com/index.php/2006/03/14/python-on-xp-7-minutes-to-hello-world/

   (9) http://www.diveintopython.net/installing_python/windows.html

   (10) http://www.diveintopython.net/

   (11) http://www.swaroopch.com/notes/python/#install_windows

   (12) http://www.swaroopch.com/notes/python/


File: python.info,  Node: Alternative bundles,  Next: Configuring Python,  Prev: Installing Python,  Up: Using Python on Windows

3.3.2 Alternative bundles
-------------------------

Besides the standard CPython distribution, there are modified packages
including additional functionality.  The following is a list of popular
versions and their key features:

ActivePython(1)

     Installer with multi-platform compatibility, documentation, PyWin32

Enthought Python Distribution(2)

     Popular modules (such as PyWin32) with their respective
     documentation, tool suite for building extensible Python
     applications

Notice that these packages are likely to install `older' versions of
Python.

   ---------- Footnotes ----------

   (1) http://www.activestate.com/activepython/

   (2) https://www.enthought.com/products/epd/


File: python.info,  Node: Configuring Python,  Next: Python Launcher for Windows,  Prev: Alternative bundles,  Up: Using Python on Windows

3.3.3 Configuring Python
------------------------

In order to run Python flawlessly, you might have to change certain
environment settings in Windows.

* Menu:

* Excursus; Setting environment variables: Excursus Setting environment variables. 
* Finding the Python executable:: 
* Finding modules:: 
* Executing scripts:: 
* Executing scripts without the Python launcher:: 


File: python.info,  Node: Excursus Setting environment variables,  Next: Finding the Python executable,  Up: Configuring Python

3.3.3.1 Excursus: Setting environment variables
...............................................

Windows has a built-in dialog for changing environment variables
(following guide applies to XP classical view): Right-click the icon for
your machine (usually located on your Desktop and called "My Computer")
and choose Properties there.  Then, open the Advanced tab and click the
Environment Variables button.

In short, your path is:

     My Computer ‣ Properties ‣ Advanced ‣ Environment Variables

In this dialog, you can add or modify User and System variables.  To
change System variables, you need non-restricted access to your machine
(i.e.  Administrator rights).

Another way of adding variables to your environment is using the ‘set’
command:

     set PYTHONPATH=%PYTHONPATH%;C:\My_python_lib

To make this setting permanent, you could add the corresponding command
line to your ‘autoexec.bat’.  ‘msconfig’ is a graphical interface to
this file.

Viewing environment variables can also be done more straight-forward:
The command prompt will expand strings wrapped into percent signs
automatically:

     echo %PATH%

Consult ‘set /?’ for details on this behaviour.

See also
........

‘http://support.microsoft.com/kb/100843’

     Environment variables in Windows NT

‘http://support.microsoft.com/kb/310519’

     How To Manage Environment Variables in Windows XP

‘http://www.chem.gla.ac.uk/~louis/software/faq/q1.html’

     Setting Environment variables, Louis J. Farrugia


File: python.info,  Node: Finding the Python executable,  Next: Finding modules,  Prev: Excursus Setting environment variables,  Up: Configuring Python

3.3.3.2 Finding the Python executable
.....................................

Changed in version 3.3.

Besides using the automatically created start menu entry for the Python
interpreter, you might want to start Python in the command prompt.  As
of Python 3.3, the installer has an option to set that up for you.

At the "Customize Python 3.3" screen, an option called "Add python.exe
to search path" can be enabled to have the installer place your
installation into the ‘%PATH%’.  This allows you to type ‘python’ to run
the interpreter.  Thus, you can also execute your scripts with command
line options, see *note Command line: 2d3. documentation.

If you don’t enable this option at install time, you can always re-run
the installer to choose it.

The alternative is manually modifying the ‘%PATH%’ using the directions
in *note Excursus; Setting environment variables: b59.  You need to set
your ‘%PATH%’ environment variable to include the directory of your
Python distribution, delimited by a semicolon from other entries.  An
example variable could look like this (assuming the first two entries
are Windows’ default):

     C:\WINDOWS\system32;C:\WINDOWS;C:\Python33


File: python.info,  Node: Finding modules,  Next: Executing scripts,  Prev: Finding the Python executable,  Up: Configuring Python

3.3.3.3 Finding modules
.......................

Python usually stores its library (and thereby your site-packages
folder) in the installation directory.  So, if you had installed Python
to ‘C:\Python\’, the default library would reside in ‘C:\Python\Lib\’
and third-party modules should be stored in
‘C:\Python\Lib\site-packages\’.

This is how *note sys.path: 2d5. is populated on Windows:

   * An empty entry is added at the start, which corresponds to the
     current directory.

   * If the environment variable *note PYTHONPATH: 30e. exists, as
     described in *note Environment variables: b39, its entries are
     added next.  Note that on Windows, paths in this variable must be
     separated by semicolons, to distinguish them from the colon used in
     drive identifiers (‘C:\’ etc.).

   * Additional "application paths" can be added in the registry as
     subkeys of ‘\SOFTWARE\Python\PythonCore\`version'\PythonPath’ under
     both the ‘HKEY_CURRENT_USER’ and ‘HKEY_LOCAL_MACHINE’ hives.
     Subkeys which have semicolon-delimited path strings as their
     default value will cause each path to be added to *note sys.path:
     2d5.  (Note that all known installers only use HKLM, so HKCU is
     typically empty.)

   * If the environment variable *note PYTHONHOME: b2c. is set, it is
     assumed as "Python Home".  Otherwise, the path of the main Python
     executable is used to locate a "landmark file" (‘Lib\os.py’) to
     deduce the "Python Home".  If a Python home is found, the relevant
     sub-directories added to *note sys.path: 2d5. (‘Lib’, ‘plat-win’,
     etc) are based on that folder.  Otherwise, the core Python path is
     constructed from the PythonPath stored in the registry.

   * If the Python Home cannot be located, no *note PYTHONPATH: 30e. is
     specified in the environment, and no registry entries can be found,
     a default path with relative entries is used (e.g.
     ‘.\Lib;.\plat-win’, etc).

The end result of all this is:

   * When running ‘python.exe’, or any other .exe in the main Python
     directory (either an installed version, or directly from the
     PCbuild directory), the core path is deduced, and the core paths in
     the registry are ignored.  Other "application paths" in the
     registry are always read.

   * When Python is hosted in another .exe (different directory,
     embedded via COM, etc), the "Python Home" will not be deduced, so
     the core path from the registry is used.  Other "application paths"
     in the registry are always read.

   * If Python can’t find its home and there is no registry (eg, frozen
     .exe, some very strange installation setup) you get a path with
     some default, but relative, paths.


File: python.info,  Node: Executing scripts,  Next: Executing scripts without the Python launcher,  Prev: Finding modules,  Up: Configuring Python

3.3.3.4 Executing scripts
.........................

As of Python 3.3, Python includes a launcher which facilitates running
Python scripts.  See *note Python Launcher for Windows: 35d. for more
information.


File: python.info,  Node: Executing scripts without the Python launcher,  Prev: Executing scripts,  Up: Configuring Python

3.3.3.5 Executing scripts without the Python launcher
.....................................................

Without the Python launcher installed, Python scripts (files with the
extension ‘.py’) will be executed by ‘python.exe’ by default.  This
executable opens a terminal, which stays open even if the program uses a
GUI. If you do not want this to happen, use the extension ‘.pyw’ which
will cause the script to be executed by ‘pythonw.exe’ by default (both
executables are located in the top-level of your Python installation
directory).  This suppresses the terminal window on startup.

You can also make all ‘.py’ scripts execute with ‘pythonw.exe’, setting
this through the usual facilities, for example (might require
administrative rights):

  1. Launch a command prompt.

  2. Associate the correct file group with ‘.py’ scripts:

          assoc .py=Python.File

  3. Redirect all Python files to the new executable:

          ftype Python.File=C:\Path\to\pythonw.exe "%1" %*


File: python.info,  Node: Python Launcher for Windows,  Next: Additional modules,  Prev: Configuring Python,  Up: Using Python on Windows

3.3.4 Python Launcher for Windows
---------------------------------

New in version 3.3.

The Python launcher for Windows is a utility which aids in the location
and execution of different Python versions.  It allows scripts (or the
command-line) to indicate a preference for a specific Python version,
and will locate and execute that version.

* Menu:

* Getting started:: 
* Shebang Lines:: 
* Arguments in shebang lines:: 
* Customization:: 
* Diagnostics:: 


File: python.info,  Node: Getting started,  Next: Shebang Lines,  Up: Python Launcher for Windows

3.3.4.1 Getting started
.......................

* Menu:

* From the command-line:: 
* From a script:: 
* From file associations:: 


File: python.info,  Node: From the command-line,  Next: From a script,  Up: Getting started

3.3.4.2 From the command-line
.............................

You should ensure the launcher is on your PATH - depending on how it was
installed it may already be there, but check just in case it is not.

From a command-prompt, execute the following command:

     py

You should find that the latest version of Python 2.x you have installed
is started - it can be exited as normal, and any additional command-line
arguments specified will be sent directly to Python.

If you have multiple versions of Python 2.x installed (e.g., 2.6 and
2.7) you will have noticed that Python 2.7 was started - to launch
Python 2.6, try the command:

     py -2.6

If you have a Python 3.x installed, try the command:

     py -3

You should find the latest version of Python 3.x starts.


File: python.info,  Node: From a script,  Next: From file associations,  Prev: From the command-line,  Up: Getting started

3.3.4.3 From a script
.....................

Let’s create a test Python script - create a file called ‘hello.py’ with
the following contents

     #! python
     import sys
     sys.stdout.write("hello from Python %s\n" % (sys.version,))

From the directory in which hello.py lives, execute the command:

     py hello.py

You should notice the version number of your latest Python 2.x
installation is printed.  Now try changing the first line to be:

     #! python3

Re-executing the command should now print the latest Python 3.x
information.  As with the above command-line examples, you can specify a
more explicit version qualifier.  Assuming you have Python 2.6
installed, try changing the first line to ‘#! python2.6’ and you should
find the 2.6 version information printed.


File: python.info,  Node: From file associations,  Prev: From a script,  Up: Getting started

3.3.4.4 From file associations
..............................

The launcher should have been associated with Python files (i.e.  ‘.py’,
‘.pyw’, ‘.pyc’, ‘.pyo’ files) when it was installed.  This means that
when you double-click on one of these files from Windows explorer the
launcher will be used, and therefore you can use the same facilities
described above to have the script specify the version which should be
used.

The key benefit of this is that a single launcher can support multiple
Python versions at the same time depending on the contents of the first
line.


File: python.info,  Node: Shebang Lines,  Next: Arguments in shebang lines,  Prev: Getting started,  Up: Python Launcher for Windows

3.3.4.5 Shebang Lines
.....................

If the first line of a script file starts with ‘#!’, it is known as a
"shebang" line.  Linux and other Unix like operating systems have native
support for such lines and are commonly used on such systems to indicate
how a script should be executed.  This launcher allows the same
facilities to be using with Python scripts on Windows and the examples
above demonstrate their use.

To allow shebang lines in Python scripts to be portable between Unix and
Windows, this launcher supports a number of ’virtual’ commands to
specify which interpreter to use.  The supported virtual commands are:

   * ‘/usr/bin/env python’

   * ‘/usr/bin/python’

   * ‘/usr/local/bin/python’

   * ‘python’

For example, if the first line of your script starts with

     #! /usr/bin/python

The default Python will be located and used.  As many Python scripts
written to work on Unix will already have this line, you should find
these scripts can be used by the launcher without modification.  If you
are writing a new script on Windows which you hope will be useful on
Unix, you should use one of the shebang lines starting with ‘/usr’.


File: python.info,  Node: Arguments in shebang lines,  Next: Customization,  Prev: Shebang Lines,  Up: Python Launcher for Windows

3.3.4.6 Arguments in shebang lines
..................................

The shebang lines can also specify additional options to be passed to
the Python interpreter.  For example, if you have a shebang line:

     #! /usr/bin/python -v

Then Python will be started with the ‘-v’ option


File: python.info,  Node: Customization,  Next: Diagnostics,  Prev: Arguments in shebang lines,  Up: Python Launcher for Windows

3.3.4.7 Customization
.....................

* Menu:

* Customization via INI files:: 
* Customizing default Python versions:: 


File: python.info,  Node: Customization via INI files,  Next: Customizing default Python versions,  Up: Customization

3.3.4.8 Customization via INI files
...................................

     Two .ini files will be searched by the launcher - ‘py.ini’ in the
     current user’s "application data" directory (i.e.  the directory
     returned by calling the Windows function SHGetFolderPath with
     CSIDL_LOCAL_APPDATA) and ‘py.ini’ in the same directory as the
     launcher.  The same .ini files are used for both the ’console’
     version of the launcher (i.e.  py.exe) and for the ’windows’
     version (i.e.  pyw.exe)

     Customization specified in the "application directory" will have
     precedence over the one next to the executable, so a user, who may
     not have write access to the .ini file next to the launcher, can
     override commands in that global .ini file)


File: python.info,  Node: Customizing default Python versions,  Prev: Customization via INI files,  Up: Customization

3.3.4.9 Customizing default Python versions
...........................................

In some cases, a version qualifier can be included in a command to
dictate which version of Python will be used by the command.  A version
qualifier starts with a major version number and can optionally be
followed by a period (’.’) and a minor version specifier.  If the minor
qualifier is specified, it may optionally be followed by "-32" to
indicate the 32-bit implementation of that version be used.

For example, a shebang line of ‘#!python’ has no version qualifier,
while ‘#!python3’ has a version qualifier which specifies only a major
version.

If no version qualifiers are found in a command, the environment
variable ‘PY_PYTHON’ can be set to specify the default version qualifier
- the default value is "2".  Note this value could specify just a major
version (e.g.  "2") or a major.minor qualifier (e.g.  "2.6"), or even
major.minor-32.

If no minor version qualifiers are found, the environment variable
‘PY_PYTHON{major}’ (where ‘{major}’ is the current major version
qualifier as determined above) can be set to specify the full version.
If no such option is found, the launcher will enumerate the installed
Python versions and use the latest minor release found for the major
version, which is likely, although not guaranteed, to be the most
recently installed version in that family.

On 64-bit Windows with both 32-bit and 64-bit implementations of the
same (major.minor) Python version installed, the 64-bit version will
always be preferred.  This will be true for both 32-bit and 64-bit
implementations of the launcher - a 32-bit launcher will prefer to
execute a 64-bit Python installation of the specified version if
available.  This is so the behavior of the launcher can be predicted
knowing only what versions are installed on the PC and without regard to
the order in which they were installed (i.e., without knowing whether a
32 or 64-bit version of Python and corresponding launcher was installed
last).  As noted above, an optional "-32" suffix can be used on a
version specifier to change this behaviour.

Examples:

   * If no relevant options are set, the commands ‘python’ and ‘python2’
     will use the latest Python 2.x version installed and the command
     ‘python3’ will use the latest Python 3.x installed.

   * The commands ‘python3.1’ and ‘python2.7’ will not consult any
     options at all as the versions are fully specified.

   * If ‘PY_PYTHON=3’, the commands ‘python’ and ‘python3’ will both use
     the latest installed Python 3 version.

   * If ‘PY_PYTHON=3.1-32’, the command ‘python’ will use the 32-bit
     implementation of 3.1 whereas the command ‘python3’ will use the
     latest installed Python (PY_PYTHON was not considered at all as a
     major version was specified.)

   * If ‘PY_PYTHON=3’ and ‘PY_PYTHON3=3.1’, the commands ‘python’ and
     ‘python3’ will both use specifically 3.1

In addition to environment variables, the same settings can be
configured in the .INI file used by the launcher.  The section in the
INI file is called ‘[defaults]’ and the key name will be the same as the
environment variables without the leading ‘PY_’ prefix (and note that
the key names in the INI file are case insensitive.)  The contents of an
environment variable will override things specified in the INI file.

For example:

   * Setting ‘PY_PYTHON=3.1’ is equivalent to the INI file containing:

     [defaults]
     python=3.1

   * Setting ‘PY_PYTHON=3’ and ‘PY_PYTHON3=3.1’ is equivalent to the INI
     file containing:

     [defaults]
     python=3
     python3=3.1


File: python.info,  Node: Diagnostics,  Prev: Customization,  Up: Python Launcher for Windows

3.3.4.10 Diagnostics
....................

If an environment variable ‘PYLAUNCH_DEBUG’ is set (to any value), the
launcher will print diagnostic information to stderr (i.e.  to the
console).  While this information manages to be simultaneously verbose
`and' terse, it should allow you to see what versions of Python were
located, why a particular version was chosen and the exact command-line
used to execute the target Python.


File: python.info,  Node: Additional modules,  Next: Compiling Python on Windows,  Prev: Python Launcher for Windows,  Up: Using Python on Windows

3.3.5 Additional modules
------------------------

Even though Python aims to be portable among all platforms, there are
features that are unique to Windows.  A couple of modules, both in the
standard library and external, and snippets exist to use these features.

The Windows-specific standard modules are documented in *note MS Windows
Specific Services: b6b.

* Menu:

* PyWin32:: 
* cx_Freeze:: 
* WConio:: 


File: python.info,  Node: PyWin32,  Next: cx_Freeze,  Up: Additional modules

3.3.5.1 PyWin32
...............

The PyWin32(1) module by Mark Hammond is a collection of modules for
advanced Windows-specific support.  This includes utilities for:

   * Component Object Model(2) (COM)

   * Win32 API calls

   * Registry

   * Event log

   * Microsoft Foundation Classes(3) (MFC) user interfaces

PythonWin(4) is a sample MFC application shipped with PyWin32.  It is an
embeddable IDE with a built-in debugger.

See also
........

Win32 How Do I...?(5)

     by Tim Golden

Python and COM(6)

     by David and Paul Boddie

   ---------- Footnotes ----------

   (1) http://python.net/crew/mhammond/win32/

   (2) http://www.microsoft.com/com/

   (3) http://msdn.microsoft.com/en-us/library/fe1cf721%28VS.80%29.aspx

   (4) 
http://web.archive.org/web/20060524042422/https://www.python.org/windows/pythonwin/

   (5) http://timgolden.me.uk/python/win32_how_do_i.html

   (6) http://www.boddie.org.uk/python/COM.html


File: python.info,  Node: cx_Freeze,  Next: WConio,  Prev: PyWin32,  Up: Additional modules

3.3.5.2 cx_Freeze
.................

cx_Freeze(1) is a *note distutils: 37. extension (see *note Extending
Distutils: b6e.) which wraps Python scripts into executable Windows
programs (‘`*'.exe’ files).  When you have done this, you can distribute
your application without requiring your users to install Python.

   ---------- Footnotes ----------

   (1) http://cx-freeze.sourceforge.net/


File: python.info,  Node: WConio,  Prev: cx_Freeze,  Up: Additional modules

3.3.5.3 WConio
..............

Since Python’s advanced terminal handling layer, *note curses: 2b, is
restricted to Unix-like systems, there is a library exclusive to Windows
as well: Windows Console I/O for Python.

WConio(1) is a wrapper for Turbo-C’s ‘CONIO.H’, used to create text user
interfaces.

   ---------- Footnotes ----------

   (1) http://newcenturycomputers.net/projects/wconio.html


File: python.info,  Node: Compiling Python on Windows,  Next: Other resources,  Prev: Additional modules,  Up: Using Python on Windows

3.3.6 Compiling Python on Windows
---------------------------------

If you want to compile CPython yourself, first thing you should do is
get the source(1).  You can download either the latest release’s source
or just grab a fresh checkout(2).

The source tree contains a build solution and project files for
Microsoft Visual C++, which is the compiler used to build the official
Python releases.  View the ‘readme.txt’ in their respective directories:

Directory                MSVC version       Visual Studio version
                                            
------------------------------------------------------------------------
                                            
‘PC/VS9.0/’              9.0                2008
                                            
                                            
‘PCbuild/’               10.0               2010
                                            

Note that any build directories within the ‘PC’ directory are not
necessarily fully supported.  The ‘PCbuild’ directory contains the files
for the compiler used to build the official release.

Check ‘PCbuild/readme.txt’ for general information on the build process.

For extension modules, consult *note Building C and C++ Extensions on
Windows: b71.

See also
........

Python + Windows + distutils + SWIG + gcc MinGW(3)

     or "Creating Python extensions in C/C++ with SWIG and compiling
     them with MinGW gcc under Windows" or "Installing Python extension
     with distutils and without Microsoft Visual C++" by Sébastien
     Sauvage, 2003

MingW – Python extensions(4)

     by Trent Apted et al, 2007

   ---------- Footnotes ----------

   (1) https://www.python.org/download/source/

   (2) 
https://docs.python.org/devguide/setup.html#getting-the-source-code

   (3) http://sebsauvage.net/python/mingw.html

   (4) http://oldwiki.mingw.org/index.php/Python%20extensions


File: python.info,  Node: Other resources,  Prev: Compiling Python on Windows,  Up: Using Python on Windows

3.3.7 Other resources
---------------------

See also
........

Python Programming On Win32(1)

     "Help for Windows Programmers" by Mark Hammond and Andy Robinson,
     O’Reilly Media, 2000, ISBN 1-56592-621-8

A Python for Windows Tutorial(2)

     by Amanda Birmingham, 2004

PEP 397(3) - Python launcher for Windows

     The proposal for the launcher to be included in the Python
     distribution.

   ---------- Footnotes ----------

   (1) http://shop.oreilly.com/product/9781565926219.do

   (2) http://www.imladris.com/Scripts/PythonForWindows.html

   (3) https://www.python.org/dev/peps/pep-0397


File: python.info,  Node: Using Python on a Macintosh,  Next: Additional Tools and Scripts,  Prev: Using Python on Windows,  Up: Python Setup and Usage

3.4 Using Python on a Macintosh
===============================


Author: Bob Savage <<bobsavage@mac.com>>

Python on a Macintosh running Mac OS X is in principle very similar to
Python on any other Unix platform, but there are a number of additional
features such as the IDE and the Package Manager that are worth pointing
out.

* Menu:

* Getting and Installing MacPython:: 
* The IDE:: 
* Installing Additional Python Packages:: 
* GUI Programming on the Mac:: 
* Distributing Python Applications on the Mac:: 
* Other Resources:: 


File: python.info,  Node: Getting and Installing MacPython,  Next: The IDE,  Up: Using Python on a Macintosh

3.4.1 Getting and Installing MacPython
--------------------------------------

Mac OS X 10.8 comes with Python 2.7 pre-installed by Apple.  If you
wish, you are invited to install the most recent version of Python 3
from the Python website (‘https://www.python.org’).  A current
"universal binary" build of Python, which runs natively on the Mac’s new
Intel and legacy PPC CPU’s, is available there.

What you get after installing is a number of things:

   * A ‘MacPython 3.4’ folder in your ‘Applications’ folder.  In here
     you find IDLE, the development environment that is a standard part
     of official Python distributions; PythonLauncher, which handles
     double-clicking Python scripts from the Finder; and the "Build
     Applet" tool, which allows you to package Python scripts as
     standalone applications on your system.

   * A framework ‘/Library/Frameworks/Python.framework’, which includes
     the Python executable and libraries.  The installer adds this
     location to your shell path.  To uninstall MacPython, you can
     simply remove these three things.  A symlink to the Python
     executable is placed in /usr/local/bin/.

The Apple-provided build of Python is installed in
‘/System/Library/Frameworks/Python.framework’ and ‘/usr/bin/python’,
respectively.  You should never modify or delete these, as they are
Apple-controlled and are used by Apple- or third-party software.
Remember that if you choose to install a newer Python version from
python.org, you will have two different but functional Python
installations on your computer, so it will be important that your paths
and usages are consistent with what you want to do.

IDLE includes a help menu that allows you to access Python
documentation.  If you are completely new to Python you should start
reading the tutorial introduction in that document.

If you are familiar with Python on other Unix platforms you should read
the section on running Python scripts from the Unix shell.

* Menu:

* How to run a Python script:: 
* Running scripts with a GUI:: 
* Configuration:: 


File: python.info,  Node: How to run a Python script,  Next: Running scripts with a GUI,  Up: Getting and Installing MacPython

3.4.1.1 How to run a Python script
..................................

Your best way to get started with Python on Mac OS X is through the IDLE
integrated development environment, see section *note The IDE: b79. and
use the Help menu when the IDE is running.

If you want to run Python scripts from the Terminal window command line
or from the Finder you first need an editor to create your script.  Mac
OS X comes with a number of standard Unix command line editors, ‘vim’
and ‘emacs’ among them.  If you want a more Mac-like editor, ‘BBEdit’ or
‘TextWrangler’ from Bare Bones Software (see
‘http://www.barebones.com/products/bbedit/index.html’) are good choices,
as is ‘TextMate’ (see ‘http://macromates.com/’).  Other editors include
‘Gvim’ (‘http://macvim.org’) and ‘Aquamacs’ (‘http://aquamacs.org/’).

To run your script from the Terminal window you must make sure that
‘/usr/local/bin’ is in your shell search path.

To run your script from the Finder you have two options:

   * Drag it to ‘PythonLauncher’

   * Select ‘PythonLauncher’ as the default application to open your
     script (or any .py script) through the finder Info window and
     double-click it.  ‘PythonLauncher’ has various preferences to
     control how your script is launched.  Option-dragging allows you to
     change these for one invocation, or use its Preferences menu to
     change things globally.


File: python.info,  Node: Running scripts with a GUI,  Next: Configuration,  Prev: How to run a Python script,  Up: Getting and Installing MacPython

3.4.1.2 Running scripts with a GUI
..................................

With older versions of Python, there is one Mac OS X quirk that you need
to be aware of: programs that talk to the Aqua window manager (in other
words, anything that has a GUI) need to be run in a special way.  Use
‘pythonw’ instead of ‘python’ to start such scripts.

With Python 3.4, you can use either ‘python’ or ‘pythonw’.


File: python.info,  Node: Configuration,  Prev: Running scripts with a GUI,  Up: Getting and Installing MacPython

3.4.1.3 Configuration
.....................

Python on OS X honors all standard Unix environment variables such as
*note PYTHONPATH: 30e, but setting these variables for programs started
from the Finder is non-standard as the Finder does not read your
‘.profile’ or ‘.cshrc’ at startup.  You need to create a file ‘~
/.MacOSX/environment.plist’.  See Apple’s Technical Document QA1067 for
details.

For more information on installation Python packages in MacPython, see
section *note Installing Additional Python Packages: b7d.


File: python.info,  Node: The IDE,  Next: Installing Additional Python Packages,  Prev: Getting and Installing MacPython,  Up: Using Python on a Macintosh

3.4.2 The IDE
-------------

MacPython ships with the standard IDLE development environment.  A good
introduction to using IDLE can be found at
‘https://hkn.eecs.berkeley.edu/~dyoo/python/idle_intro/index.html’.


File: python.info,  Node: Installing Additional Python Packages,  Next: GUI Programming on the Mac,  Prev: The IDE,  Up: Using Python on a Macintosh

3.4.3 Installing Additional Python Packages
-------------------------------------------

There are several methods to install additional Python packages:

   * Packages can be installed via the standard Python distutils mode
     (‘python setup.py install’).

   * Many packages can also be installed via the ‘setuptools’ extension
     or ‘pip’ wrapper, see ‘https://pip.pypa.io/’.


File: python.info,  Node: GUI Programming on the Mac,  Next: Distributing Python Applications on the Mac,  Prev: Installing Additional Python Packages,  Up: Using Python on a Macintosh

3.4.4 GUI Programming on the Mac
--------------------------------

There are several options for building GUI applications on the Mac with
Python.

`PyObjC' is a Python binding to Apple’s Objective-C/Cocoa framework,
which is the foundation of most modern Mac development.  Information on
PyObjC is available from ‘https://pythonhosted.org/pyobjc/’.

The standard Python GUI toolkit is *note tkinter: 106, based on the
cross-platform Tk toolkit (‘http://www.tcl.tk’).  An Aqua-native version
of Tk is bundled with OS X by Apple, and the latest version can be
downloaded and installed from ‘http://www.activestate.com’; it can also
be built from source.

`wxPython' is another popular cross-platform GUI toolkit that runs
natively on Mac OS X. Packages and documentation are available from
‘http://www.wxpython.org’.

`PyQt' is another popular cross-platform GUI toolkit that runs natively
on Mac OS X. More information can be found at
‘http://www.riverbankcomputing.co.uk/software/pyqt/intro’.


File: python.info,  Node: Distributing Python Applications on the Mac,  Next: Other Resources,  Prev: GUI Programming on the Mac,  Up: Using Python on a Macintosh

3.4.5 Distributing Python Applications on the Mac
-------------------------------------------------

The "Build Applet" tool that is placed in the MacPython 3.4 folder is
fine for packaging small Python scripts on your own machine to run as a
standard Mac application.  This tool, however, is not robust enough to
distribute Python applications to other users.

The standard tool for deploying standalone Python applications on the
Mac is ‘py2app’.  More information on installing and using py2app can be
found at ‘http://undefined.org/python/#py2app’.


File: python.info,  Node: Other Resources,  Prev: Distributing Python Applications on the Mac,  Up: Using Python on a Macintosh

3.4.6 Other Resources
---------------------

The MacPython mailing list is an excellent support resource for Python
users and developers on the Mac:

‘https://www.python.org/community/sigs/current/pythonmac-sig/’

Another useful resource is the MacPython wiki:

‘https://wiki.python.org/moin/MacPython’


File: python.info,  Node: Additional Tools and Scripts,  Prev: Using Python on a Macintosh,  Up: Python Setup and Usage

3.5 Additional Tools and Scripts
================================

* Menu:

* pyvenv - Creating virtual environments:: 


File: python.info,  Node: pyvenv - Creating virtual environments,  Up: Additional Tools and Scripts

3.5.1 pyvenv - Creating virtual environments
--------------------------------------------

Creation of *note virtual environments: b87. is done by executing the
‘pyvenv’ script:

     pyvenv /path/to/new/virtual/environment

Running this command creates the target directory (creating any parent
directories that don’t exist already) and places a ‘pyvenv.cfg’ file in
it with a ‘home’ key pointing to the Python installation the command was
run from.  It also creates a ‘bin’ (or ‘Scripts’ on Windows)
subdirectory containing a copy of the ‘python’ binary (or binaries, in
the case of Windows).  It also creates an (initially empty)
‘lib/pythonX.Y/site-packages’ subdirectory (on Windows, this is
‘Lib\site-packages’).

See also
........

Python Packaging User Guide: Creating and using virtual environments(1)

On Windows, you may have to invoke the ‘pyvenv’ script as follows, if
you don’t have the relevant PATH and PATHEXT settings:

     c:\Temp>c:\Python34\python c:\Python34\Tools\Scripts\pyvenv.py myenv

or equivalently:

     c:\Temp>c:\Python34\python -m venv myenv

The command, if run with ‘-h’, will show the available options:

     usage: venv [-h] [--system-site-packages] [--symlinks] [--clear]
                 [--upgrade] [--without-pip] ENV_DIR [ENV_DIR ...]

     Creates virtual Python environments in one or more target directories.

     positional arguments:
       ENV_DIR             A directory to create the environment in.

     optional arguments:
       -h, --help             show this help message and exit
       --system-site-packages Give access to the global site-packages dir to the
                              virtual environment.
       --symlinks             Try to use symlinks rather than copies, when symlinks
                              are not the default for the platform.
       --copies               Try to use copies rather than symlinks, even when
                              symlinks are the default for the platform.
       --clear                Delete the environment directory if it already exists.
                              If not specified and the directory exists, an error is
                              raised.
       --upgrade              Upgrade the environment directory to use this version
                              of Python, assuming Python has been upgraded in-place.
       --without-pip          Skips installing or upgrading pip in the virtual
                              environment (pip is bootstrapped by default)

Depending on how the ‘venv’ functionality has been invoked, the usage
message may vary slightly, e.g.  referencing ‘pyvenv’ rather than
‘venv’.

Changed in version 3.4: Installs pip by default, added the
‘--without-pip’ and ‘--copies’ options

Changed in version 3.4: In earlier versions, if the target directory
already existed, an error was raised, unless the ‘--clear’ or
‘--upgrade’ option was provided.  Now, if an existing directory is
specified, its contents are removed and the directory is processed as if
it had been newly created.

The created ‘pyvenv.cfg’ file also includes the
‘include-system-site-packages’ key, set to ‘true’ if ‘venv’ is run with
the ‘--system-site-packages’ option, ‘false’ otherwise.

Unless the ‘--without-pip’ option is given, *note ensurepip: 78. will be
invoked to bootstrap ‘pip’ into the virtual environment.

Multiple paths can be given to ‘pyvenv’, in which case an identical
virtualenv will be created, according to the given options, at each
provided path.

Once a venv has been created, it can be "activated" using a script in
the venv’s binary directory.  The invocation of the script is
platform-specific:

Platform          Shell                 Command to activate virtual environment
                                        
--------------------------------------------------------------------------------------
                                        
Posix             bash/zsh              $ source <venv>/bin/activate
                                        
                                        
                  fish                  $ .  <venv>/bin/activate.fish
                                        
                                        
                  csh/tcsh              $ source <venv>/bin/activate.csh
                                        
                                        
Windows           cmd.exe               C:> <venv>/Scripts/activate.bat
                                        
                                        
                  PowerShell            PS C:> <venv>/Scripts/Activate.ps1
                                        

You don’t specifically `need' to activate an environment; activation
just prepends the venv’s binary directory to your path, so that "python"
invokes the venv’s Python interpreter and you can run installed scripts
without having to use their full path.  However, all scripts installed
in a venv should be runnable without activating it, and run with the
venv’s Python automatically.

You can deactivate a venv by typing "deactivate" in your shell.  The
exact mechanism is platform-specific: for example, the Bash activation
script defines a "deactivate" function, whereas on Windows there are
separate scripts called ‘deactivate.bat’ and ‘Deactivate.ps1’ which are
installed when the venv is created.

New in version 3.4: ‘fish’ and ‘csh’ activation scripts.

   ---------- Footnotes ----------

   (1) 
https://packaging.python.org/en/latest/installing.html#virtual-environments


File: python.info,  Node: The Python Language Reference,  Next: The Python Standard Library,  Prev: Python Setup and Usage,  Up: Top

4 The Python Language Reference
*******************************

This reference manual describes the syntax and "core semantics" of the
language.  It is terse, but attempts to be exact and complete.  The
semantics of non-essential built-in object types and of the built-in
functions and modules are described in *note The Python Standard
Library: 9f1.  For an informal introduction to the language, see *note
The Python Tutorial: 9f0.  For C or C++ programmers, two additional
manuals exist: *note Extending and Embedding the Python Interpreter:
9f3. describes the high-level picture of how to write a Python extension
module, and the *note Python/C API Reference Manual: 9f4. describes the
interfaces available to C/C++ programmers in detail.

* Menu:

* Introduction: Introduction<4>. 
* Lexical analysis:: 
* Data model:: 
* Execution model:: 
* The import system:: 
* Expressions:: 
* Simple statements:: 
* Compound statements:: 
* Top-level components:: 
* Full Grammar specification:: 


File: python.info,  Node: Introduction<4>,  Next: Lexical analysis,  Up: The Python Language Reference

4.1 Introduction
================

This reference manual describes the Python programming language.  It is
not intended as a tutorial.

While I am trying to be as precise as possible, I chose to use English
rather than formal specifications for everything except syntax and
lexical analysis.  This should make the document more understandable to
the average reader, but will leave room for ambiguities.  Consequently,
if you were coming from Mars and tried to re-implement Python from this
document alone, you might have to guess things and in fact you would
probably end up implementing quite a different language.  On the other
hand, if you are using Python and wonder what the precise rules about a
particular area of the language are, you should definitely be able to
find them here.  If you would like to see a more formal definition of
the language, maybe you could volunteer your time — or invent a cloning
machine :-).

It is dangerous to add too many implementation details to a language
reference document — the implementation may change, and other
implementations of the same language may work differently.  On the other
hand, CPython is the one Python implementation in widespread use
(although alternate implementations continue to gain support), and its
particular quirks are sometimes worth being mentioned, especially where
the implementation imposes additional limitations.  Therefore, you’ll
find short "implementation notes" sprinkled throughout the text.

Every Python implementation comes with a number of built-in and standard
modules.  These are documented in *note The Python Standard Library:
9f1.  A few built-in modules are mentioned when they interact in a
significant way with the language definition.

* Menu:

* Alternate Implementations:: 
* Notation:: 


File: python.info,  Node: Alternate Implementations,  Next: Notation,  Up: Introduction<4>

4.1.1 Alternate Implementations
-------------------------------

Though there is one Python implementation which is by far the most
popular, there are some alternate implementations which are of
particular interest to different audiences.

Known implementations include:

CPython

     This is the original and most-maintained implementation of Python,
     written in C. New language features generally appear here first.

Jython

     Python implemented in Java.  This implementation can be used as a
     scripting language for Java applications, or can be used to create
     applications using the Java class libraries.  It is also often used
     to create tests for Java libraries.  More information can be found
     at the Jython website(1).

Python for .NET

     This implementation actually uses the CPython implementation, but
     is a managed .NET application and makes .NET libraries available.
     It was created by Brian Lloyd.  For more information, see the
     Python for .NET home page(2).

IronPython

     An alternate Python for .NET. Unlike Python.NET, this is a complete
     Python implementation that generates IL, and compiles Python code
     directly to .NET assemblies.  It was created by Jim Hugunin, the
     original creator of Jython.  For more information, see the
     IronPython website(3).

PyPy

     An implementation of Python written completely in Python.  It
     supports several advanced features not found in other
     implementations like stackless support and a Just in Time compiler.
     One of the goals of the project is to encourage experimentation
     with the language itself by making it easier to modify the
     interpreter (since it is written in Python).  Additional
     information is available on the PyPy project’s home page(4).

Each of these implementations varies in some way from the language as
documented in this manual, or introduces specific information beyond
what’s covered in the standard Python documentation.  Please refer to
the implementation-specific documentation to determine what else you
need to know about the specific implementation you’re using.

   ---------- Footnotes ----------

   (1) http://www.jython.org/

   (2) http://pythonnet.sourceforge.net

   (3) http://ironpython.net/

   (4) http://pypy.org/


File: python.info,  Node: Notation,  Prev: Alternate Implementations,  Up: Introduction<4>

4.1.2 Notation
--------------

The descriptions of lexical analysis and syntax use a modified BNF
grammar notation.  This uses the following style of definition:

     name      ::= lc_letter (lc_letter | "_")*
     lc_letter ::= "a"..."z"

The first line says that a ‘name’ is an ‘lc_letter’ followed by a
sequence of zero or more ‘lc_letter’s and underscores.  An ‘lc_letter’
in turn is any of the single characters ‘'a'’ through ‘'z'’.  (This rule
is actually adhered to for the names defined in lexical and grammar
rules in this document.)

Each rule begins with a name (which is the name defined by the rule) and
‘::=’.  A vertical bar (‘|’) is used to separate alternatives; it is the
least binding operator in this notation.  A star (‘*’) means zero or
more repetitions of the preceding item; likewise, a plus (‘+’) means one
or more repetitions, and a phrase enclosed in square brackets (‘[ ]’)
means zero or one occurrences (in other words, the enclosed phrase is
optional).  The ‘*’ and ‘+’ operators bind as tightly as possible;
parentheses are used for grouping.  Literal strings are enclosed in
quotes.  White space is only meaningful to separate tokens.  Rules are
normally contained on a single line; rules with many alternatives may be
formatted alternatively with each line after the first beginning with a
vertical bar.

In lexical definitions (as the example above), two more conventions are
used: Two literal characters separated by three dots mean a choice of
any single character in the given (inclusive) range of ASCII characters.
A phrase between angular brackets (‘<...>’) gives an informal
description of the symbol defined; e.g., this could be used to describe
the notion of ’control character’ if needed.

Even though the notation used is almost the same, there is a big
difference between the meaning of lexical and syntactic definitions: a
lexical definition operates on the individual characters of the input
source, while a syntax definition operates on the stream of tokens
generated by the lexical analysis.  All uses of BNF in the next chapter
("Lexical Analysis") are lexical definitions; uses in subsequent
chapters are syntactic definitions.


File: python.info,  Node: Lexical analysis,  Next: Data model,  Prev: Introduction<4>,  Up: The Python Language Reference

4.2 Lexical analysis
====================

A Python program is read by a `parser'.  Input to the parser is a stream
of `tokens', generated by the `lexical analyzer'.  This chapter
describes how the lexical analyzer breaks a file into tokens.

Python reads program text as Unicode code points; the encoding of a
source file can be given by an encoding declaration and defaults to
UTF-8, see PEP 3120(1) for details.  If the source file cannot be
decoded, a *note SyntaxError: 319. is raised.

* Menu:

* Line structure:: 
* Other tokens:: 
* Identifiers and keywords:: 
* Literals:: 
* Operators:: 
* Delimiters:: 

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-3120


File: python.info,  Node: Line structure,  Next: Other tokens,  Up: Lexical analysis

4.2.1 Line structure
--------------------

A Python program is divided into a number of `logical lines'.

* Menu:

* Logical lines:: 
* Physical lines:: 
* Comments:: 
* Encoding declarations:: 
* Explicit line joining:: 
* Implicit line joining:: 
* Blank lines:: 
* Indentation:: 
* Whitespace between tokens:: 


File: python.info,  Node: Logical lines,  Next: Physical lines,  Up: Line structure

4.2.1.1 Logical lines
.....................

The end of a logical line is represented by the token NEWLINE.
Statements cannot cross logical line boundaries except where NEWLINE is
allowed by the syntax (e.g., between statements in compound statements).
A logical line is constructed from one or more `physical lines' by
following the explicit or implicit `line joining' rules.


File: python.info,  Node: Physical lines,  Next: Comments,  Prev: Logical lines,  Up: Line structure

4.2.1.2 Physical lines
......................

A physical line is a sequence of characters terminated by an end-of-line
sequence.  In source files, any of the standard platform line
termination sequences can be used - the Unix form using ASCII LF
(linefeed), the Windows form using the ASCII sequence CR LF (return
followed by linefeed), or the old Macintosh form using the ASCII CR
(return) character.  All of these forms can be used equally, regardless
of platform.

When embedding Python, source code strings should be passed to Python
APIs using the standard C conventions for newline characters (the ‘\n’
character, representing ASCII LF, is the line terminator).


File: python.info,  Node: Comments,  Next: Encoding declarations,  Prev: Physical lines,  Up: Line structure

4.2.1.3 Comments
................

A comment starts with a hash character (‘#’) that is not part of a
string literal, and ends at the end of the physical line.  A comment
signifies the end of the logical line unless the implicit line joining
rules are invoked.  Comments are ignored by the syntax; they are not
tokens.


File: python.info,  Node: Encoding declarations,  Next: Explicit line joining,  Prev: Comments,  Up: Line structure

4.2.1.4 Encoding declarations
.............................

If a comment in the first or second line of the Python script matches
the regular expression ‘coding[=:]\s*([-\w.]+)’, this comment is
processed as an encoding declaration; the first group of this expression
names the encoding of the source code file.  The recommended forms of
this expression are

     # -*- coding: <encoding-name> -*-

which is recognized also by GNU Emacs, and

     # vim:fileencoding=<encoding-name>

which is recognized by Bram Moolenaar’s VIM.

If no encoding declaration is found, the default encoding is UTF-8.  In
addition, if the first bytes of the file are the UTF-8 byte-order mark
(‘b'\xef\xbb\xbf'’), the declared file encoding is UTF-8 (this is
supported, among others, by Microsoft’s ‘notepad’).

If an encoding is declared, the encoding name must be recognized by
Python.  The encoding is used for all lexical analysis, including string
literals, comments and identifiers.  The encoding declaration must
appear on a line of its own.


File: python.info,  Node: Explicit line joining,  Next: Implicit line joining,  Prev: Encoding declarations,  Up: Line structure

4.2.1.5 Explicit line joining
.............................

Two or more physical lines may be joined into logical lines using
backslash characters (‘\’), as follows: when a physical line ends in a
backslash that is not part of a string literal or comment, it is joined
with the following forming a single logical line, deleting the backslash
and the following end-of-line character.  For example:

     if 1900 < year < 2100 and 1 <= month <= 12 \
        and 1 <= day <= 31 and 0 <= hour < 24 \
        and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a valid date
             return 1

A line ending in a backslash cannot carry a comment.  A backslash does
not continue a comment.  A backslash does not continue a token except
for string literals (i.e., tokens other than string literals cannot be
split across physical lines using a backslash).  A backslash is illegal
elsewhere on a line outside a string literal.


File: python.info,  Node: Implicit line joining,  Next: Blank lines,  Prev: Explicit line joining,  Up: Line structure

4.2.1.6 Implicit line joining
.............................

Expressions in parentheses, square brackets or curly braces can be split
over more than one physical line without using backslashes.  For
example:

     month_names = ['Januari', 'Februari', 'Maart',      # These are the
                    'April',   'Mei',      'Juni',       # Dutch names
                    'Juli',    'Augustus', 'September',  # for the months
                    'Oktober', 'November', 'December']   # of the year

Implicitly continued lines can carry comments.  The indentation of the
continuation lines is not important.  Blank continuation lines are
allowed.  There is no NEWLINE token between implicit continuation lines.
Implicitly continued lines can also occur within triple-quoted strings
(see below); in that case they cannot carry comments.


File: python.info,  Node: Blank lines,  Next: Indentation,  Prev: Implicit line joining,  Up: Line structure

4.2.1.7 Blank lines
...................

A logical line that contains only spaces, tabs, formfeeds and possibly a
comment, is ignored (i.e., no NEWLINE token is generated).  During
interactive input of statements, handling of a blank line may differ
depending on the implementation of the read-eval-print loop.  In the
standard interactive interpreter, an entirely blank logical line (i.e.
one containing not even whitespace or a comment) terminates a multi-line
statement.


File: python.info,  Node: Indentation,  Next: Whitespace between tokens,  Prev: Blank lines,  Up: Line structure

4.2.1.8 Indentation
...................

Leading whitespace (spaces and tabs) at the beginning of a logical line
is used to compute the indentation level of the line, which in turn is
used to determine the grouping of statements.

Tabs are replaced (from left to right) by one to eight spaces such that
the total number of characters up to and including the replacement is a
multiple of eight (this is intended to be the same rule as used by
Unix).  The total number of spaces preceding the first non-blank
character then determines the line’s indentation.  Indentation cannot be
split over multiple physical lines using backslashes; the whitespace up
to the first backslash determines the indentation.

Indentation is rejected as inconsistent if a source file mixes tabs and
spaces in a way that makes the meaning dependent on the worth of a tab
in spaces; a *note TabError: 90a. is raised in that case.

`Cross-platform compatibility note:' because of the nature of text
editors on non-UNIX platforms, it is unwise to use a mixture of spaces
and tabs for the indentation in a single source file.  It should also be
noted that different platforms may explicitly limit the maximum
indentation level.

A formfeed character may be present at the start of the line; it will be
ignored for the indentation calculations above.  Formfeed characters
occurring elsewhere in the leading whitespace have an undefined effect
(for instance, they may reset the space count to zero).

The indentation levels of consecutive lines are used to generate INDENT
and DEDENT tokens, using a stack, as follows.

Before the first line of the file is read, a single zero is pushed on
the stack; this will never be popped off again.  The numbers pushed on
the stack will always be strictly increasing from bottom to top.  At the
beginning of each logical line, the line’s indentation level is compared
to the top of the stack.  If it is equal, nothing happens.  If it is
larger, it is pushed on the stack, and one INDENT token is generated.
If it is smaller, it `must' be one of the numbers occurring on the
stack; all numbers on the stack that are larger are popped off, and for
each number popped off a DEDENT token is generated.  At the end of the
file, a DEDENT token is generated for each number remaining on the stack
that is larger than zero.

Here is an example of a correctly (though confusingly) indented piece of
Python code:

     def perm(l):
             # Compute the list of all permutations of l
         if len(l) <= 1:
                       return [l]
         r = []
         for i in range(len(l)):
                  s = l[:i] + l[i+1:]
                  p = perm(s)
                  for x in p:
                   r.append(l[i:i+1] + x)
         return r

The following example shows various indentation errors:

      def perm(l):                       # error: first line indented
     for i in range(len(l)):             # error: not indented
         s = l[:i] + l[i+1:]
             p = perm(l[:i] + l[i+1:])   # error: unexpected indent
             for x in p:
                     r.append(l[i:i+1] + x)
                 return r                # error: inconsistent dedent

(Actually, the first three errors are detected by the parser; only the
last error is found by the lexical analyzer — the indentation of ‘return
r’ does not match a level popped off the stack.)


File: python.info,  Node: Whitespace between tokens,  Prev: Indentation,  Up: Line structure

4.2.1.9 Whitespace between tokens
.................................

Except at the beginning of a logical line or in string literals, the
whitespace characters space, tab and formfeed can be used
interchangeably to separate tokens.  Whitespace is needed between two
tokens only if their concatenation could otherwise be interpreted as a
different token (e.g., ab is one token, but a b is two tokens).


File: python.info,  Node: Other tokens,  Next: Identifiers and keywords,  Prev: Line structure,  Up: Lexical analysis

4.2.2 Other tokens
------------------

Besides NEWLINE, INDENT and DEDENT, the following categories of tokens
exist: `identifiers', `keywords', `literals', `operators', and
`delimiters'.  Whitespace characters (other than line terminators,
discussed earlier) are not tokens, but serve to delimit tokens.  Where
ambiguity exists, a token comprises the longest possible string that
forms a legal token, when read from left to right.


File: python.info,  Node: Identifiers and keywords,  Next: Literals,  Prev: Other tokens,  Up: Lexical analysis

4.2.3 Identifiers and keywords
------------------------------

Identifiers (also referred to as `names') are described by the following
lexical definitions.

The syntax of identifiers in Python is based on the Unicode standard
annex UAX-31, with elaboration and changes as defined below; see also
PEP 3131(1) for further details.

Within the ASCII range (U+0001..U+007F), the valid characters for
identifiers are the same as in Python 2.x: the uppercase and lowercase
letters ‘A’ through ‘Z’, the underscore ‘_’ and, except for the first
character, the digits ‘0’ through ‘9’.

Python 3.0 introduces additional characters from outside the ASCII range
(see PEP 3131(2)).  For these characters, the classification uses the
version of the Unicode Character Database as included in the *note
unicodedata: 113. module.

Identifiers are unlimited in length.  Case is significant.

     identifier   ::= xid_start xid_continue*
     id_start     ::= <all characters in general categories Lu, Ll, Lt, Lm, Lo, Nl, the underscore, and characters with the Other_ID_Start property>
     id_continue  ::= <all characters in id_start, plus characters in the categories Mn, Mc, Nd, Pc and others with the Other_ID_Continue property>
     xid_start    ::= <all characters in id_start whose NFKC normalization is in "id_start xid_continue*">
     xid_continue ::= <all characters in id_continue whose NFKC normalization is in "id_continue*">

The Unicode category codes mentioned above stand for:

   * `Lu' - uppercase letters

   * `Ll' - lowercase letters

   * `Lt' - titlecase letters

   * `Lm' - modifier letters

   * `Lo' - other letters

   * `Nl' - letter numbers

   * `Mn' - nonspacing marks

   * `Mc' - spacing combining marks

   * `Nd' - decimal numbers

   * `Pc' - connector punctuations

   * `Other_ID_Start' - explicit list of characters in PropList.txt(3)
     to support backwards compatibility

   * `Other_ID_Continue' - likewise

All identifiers are converted into the normal form NFKC while parsing;
comparison of identifiers is based on NFKC.

A non-normative HTML file listing all valid identifier characters for
Unicode 4.1 can be found at
‘http://www.dcl.hpi.uni-potsdam.de/home/loewis/table-3131.html’.

* Menu:

* Keywords:: 
* Reserved classes of identifiers:: 

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-3131

   (2) https://www.python.org/dev/peps/pep-3131

   (3) http://www.unicode.org/Public/6.3.0/ucd/PropList.txt


File: python.info,  Node: Keywords,  Next: Reserved classes of identifiers,  Up: Identifiers and keywords

4.2.3.1 Keywords
................

The following identifiers are used as reserved words, or `keywords' of
the language, and cannot be used as ordinary identifiers.  They must be
spelled exactly as written here:

     False      class      finally    is         return
     None       continue   for        lambda     try
     True       def        from       nonlocal   while
     and        del        global     not        with
     as         elif       if         or         yield
     assert     else       import     pass
     break      except     in         raise


File: python.info,  Node: Reserved classes of identifiers,  Prev: Keywords,  Up: Identifiers and keywords

4.2.3.2 Reserved classes of identifiers
.......................................

Certain classes of identifiers (besides keywords) have special meanings.
These classes are identified by the patterns of leading and trailing
underscore characters:

‘_*’

     Not imported by ‘from module import *’.  The special identifier ‘_’
     is used in the interactive interpreter to store the result of the
     last evaluation; it is stored in the *note builtins: 13. module.
     When not in interactive mode, ‘_’ has no special meaning and is not
     defined.  See section *note The import statement: 674.

          Note: The name ‘_’ is often used in conjunction with
          internationalization; refer to the documentation for the *note
          gettext: 88. module for more information on this convention.

‘__*__’

     System-defined names.  These names are defined by the interpreter
     and its implementation (including the standard library).  Current
     system names are discussed in the *note Special method names: bb6.
     section and elsewhere.  More will likely be defined in future
     versions of Python.  `Any' use of ‘__*__’ names, in any context,
     that does not follow explicitly documented use, is subject to
     breakage without warning.

‘__*’

     Class-private names.  Names in this category, when used within the
     context of a class definition, are re-written to use a mangled form
     to help avoid name clashes between "private" attributes of base and
     derived classes.  See section *note Identifiers (Names): bb7.


File: python.info,  Node: Literals,  Next: Operators,  Prev: Identifiers and keywords,  Up: Lexical analysis

4.2.4 Literals
--------------

Literals are notations for constant values of some built-in types.

* Menu:

* String and Bytes literals:: 
* String literal concatenation:: 
* Numeric literals:: 
* Integer literals:: 
* Floating point literals:: 
* Imaginary literals:: 


File: python.info,  Node: String and Bytes literals,  Next: String literal concatenation,  Up: Literals

4.2.4.1 String and Bytes literals
.................................

String literals are described by the following lexical definitions:

     stringliteral   ::= [stringprefix](shortstring | longstring)
     stringprefix    ::= "r" | "u" | "R" | "U"
     shortstring     ::= "'" shortstringitem* "'" | '"' shortstringitem* '"'
     longstring      ::= "'''" longstringitem* "'''" | '"""' longstringitem* '"""'
     shortstringitem ::= shortstringchar | stringescapeseq
     longstringitem  ::= longstringchar | stringescapeseq
     shortstringchar ::= <any source character except "\" or newline or the quote>
     longstringchar  ::= <any source character except "\">
     stringescapeseq ::= "\" <any source character>

     bytesliteral   ::= bytesprefix(shortbytes | longbytes)
     bytesprefix    ::= "b" | "B" | "br" | "Br" | "bR" | "BR" | "rb" | "rB" | "Rb" | "RB"
     shortbytes     ::= "'" shortbytesitem* "'" | '"' shortbytesitem* '"'
     longbytes      ::= "'''" longbytesitem* "'''" | '"""' longbytesitem* '"""'
     shortbytesitem ::= shortbyteschar | bytesescapeseq
     longbytesitem  ::= longbyteschar | bytesescapeseq
     shortbyteschar ::= <any ASCII character except "\" or newline or the quote>
     longbyteschar  ::= <any ASCII character except "\">
     bytesescapeseq ::= "\" <any ASCII character>

One syntactic restriction not indicated by these productions is that
whitespace is not allowed between the *note stringprefix: bbd. or *note
bytesprefix: bc6. and the rest of the literal.  The source character set
is defined by the encoding declaration; it is UTF-8 if no encoding
declaration is given in the source file; see section *note Encoding
declarations: b9d.

In plain English: Both types of literals can be enclosed in matching
single quotes (‘'’) or double quotes (‘"’).  They can also be enclosed
in matching groups of three single or double quotes (these are generally
referred to as `triple-quoted strings').  The backslash (‘\’) character
is used to escape characters that otherwise have a special meaning, such
as newline, backslash itself, or the quote character.

Bytes literals are always prefixed with ‘'b'’ or ‘'B'’; they produce an
instance of the *note bytes: 179. type instead of the *note str: 178.
type.  They may only contain ASCII characters; bytes with a numeric
value of 128 or greater must be expressed with escapes.

As of Python 3.3 it is possible again to prefix string literals with a
‘u’ prefix to simplify maintenance of dual 2.x and 3.x codebases.

Both string and bytes literals may optionally be prefixed with a letter
‘'r'’ or ‘'R'’; such strings are called `raw strings' and treat
backslashes as literal characters.  As a result, in string literals,
‘'\U'’ and ‘'\u'’ escapes in raw strings are not treated specially.
Given that Python 2.x’s raw unicode literals behave differently than
Python 3.x’s the ‘'ur'’ syntax is not supported.

New in version 3.3: The ‘'rb'’ prefix of raw bytes literals has been
added as a synonym of ‘'br'’.

New in version 3.3: Support for the unicode legacy literal (‘u'value'’)
was reintroduced to simplify the maintenance of dual Python 2.x and 3.x
codebases.  See PEP 414(1) for more information.

In triple-quoted literals, unescaped newlines and quotes are allowed
(and are retained), except that three unescaped quotes in a row
terminate the literal.  (A "quote" is the character used to open the
literal, i.e.  either ‘'’ or ‘"’.)

Unless an ‘'r'’ or ‘'R'’ prefix is present, escape sequences in string
and bytes literals are interpreted according to rules similar to those
used by Standard C. The recognized escape sequences are:

Escape Sequence       Meaning                               Notes
                                                            
------------------------------------------------------------------------
                                                            
‘\newline’            Backslash and newline ignored
                      
                                                            
‘\\’                  Backslash (‘\’)
                      
                                                            
‘\'’                  Single quote (‘'’)
                      
                                                            
‘\"’                  Double quote (‘"’)
                      
                                                            
‘\a’                  ASCII Bell (BEL)
                      
                                                            
‘\b’                  ASCII Backspace (BS)
                      
                                                            
‘\f’                  ASCII Formfeed (FF)
                      
                                                            
‘\n’                  ASCII Linefeed (LF)
                      
                                                            
‘\r’                  ASCII Carriage Return (CR)
                      
                                                            
‘\t’                  ASCII Horizontal Tab (TAB)
                      
                                                            
‘\v’                  ASCII Vertical Tab (VT)
                      
                                                            
‘\ooo’                Character with octal value `ooo'      (1,3)
                                                            
                                                            
‘\xhh’                Character with hex value `hh'         (2,3)
                                                            

Escape sequences only recognized in string literals are:

Escape Sequence       Meaning                               Notes
                                                            
------------------------------------------------------------------------
                                                            
‘\N{name}’            Character named `name' in the         (4)
                      Unicode database                      
                      
                                                            
‘\uxxxx’              Character with 16-bit hex value       (5)
                      `xxxx'                                
                      
                                                            
‘\Uxxxxxxxx’          Character with 32-bit hex value       (6)
                      `xxxxxxxx'                            
                      

Notes:

  1. As in Standard C, up to three octal digits are accepted.

  2. Unlike in Standard C, exactly two hex digits are required.

  3. In a bytes literal, hexadecimal and octal escapes denote the byte
     with the given value.  In a string literal, these escapes denote a
     Unicode character with the given value.

  4. 
     Changed in version 3.3: Support for name aliases (2) has been
     added.

  5. Individual code units which form parts of a surrogate pair can be
     encoded using this escape sequence.  Exactly four hex digits are
     required.

  6. Any Unicode character can be encoded this way.  Exactly eight hex
     digits are required.

Unlike Standard C, all unrecognized escape sequences are left in the
string unchanged, i.e., `the backslash is left in the result'.  (This
behavior is useful when debugging: if an escape sequence is mistyped,
the resulting output is more easily recognized as broken.)  It is also
important to note that the escape sequences only recognized in string
literals fall into the category of unrecognized escapes for bytes
literals.

Even in a raw literal, quotes can be escaped with a backslash, but the
backslash remains in the result; for example, ‘r"\""’ is a valid string
literal consisting of two characters: a backslash and a double quote;
‘r"\"’ is not a valid string literal (even a raw string cannot end in an
odd number of backslashes).  Specifically, `a raw literal cannot end in
a single backslash' (since the backslash would escape the following
quote character).  Note also that a single backslash followed by a
newline is interpreted as those two characters as part of the literal,
`not' as a line continuation.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0414

   (2) ‘http://www.unicode.org/Public/6.3.0/ucd/NameAliases.txt’


File: python.info,  Node: String literal concatenation,  Next: Numeric literals,  Prev: String and Bytes literals,  Up: Literals

4.2.4.2 String literal concatenation
....................................

Multiple adjacent string or bytes literals (delimited by whitespace),
possibly using different quoting conventions, are allowed, and their
meaning is the same as their concatenation.  Thus, ‘"hello" 'world'’ is
equivalent to ‘"helloworld"’.  This feature can be used to reduce the
number of backslashes needed, to split long strings conveniently across
long lines, or even to add comments to parts of strings, for example:

     re.compile("[A-Za-z_]"       # letter or underscore
                "[A-Za-z0-9_]*"   # letter, digit or underscore
               )

Note that this feature is defined at the syntactical level, but
implemented at compile time.  The ’+’ operator must be used to
concatenate string expressions at run time.  Also note that literal
concatenation can use different quoting styles for each component (even
mixing raw strings and triple quoted strings).


File: python.info,  Node: Numeric literals,  Next: Integer literals,  Prev: String literal concatenation,  Up: Literals

4.2.4.3 Numeric literals
........................

There are three types of numeric literals: integers, floating point
numbers, and imaginary numbers.  There are no complex literals (complex
numbers can be formed by adding a real number and an imaginary number).

Note that numeric literals do not include a sign; a phrase like ‘-1’ is
actually an expression composed of the unary operator ’‘-’’ and the
literal ‘1’.


File: python.info,  Node: Integer literals,  Next: Floating point literals,  Prev: Numeric literals,  Up: Literals

4.2.4.4 Integer literals
........................

Integer literals are described by the following lexical definitions:

     integer        ::= decimalinteger | octinteger | hexinteger | bininteger
     decimalinteger ::= nonzerodigit digit* | "0"+
     nonzerodigit   ::= "1"..."9"
     digit          ::= "0"..."9"
     octinteger     ::= "0" ("o" | "O") octdigit+
     hexinteger     ::= "0" ("x" | "X") hexdigit+
     bininteger     ::= "0" ("b" | "B") bindigit+
     octdigit       ::= "0"..."7"
     hexdigit       ::= digit | "a"..."f" | "A"..."F"
     bindigit       ::= "0" | "1"

There is no limit for the length of integer literals apart from what can
be stored in available memory.

Note that leading zeros in a non-zero decimal number are not allowed.
This is for disambiguation with C-style octal literals, which Python
used before version 3.0.

Some examples of integer literals:

     7     2147483647                        0o177    0b100110111
     3     79228162514264337593543950336     0o377    0x100000000
           79228162514264337593543950336              0xdeadbeef


File: python.info,  Node: Floating point literals,  Next: Imaginary literals,  Prev: Integer literals,  Up: Literals

4.2.4.5 Floating point literals
...............................

Floating point literals are described by the following lexical
definitions:

     floatnumber   ::= pointfloat | exponentfloat
     pointfloat    ::= [intpart] fraction | intpart "."
     exponentfloat ::= (intpart | pointfloat) exponent
     intpart       ::= digit+
     fraction      ::= "." digit+
     exponent      ::= ("e" | "E") ["+" | "-"] digit+

Note that the integer and exponent parts are always interpreted using
radix 10.  For example, ‘077e010’ is legal, and denotes the same number
as ‘77e10’.  The allowed range of floating point literals is
implementation-dependent.  Some examples of floating point literals:

     3.14    10.    .001    1e100    3.14e-10    0e0

Note that numeric literals do not include a sign; a phrase like ‘-1’ is
actually an expression composed of the unary operator ‘-’ and the
literal ‘1’.


File: python.info,  Node: Imaginary literals,  Prev: Floating point literals,  Up: Literals

4.2.4.6 Imaginary literals
..........................

Imaginary literals are described by the following lexical definitions:

     imagnumber ::= (floatnumber | intpart) ("j" | "J")

An imaginary literal yields a complex number with a real part of 0.0.
Complex numbers are represented as a pair of floating point numbers and
have the same restrictions on their range.  To create a complex number
with a nonzero real part, add a floating point number to it, e.g.,
‘(3+4j)’.  Some examples of imaginary literals:

     3.14j   10.j    10j     .001j   1e100j  3.14e-10j


File: python.info,  Node: Operators,  Next: Delimiters,  Prev: Literals,  Up: Lexical analysis

4.2.5 Operators
---------------

The following tokens are operators:

     +       -       *       **      /       //      %
     <<      >>      &       |       ^       ~
     <       >       <=      >=      ==      !=


File: python.info,  Node: Delimiters,  Prev: Operators,  Up: Lexical analysis

4.2.6 Delimiters
----------------

The following tokens serve as delimiters in the grammar:

     (       )       [       ]       {       }
     ,       :       .       ;       @       =       ->
     +=      -=      *=      /=      //=     %=
     &=      |=      ^=      >>=     <<=     **=

The period can also occur in floating-point and imaginary literals.  A
sequence of three periods has a special meaning as an ellipsis literal.
The second half of the list, the augmented assignment operators, serve
lexically as delimiters, but also perform an operation.

The following printing ASCII characters have special meaning as part of
other tokens or are otherwise significant to the lexical analyzer:

     '       "       #       \

The following printing ASCII characters are not used in Python.  Their
occurrence outside string literals and comments is an unconditional
error:

     $       ?       `


File: python.info,  Node: Data model,  Next: Execution model,  Prev: Lexical analysis,  Up: The Python Language Reference

4.3 Data model
==============

* Menu:

* Objects, values and types: Objects values and types. 
* The standard type hierarchy:: 
* Special method names:: 


File: python.info,  Node: Objects values and types,  Next: The standard type hierarchy,  Up: Data model

4.3.1 Objects, values and types
-------------------------------

`Objects' are Python’s abstraction for data.  All data in a Python
program is represented by objects or by relations between objects.  (In
a sense, and in conformance to Von Neumann’s model of a "stored program
computer," code is also represented by objects.)

Every object has an identity, a type and a value.  An object’s
`identity' never changes once it has been created; you may think of it
as the object’s address in memory.  The ’*note is: bf2.’ operator
compares the identity of two objects; the *note id(): 806. function
returns an integer representing its identity.

`CPython implementation detail:' For CPython, ‘id(x)’ is the memory
address where ‘x’ is stored.

An object’s type determines the operations that the object supports
(e.g., "does it have a length?")  and also defines the possible values
for objects of that type.  The *note type(): 8c1. function returns an
object’s type (which is an object itself).  Like its identity, an
object’s `type' is also unchangeable.  (1)

The `value' of some objects can change.  Objects whose value can change
are said to be `mutable'; objects whose value is unchangeable once they
are created are called `immutable'.  (The value of an immutable
container object that contains a reference to a mutable object can
change when the latter’s value is changed; however the container is
still considered immutable, because the collection of objects it
contains cannot be changed.  So, immutability is not strictly the same
as having an unchangeable value, it is more subtle.)  An object’s
mutability is determined by its type; for instance, numbers, strings and
tuples are immutable, while dictionaries and lists are mutable.

Objects are never explicitly destroyed; however, when they become
unreachable they may be garbage-collected.  An implementation is allowed
to postpone garbage collection or omit it altogether — it is a matter of
implementation quality how garbage collection is implemented, as long as
no objects are collected that are still reachable.

`CPython implementation detail:' CPython currently uses a
reference-counting scheme with (optional) delayed detection of
cyclically linked garbage, which collects most objects as soon as they
become unreachable, but is not guaranteed to collect garbage containing
circular references.  See the documentation of the *note gc: 85. module
for information on controlling the collection of cyclic garbage.  Other
implementations act differently and CPython may change.  Do not depend
on immediate finalization of objects when they become unreachable (so
you should always close files explicitly).

Note that the use of the implementation’s tracing or debugging
facilities may keep objects alive that would normally be collectable.
Also note that catching an exception with a ’*note try: 7ee...*note
except: 563.’ statement may keep objects alive.

Some objects contain references to "external" resources such as open
files or windows.  It is understood that these resources are freed when
the object is garbage-collected, but since garbage collection is not
guaranteed to happen, such objects also provide an explicit way to
release the external resource, usually a ‘close()’ method.  Programs are
strongly recommended to explicitly close such objects.  The ’*note try:
7ee...*note finally: 2c5.’ statement and the ’*note with: 19b.’
statement provide convenient ways to do this.

Some objects contain references to other objects; these are called
`containers'.  Examples of containers are tuples, lists and
dictionaries.  The references are part of a container’s value.  In most
cases, when we talk about the value of a container, we imply the values,
not the identities of the contained objects; however, when we talk about
the mutability of a container, only the identities of the immediately
contained objects are implied.  So, if an immutable container (like a
tuple) contains a reference to a mutable object, its value changes if
that mutable object is changed.

Types affect almost all aspects of object behavior.  Even the importance
of object identity is affected in some sense: for immutable types,
operations that compute new values may actually return a reference to
any existing object with the same type and value, while for mutable
objects this is not allowed.  E.g., after ‘a = 1; b = 1’, ‘a’ and ‘b’
may or may not refer to the same object with the value one, depending on
the implementation, but after ‘c = []; d = []’, ‘c’ and ‘d’ are
guaranteed to refer to two different, unique, newly created empty lists.
(Note that ‘c = d = []’ assigns the same object to both ‘c’ and ‘d’.)

   ---------- Footnotes ----------

   (1) It `is' possible in some cases to change an object’s type, under
certain controlled conditions.  It generally isn’t a good idea though,
since it can lead to some very strange behaviour if it is handled
incorrectly.


File: python.info,  Node: The standard type hierarchy,  Next: Special method names,  Prev: Objects values and types,  Up: Data model

4.3.2 The standard type hierarchy
---------------------------------

Below is a list of the types that are built into Python.  Extension
modules (written in C, Java, or other languages, depending on the
implementation) can define additional types.  Future versions of Python
may add types to the type hierarchy (e.g., rational numbers, efficiently
stored arrays of integers, etc.), although such additions will often be
provided via the standard library instead.

Some of the type descriptions below contain a paragraph listing ’special
attributes.’ These are attributes that provide access to the
implementation and are not intended for general use.  Their definition
may change in the future.

None

     This type has a single value.  There is a single object with this
     value.  This object is accessed through the built-in name ‘None’.
     It is used to signify the absence of a value in many situations,
     e.g., it is returned from functions that don’t explicitly return
     anything.  Its truth value is false.

NotImplemented

     This type has a single value.  There is a single object with this
     value.  This object is accessed through the built-in name
     ‘NotImplemented’.  Numeric methods and rich comparison methods
     should return this value if they do not implement the operation for
     the operands provided.  (The interpreter will then try the
     reflected operation, or some other fallback, depending on the
     operator.)  Its truth value is true.

     See *note Implementing the arithmetic operations: bf5. for more
     details.

Ellipsis

     This type has a single value.  There is a single object with this
     value.  This object is accessed through the literal ‘...’ or the
     built-in name ‘Ellipsis’.  Its truth value is true.

*note numbers.Number: bf6.

     These are created by numeric literals and returned as results by
     arithmetic operators and arithmetic built-in functions.  Numeric
     objects are immutable; once created their value never changes.
     Python numbers are of course strongly related to mathematical
     numbers, but subject to the limitations of numerical representation
     in computers.

     Python distinguishes between integers, floating point numbers, and
     complex numbers:

     *note numbers.Integral: bf7.

          These represent elements from the mathematical set of integers
          (positive and negative).

          There are two types of integers:

          Integers (*note int: 185.)

               These represent numbers in an unlimited range, subject to
               available (virtual) memory only.  For the purpose of
               shift and mask operations, a binary representation is
               assumed, and negative numbers are represented in a
               variant of 2’s complement which gives the illusion of an
               infinite string of sign bits extending to the left.

          Booleans (*note bool: 87a.)

               These represent the truth values False and True.  The two
               objects representing the values ‘False’ and ‘True’ are
               the only Boolean objects.  The Boolean type is a subtype
               of the integer type, and Boolean values behave like the
               values 0 and 1, respectively, in almost all contexts, the
               exception being that when converted to a string, the
               strings ‘"False"’ or ‘"True"’ are returned, respectively.

          The rules for integer representation are intended to give the
          most meaningful interpretation of shift and mask operations
          involving negative integers.

     *note numbers.Real: bf8. (*note float: 327.)

          These represent machine-level double precision floating point
          numbers.  You are at the mercy of the underlying machine
          architecture (and C or Java implementation) for the accepted
          range and handling of overflow.  Python does not support
          single-precision floating point numbers; the savings in
          processor and memory usage that are usually the reason for
          using these are dwarfed by the overhead of using objects in
          Python, so there is no reason to complicate the language with
          two kinds of floating point numbers.

     *note numbers.Complex: bf9. (*note complex: 326.)

          These represent complex numbers as a pair of machine-level
          double precision floating point numbers.  The same caveats
          apply as for floating point numbers.  The real and imaginary
          parts of a complex number ‘z’ can be retrieved through the
          read-only attributes ‘z.real’ and ‘z.imag’.

Sequences

     These represent finite ordered sets indexed by non-negative
     numbers.  The built-in function *note len(): 358. returns the
     number of items of a sequence.  When the length of a sequence is
     `n', the index set contains the numbers 0, 1, ..., `n'-1.  Item `i'
     of sequence `a' is selected by ‘a[i]’.

     Sequences also support slicing: ‘a[i:j]’ selects all items with
     index `k' such that `i' ‘<=’ `k' ‘<’ `j'.  When used as an
     expression, a slice is a sequence of the same type.  This implies
     that the index set is renumbered so that it starts at 0.

     Some sequences also support "extended slicing" with a third "step"
     parameter: ‘a[i:j:k]’ selects all items of `a' with index `x' where
     ‘x = i + n*k’, `n' ‘>=’ ‘0’ and `i' ‘<=’ `x' ‘<’ `j'.

     Sequences are distinguished according to their mutability:

     Immutable sequences

          An object of an immutable sequence type cannot change once it
          is created.  (If the object contains references to other
          objects, these other objects may be mutable and may be
          changed; however, the collection of objects directly
          referenced by an immutable object cannot change.)

          The following types are immutable sequences:

          Strings

               A string is a sequence of values that represent Unicode
               code points.  All the code points in the range ‘U+0000 -
               U+10FFFF’ can be represented in a string.  Python doesn’t
               have a ‘char’ type; instead, every code point in the
               string is represented as a string object with length ‘1’.
               The built-in function *note ord(): bfa. converts a code
               point from its string form to an integer in the range ‘0
               - 10FFFF’; *note chr(): bfb. converts an integer in the
               range ‘0 - 10FFFF’ to the corresponding length ‘1’ string
               object.  *note str.encode(): 690. can be used to convert
               a *note str: 178. to *note bytes: 179. using the given
               text encoding, and *note bytes.decode(): 691. can be used
               to achieve the opposite.

          Tuples

               The items of a tuple are arbitrary Python objects.
               Tuples of two or more items are formed by comma-separated
               lists of expressions.  A tuple of one item (a
               ’singleton’) can be formed by affixing a comma to an
               expression (an expression by itself does not create a
               tuple, since parentheses must be usable for grouping of
               expressions).  An empty tuple can be formed by an empty
               pair of parentheses.

          Bytes

               A bytes object is an immutable array.  The items are
               8-bit bytes, represented by integers in the range 0 <= x
               < 256.  Bytes literals (like ‘b'abc'’) and the built-in
               function *note bytes(): 179. can be used to construct
               bytes objects.  Also, bytes objects can be decoded to
               strings via the *note decode(): 691. method.

     Mutable sequences

          Mutable sequences can be changed after they are created.  The
          subscription and slicing notations can be used as the target
          of assignment and *note del: a5d. (delete) statements.

          There are currently two intrinsic mutable sequence types:

          Lists

               The items of a list are arbitrary Python objects.  Lists
               are formed by placing a comma-separated list of
               expressions in square brackets.  (Note that there are no
               special cases needed to form lists of length 0 or 1.)

          Byte Arrays

               A bytearray object is a mutable array.  They are created
               by the built-in *note bytearray(): 17a. constructor.
               Aside from being mutable (and hence unhashable), byte
               arrays otherwise provide the same interface and
               functionality as immutable bytes objects.

          The extension module *note array: 7. provides an additional
          example of a mutable sequence type, as does the *note
          collections: 1e. module.

Set types

     These represent unordered, finite sets of unique, immutable
     objects.  As such, they cannot be indexed by any subscript.
     However, they can be iterated over, and the built-in function *note
     len(): 358. returns the number of items in a set.  Common uses for
     sets are fast membership testing, removing duplicates from a
     sequence, and computing mathematical operations such as
     intersection, union, difference, and symmetric difference.

     For set elements, the same immutability rules apply as for
     dictionary keys.  Note that numeric types obey the normal rules for
     numeric comparison: if two numbers compare equal (e.g., ‘1’ and
     ‘1.0’), only one of them can be contained in a set.

     There are currently two intrinsic set types:

     Sets

          These represent a mutable set.  They are created by the
          built-in *note set(): 5a4. constructor and can be modified
          afterwards by several methods, such as *note add(): bfc.

     Frozen sets

          These represent an immutable set.  They are created by the
          built-in *note frozenset(): 63c. constructor.  As a frozenset
          is immutable and *note hashable: bfd, it can be used again as
          an element of another set, or as a dictionary key.

Mappings

     These represent finite sets of objects indexed by arbitrary index
     sets.  The subscript notation ‘a[k]’ selects the item indexed by
     ‘k’ from the mapping ‘a’; this can be used in expressions and as
     the target of assignments or *note del: a5d. statements.  The
     built-in function *note len(): 358. returns the number of items in
     a mapping.

     There is currently a single intrinsic mapping type:

     Dictionaries

          These represent finite sets of objects indexed by nearly
          arbitrary values.  The only types of values not acceptable as
          keys are values containing lists or dictionaries or other
          mutable types that are compared by value rather than by object
          identity, the reason being that the efficient implementation
          of dictionaries requires a key’s hash value to remain
          constant.  Numeric types used for keys obey the normal rules
          for numeric comparison: if two numbers compare equal (e.g.,
          ‘1’ and ‘1.0’) then they can be used interchangeably to index
          the same dictionary entry.

          Dictionaries are mutable; they can be created by the ‘{...}’
          notation (see section *note Dictionary displays: bfe.).

          The extension modules *note dbm.ndbm: 33. and *note dbm.gnu:
          32. provide additional examples of mapping types, as does the
          *note collections: 1e. module.

Callable types

     These are the types to which the function call operation (see
     section *note Calls: bff.) can be applied:

     User-defined functions

          A user-defined function object is created by a function
          definition (see section *note Function definitions: a4b.).  It
          should be called with an argument list containing the same
          number of items as the function’s formal parameter list.

          Special attributes:

          Attribute                     Meaning
                                        
          ----------------------------------------------------------------------------------
                                                                            
          ‘__doc__’                     The function’s documentation        Writable
                                        string, or ‘None’ if unavailable;   
                                        not inherited by subclasses
                                        
                                                                            
          *note __name__: 6cb.          The function’s name                 Writable
                                                                            
                                                                            
          ‘__qualname__’                The function’s *note qualified      Writable
                                        name: c00.                          
                                        
                                        New in version 3.3.
                                        
                                                                            
          ‘__module__’                  The name of the module the          Writable
                                        function was defined in, or         
                                        ‘None’ if unavailable.
                                        
                                                                            
          ‘__defaults__’                A tuple containing default          Writable
                                        argument values for those           
                                        arguments that have defaults, or
                                        ‘None’ if no arguments have a
                                        default value
                                        
                                                                            
          ‘__code__’                    The code object representing the    Writable
                                        compiled function body.             
                                        
                                                                            
          ‘__globals__’                 A reference to the dictionary       Read-only
                                        that holds the function’s global    
                                        variables — the global namespace
                                        of the module in which the
                                        function was defined.
                                        
                                                                            
          ‘__dict__’                    The namespace supporting            Writable
                                        arbitrary function attributes.      
                                        
                                                                            
          ‘__closure__’                 ‘None’ or a tuple of cells that     Read-only
                                        contain bindings for the            
                                        function’s free variables.
                                        
                                                                            
          ‘__annotations__’             A dict containing annotations of    Writable
                                        parameters.  The keys of the dict   
                                        are the parameter names, and
                                        ‘'return'’ for the return
                                        annotation, if provided.
                                        
                                                                            
          ‘__kwdefaults__’              A dict containing defaults for      Writable
                                        keyword-only parameters.            
                                        

          Most of the attributes labelled "Writable" check the type of
          the assigned value.

          Function objects also support getting and setting arbitrary
          attributes, which can be used, for example, to attach metadata
          to functions.  Regular attribute dot-notation is used to get
          and set such attributes.  `Note that the current
          implementation only supports function attributes on
          user-defined functions.  Function attributes on built-in
          functions may be supported in the future.'

          Additional information about a function’s definition can be
          retrieved from its code object; see the description of
          internal types below.

     Instance methods

          An instance method object combines a class, a class instance
          and any callable object (normally a user-defined function).

          Special read-only attributes: ‘__self__’ is the class instance
          object, ‘__func__’ is the function object; ‘__doc__’ is the
          method’s documentation (same as ‘__func__.__doc__’); *note
          __name__: 6cb. is the method name (same as
          ‘__func__.__name__’); ‘__module__’ is the name of the module
          the method was defined in, or ‘None’ if unavailable.

          Methods also support accessing (but not setting) the arbitrary
          function attributes on the underlying function object.

          User-defined method objects may be created when getting an
          attribute of a class (perhaps via an instance of that class),
          if that attribute is a user-defined function object or a class
          method object.

          When an instance method object is created by retrieving a
          user-defined function object from a class via one of its
          instances, its ‘__self__’ attribute is the instance, and the
          method object is said to be bound.  The new method’s
          ‘__func__’ attribute is the original function object.

          When a user-defined method object is created by retrieving
          another method object from a class or instance, the behaviour
          is the same as for a function object, except that the
          ‘__func__’ attribute of the new instance is not the original
          method object but its ‘__func__’ attribute.

          When an instance method object is created by retrieving a
          class method object from a class or instance, its ‘__self__’
          attribute is the class itself, and its ‘__func__’ attribute is
          the function object underlying the class method.

          When an instance method object is called, the underlying
          function (‘__func__’) is called, inserting the class instance
          (‘__self__’) in front of the argument list.  For instance,
          when ‘C’ is a class which contains a definition for a function
          ‘f()’, and ‘x’ is an instance of ‘C’, calling ‘x.f(1)’ is
          equivalent to calling ‘C.f(x, 1)’.

          When an instance method object is derived from a class method
          object, the "class instance" stored in ‘__self__’ will
          actually be the class itself, so that calling either ‘x.f(1)’
          or ‘C.f(1)’ is equivalent to calling ‘f(C,1)’ where ‘f’ is the
          underlying function.

          Note that the transformation from function object to instance
          method object happens each time the attribute is retrieved
          from the instance.  In some cases, a fruitful optimization is
          to assign the attribute to a local variable and call that
          local variable.  Also notice that this transformation only
          happens for user-defined functions; other callable objects
          (and all non-callable objects) are retrieved without
          transformation.  It is also important to note that
          user-defined functions which are attributes of a class
          instance are not converted to bound methods; this `only'
          happens when the function is an attribute of the class.

     Generator functions

          A function or method which uses the *note yield: 21b.
          statement (see section *note The yield statement: 21b.) is
          called a `generator function'.  Such a function, when called,
          always returns an iterator object which can be used to execute
          the body of the function: calling the iterator’s *note
          iterator.__next__(): 6c7. method will cause the function to
          execute until it provides a value using the *note yield: 21b.
          statement.  When the function executes a *note return: 781.
          statement or falls off the end, a *note StopIteration: 7a5.
          exception is raised and the iterator will have reached the end
          of the set of values to be returned.

     Built-in functions

          A built-in function object is a wrapper around a C function.
          Examples of built-in functions are *note len(): 358. and *note
          math.sin(): 899. (*note math: ae. is a standard built-in
          module).  The number and type of the arguments are determined
          by the C function.  Special read-only attributes: ‘__doc__’ is
          the function’s documentation string, or ‘None’ if unavailable;
          *note __name__: 6cb. is the function’s name; ‘__self__’ is set
          to ‘None’ (but see the next item); ‘__module__’ is the name of
          the module the function was defined in or ‘None’ if
          unavailable.

     Built-in methods

          This is really a different disguise of a built-in function,
          this time containing an object passed to the C function as an
          implicit extra argument.  An example of a built-in method is
          ‘alist.append()’, assuming `alist' is a list object.  In this
          case, the special read-only attribute ‘__self__’ is set to the
          object denoted by `alist'.

     Classes

          Classes are callable.  These objects normally act as factories
          for new instances of themselves, but variations are possible
          for class types that override *note __new__(): 21f.  The
          arguments of the call are passed to *note __new__(): 21f. and,
          in the typical case, to *note __init__(): 7da. to initialize
          the new instance.

     Class Instances

          Instances of arbitrary classes can be made callable by
          defining a *note __call__(): c01. method in their class.

Modules

     Modules are a basic organizational unit of Python code, and are
     created by the *note import system: c02. as invoked either by the
     *note import: 674. statement (see *note import: 674.), or by
     calling functions such as *note importlib.import_module(): 52a. and
     built-in *note __import__(): 383.  A module object has a namespace
     implemented by a dictionary object (this is the dictionary
     referenced by the ‘__globals__’ attribute of functions defined in
     the module).  Attribute references are translated to lookups in
     this dictionary, e.g., ‘m.x’ is equivalent to ‘m.__dict__["x"]’.  A
     module object does not contain the code object used to initialize
     the module (since it isn’t needed once the initialization is done).

     Attribute assignment updates the module’s namespace dictionary,
     e.g., ‘m.x = 1’ is equivalent to ‘m.__dict__["x"] = 1’.

     Special read-only attribute: ‘__dict__’ is the module’s namespace
     as a dictionary object.

     `CPython implementation detail:' Because of the way CPython clears
     module dictionaries, the module dictionary will be cleared when the
     module falls out of scope even if the dictionary still has live
     references.  To avoid this, copy the dictionary or keep the module
     around while using its dictionary directly.

     Predefined (writable) attributes: *note __name__: 6cb. is the
     module’s name; ‘__doc__’ is the module’s documentation string, or
     ‘None’ if unavailable; *note __file__: c03. is the pathname of the
     file from which the module was loaded, if it was loaded from a
     file.  The *note __file__: c03. attribute may be missing for
     certain types of modules, such as C modules that are statically
     linked into the interpreter; for extension modules loaded
     dynamically from a shared library, it is the pathname of the shared
     library file.

Custom classes

     Custom class types are typically created by class definitions (see
     section *note Class definitions: 6ce.).  A class has a namespace
     implemented by a dictionary object.  Class attribute references are
     translated to lookups in this dictionary, e.g., ‘C.x’ is translated
     to ‘C.__dict__["x"]’ (although there are a number of hooks which
     allow for other means of locating attributes).  When the attribute
     name is not found there, the attribute search continues in the base
     classes.  This search of the base classes uses the C3 method
     resolution order which behaves correctly even in the presence of
     ’diamond’ inheritance structures where there are multiple
     inheritance paths leading back to a common ancestor.  Additional
     details on the C3 MRO used by Python can be found in the
     documentation accompanying the 2.3 release at
     ‘https://www.python.org/download/releases/2.3/mro/’.

     When a class attribute reference (for class ‘C’, say) would yield a
     class method object, it is transformed into an instance method
     object whose ‘__self__’ attributes is ‘C’.  When it would yield a
     static method object, it is transformed into the object wrapped by
     the static method object.  See section *note Implementing
     Descriptors: c04. for another way in which attributes retrieved
     from a class may differ from those actually contained in its
     ‘__dict__’.

     Class attribute assignments update the class’s dictionary, never
     the dictionary of a base class.

     A class object can be called (see above) to yield a class instance
     (see below).

     Special attributes: *note __name__: 6cb. is the class name;
     ‘__module__’ is the module name in which the class was defined;
     ‘__dict__’ is the dictionary containing the class’s namespace;
     *note __bases__: c05. is a tuple (possibly empty or a singleton)
     containing the base classes, in the order of their occurrence in
     the base class list; ‘__doc__’ is the class’s documentation string,
     or None if undefined.

Class instances

     A class instance is created by calling a class object (see above).
     A class instance has a namespace implemented as a dictionary which
     is the first place in which attribute references are searched.
     When an attribute is not found there, and the instance’s class has
     an attribute by that name, the search continues with the class
     attributes.  If a class attribute is found that is a user-defined
     function object, it is transformed into an instance method object
     whose ‘__self__’ attribute is the instance.  Static method and
     class method objects are also transformed; see above under
     "Classes".  See section *note Implementing Descriptors: c04. for
     another way in which attributes of a class retrieved via its
     instances may differ from the objects actually stored in the
     class’s ‘__dict__’.  If no class attribute is found, and the
     object’s class has a *note __getattr__(): 560. method, that is
     called to satisfy the lookup.

     Attribute assignments and deletions update the instance’s
     dictionary, never a class’s dictionary.  If the class has a *note
     __setattr__(): 8ba. or *note __delattr__(): c06. method, this is
     called instead of updating the instance dictionary directly.

     Class instances can pretend to be numbers, sequences, or mappings
     if they have methods with certain special names.  See section *note
     Special method names: bb6.

     Special attributes: *note __dict__: c07. is the attribute
     dictionary; *note __class__: c08. is the instance’s class.

I/O objects (also known as file objects)

     A *note file object: 56a. represents an open file.  Various
     shortcuts are available to create file objects: the *note open():
     1a2. built-in function, and also *note os.popen(): 5bf, *note
     os.fdopen(): c09, and the *note makefile(): 531. method of socket
     objects (and perhaps by other functions or methods provided by
     extension modules).

     The objects ‘sys.stdin’, ‘sys.stdout’ and ‘sys.stderr’ are
     initialized to file objects corresponding to the interpreter’s
     standard input, output and error streams; they are all open in text
     mode and therefore follow the interface defined by the *note
     io.TextIOBase: 693. abstract class.

Internal types

     A few types used internally by the interpreter are exposed to the
     user.  Their definitions may change with future versions of the
     interpreter, but they are mentioned here for completeness.

     Code objects

          Code objects represent `byte-compiled' executable Python code,
          or *note bytecode: b2e.  The difference between a code object
          and a function object is that the function object contains an
          explicit reference to the function’s globals (the module in
          which it was defined), while a code object contains no
          context; also the default argument values are stored in the
          function object, not in the code object (because they
          represent values calculated at run-time).  Unlike function
          objects, code objects are immutable and contain no references
          (directly or indirectly) to mutable objects.

          Special read-only attributes: ‘co_name’ gives the function
          name; ‘co_argcount’ is the number of positional arguments
          (including arguments with default values); ‘co_nlocals’ is the
          number of local variables used by the function (including
          arguments); ‘co_varnames’ is a tuple containing the names of
          the local variables (starting with the argument names);
          ‘co_cellvars’ is a tuple containing the names of local
          variables that are referenced by nested functions;
          ‘co_freevars’ is a tuple containing the names of free
          variables; ‘co_code’ is a string representing the sequence of
          bytecode instructions; ‘co_consts’ is a tuple containing the
          literals used by the bytecode; ‘co_names’ is a tuple
          containing the names used by the bytecode; ‘co_filename’ is
          the filename from which the code was compiled;
          ‘co_firstlineno’ is the first line number of the function;
          ‘co_lnotab’ is a string encoding the mapping from bytecode
          offsets to line numbers (for details see the source code of
          the interpreter); ‘co_stacksize’ is the required stack size
          (including local variables); ‘co_flags’ is an integer encoding
          a number of flags for the interpreter.

          The following flag bits are defined for ‘co_flags’: bit ‘0x04’
          is set if the function uses the ‘*arguments’ syntax to accept
          an arbitrary number of positional arguments; bit ‘0x08’ is set
          if the function uses the ‘**keywords’ syntax to accept
          arbitrary keyword arguments; bit ‘0x20’ is set if the function
          is a generator.

          Future feature declarations (‘from __future__ import
          division’) also use bits in ‘co_flags’ to indicate whether a
          code object was compiled with a particular feature enabled:
          bit ‘0x2000’ is set if the function was compiled with future
          division enabled; bits ‘0x10’ and ‘0x1000’ were used in
          earlier versions of Python.

          Other bits in ‘co_flags’ are reserved for internal use.

          If a code object represents a function, the first item in
          ‘co_consts’ is the documentation string of the function, or
          ‘None’ if undefined.

     Frame objects

          Frame objects represent execution frames.  They may occur in
          traceback objects (see below).

          Special read-only attributes: ‘f_back’ is to the previous
          stack frame (towards the caller), or ‘None’ if this is the
          bottom stack frame; ‘f_code’ is the code object being executed
          in this frame; ‘f_locals’ is the dictionary used to look up
          local variables; ‘f_globals’ is used for global variables;
          ‘f_builtins’ is used for built-in (intrinsic) names; ‘f_lasti’
          gives the precise instruction (this is an index into the
          bytecode string of the code object).

          Special writable attributes: ‘f_trace’, if not ‘None’, is a
          function called at the start of each source code line (this is
          used by the debugger); ‘f_lineno’ is the current line number
          of the frame — writing to this from within a trace function
          jumps to the given line (only for the bottom-most frame).  A
          debugger can implement a Jump command (aka Set Next Statement)
          by writing to f_lineno.

          Frame objects support one method:

           -- Method: frame.clear ()

               This method clears all references to local variables held
               by the frame.  Also, if the frame belonged to a
               generator, the generator is finalized.  This helps break
               reference cycles involving frame objects (for example
               when catching an exception and storing its traceback for
               later use).

               *note RuntimeError: 7f0. is raised if the frame is
               currently executing.

               New in version 3.4.

     Traceback objects

          Traceback objects represent a stack trace of an exception.  A
          traceback object is created when an exception occurs.  When
          the search for an exception handler unwinds the execution
          stack, at each unwound level a traceback object is inserted in
          front of the current traceback.  When an exception handler is
          entered, the stack trace is made available to the program.
          (See section *note The try statement: 7ee.)  It is accessible
          as the third item of the tuple returned by ‘sys.exc_info()’.
          When the program contains no suitable handler, the stack trace
          is written (nicely formatted) to the standard error stream; if
          the interpreter is interactive, it is also made available to
          the user as ‘sys.last_traceback’.

          Special read-only attributes: ‘tb_next’ is the next level in
          the stack trace (towards the frame where the exception
          occurred), or ‘None’ if there is no next level; ‘tb_frame’
          points to the execution frame of the current level;
          ‘tb_lineno’ gives the line number where the exception
          occurred; ‘tb_lasti’ indicates the precise instruction.  The
          line number and last instruction in the traceback may differ
          from the line number of its frame object if the exception
          occurred in a *note try: 7ee. statement with no matching
          except clause or with a finally clause.

     Slice objects

          Slice objects are used to represent slices for *note
          __getitem__(): 88d. methods.  They are also created by the
          built-in *note slice(): 88e. function.

          Special read-only attributes: ‘start’ is the lower bound;
          ‘stop’ is the upper bound; ‘step’ is the step value; each is
          ‘None’ if omitted.  These attributes can have any type.

          Slice objects support one method:

           -- Method: slice.indices (self, length)

               This method takes a single integer argument `length' and
               computes information about the slice that the slice
               object would describe if applied to a sequence of
               `length' items.  It returns a tuple of three integers;
               respectively these are the `start' and `stop' indices and
               the `step' or stride length of the slice.  Missing or
               out-of-bounds indices are handled in a manner consistent
               with regular slices.

     Static method objects

          Static method objects provide a way of defeating the
          transformation of function objects to method objects described
          above.  A static method object is a wrapper around any other
          object, usually a user-defined method object.  When a static
          method object is retrieved from a class or a class instance,
          the object actually returned is the wrapped object, which is
          not subject to any further transformation.  Static method
          objects are not themselves callable, although the objects they
          wrap usually are.  Static method objects are created by the
          built-in *note staticmethod(): 3b1. constructor.

     Class method objects

          A class method object, like a static method object, is a
          wrapper around another object that alters the way in which
          that object is retrieved from classes and class instances.
          The behaviour of class method objects upon such retrieval is
          described above, under "User-defined methods".  Class method
          objects are created by the built-in *note classmethod(): 3af.
          constructor.


File: python.info,  Node: Special method names,  Prev: The standard type hierarchy,  Up: Data model

4.3.3 Special method names
--------------------------

A class can implement certain operations that are invoked by special
syntax (such as arithmetic operations or subscripting and slicing) by
defining methods with special names.  This is Python’s approach to
`operator overloading', allowing classes to define their own behavior
with respect to language operators.  For instance, if a class defines a
method named *note __getitem__(): 88d, and ‘x’ is an instance of this
class, then ‘x[i]’ is roughly equivalent to ‘type(x).__getitem__(x, i)’.
Except where mentioned, attempts to execute an operation raise an
exception when no appropriate method is defined (typically *note
AttributeError: 320. or *note TypeError: 309.).

When implementing a class that emulates any built-in type, it is
important that the emulation only be implemented to the degree that it
makes sense for the object being modelled.  For example, some sequences
may work well with retrieval of individual elements, but extracting a
slice may not make sense.  (One example of this is the ‘NodeList’
interface in the W3C’s Document Object Model.)

* Menu:

* Basic customization:: 
* Customizing attribute access:: 
* Customizing class creation:: 
* Customizing instance and subclass checks:: 
* Emulating callable objects:: 
* Emulating container types:: 
* Emulating numeric types:: 
* With Statement Context Managers:: 
* Special method lookup:: 


File: python.info,  Node: Basic customization,  Next: Customizing attribute access,  Up: Special method names

4.3.3.1 Basic customization
...........................

 -- Method: object.__new__ (cls[, ...])

     Called to create a new instance of class `cls'.  *note __new__():
     21f. is a static method (special-cased so you need not declare it
     as such) that takes the class of which an instance was requested as
     its first argument.  The remaining arguments are those passed to
     the object constructor expression (the call to the class).  The
     return value of *note __new__(): 21f. should be the new object
     instance (usually an instance of `cls').

     Typical implementations create a new instance of the class by
     invoking the superclass’s *note __new__(): 21f. method using
     ‘super(currentclass, cls).__new__(cls[, ...])’ with appropriate
     arguments and then modifying the newly-created instance as
     necessary before returning it.

     If *note __new__(): 21f. returns an instance of `cls', then the new
     instance’s *note __init__(): 7da. method will be invoked like
     ‘__init__(self[, ...])’, where `self' is the new instance and the
     remaining arguments are the same as were passed to *note __new__():
     21f.

     If *note __new__(): 21f. does not return an instance of `cls', then
     the new instance’s *note __init__(): 7da. method will not be
     invoked.

     *note __new__(): 21f. is intended mainly to allow subclasses of
     immutable types (like int, str, or tuple) to customize instance
     creation.  It is also commonly overridden in custom metaclasses in
     order to customize class creation.

 -- Method: object.__init__ (self[, ...])

     Called after the instance has been created (by *note __new__():
     21f.), but before it is returned to the caller.  The arguments are
     those passed to the class constructor expression.  If a base class
     has an *note __init__(): 7da. method, the derived class’s *note
     __init__(): 7da. method, if any, must explicitly call it to ensure
     proper initialization of the base class part of the instance; for
     example: ‘BaseClass.__init__(self, [args...])’.

     Because *note __new__(): 21f. and *note __init__(): 7da. work
     together in constructing objects (*note __new__(): 21f. to create
     it, and *note __init__(): 7da. to customise it), no non-‘None’
     value may be returned by *note __init__(): 7da.; doing so will
     cause a *note TypeError: 309. to be raised at runtime.

 -- Method: object.__del__ (self)

     Called when the instance is about to be destroyed.  This is also
     called a destructor.  If a base class has a *note __del__(): 2c4.
     method, the derived class’s *note __del__(): 2c4. method, if any,
     must explicitly call it to ensure proper deletion of the base class
     part of the instance.  Note that it is possible (though not
     recommended!)  for the *note __del__(): 2c4. method to postpone
     destruction of the instance by creating a new reference to it.  It
     may then be called at a later time when this new reference is
     deleted.  It is not guaranteed that *note __del__(): 2c4. methods
     are called for objects that still exist when the interpreter exits.

          Note: ‘del x’ doesn’t directly call ‘x.__del__()’ — the former
          decrements the reference count for ‘x’ by one, and the latter
          is only called when ‘x’’s reference count reaches zero.  Some
          common situations that may prevent the reference count of an
          object from going to zero include: circular references between
          objects (e.g., a doubly-linked list or a tree data structure
          with parent and child pointers); a reference to the object on
          the stack frame of a function that caught an exception (the
          traceback stored in ‘sys.exc_info()[2]’ keeps the stack frame
          alive); or a reference to the object on the stack frame that
          raised an unhandled exception in interactive mode (the
          traceback stored in ‘sys.last_traceback’ keeps the stack frame
          alive).  The first situation can only be remedied by
          explicitly breaking the cycles; the second can be resolved by
          freeing the reference to the traceback object when it is no
          longer useful, and the third can be resolved by storing ‘None’
          in ‘sys.last_traceback’.  Circular references which are
          garbage are detected and cleaned up when the cyclic garbage
          collector is enabled (it’s on by default).  Refer to the
          documentation for the *note gc: 85. module for more
          information about this topic.

          Warning: Due to the precarious circumstances under which *note
          __del__(): 2c4. methods are invoked, exceptions that occur
          during their execution are ignored, and a warning is printed
          to ‘sys.stderr’ instead.  Also, when *note __del__(): 2c4. is
          invoked in response to a module being deleted (e.g., when
          execution of the program is done), other globals referenced by
          the *note __del__(): 2c4. method may already have been deleted
          or in the process of being torn down (e.g.  the import
          machinery shutting down).  For this reason, *note __del__():
          2c4. methods should do the absolute minimum needed to maintain
          external invariants.  Starting with version 1.5, Python
          guarantees that globals whose name begins with a single
          underscore are deleted from their module before other globals
          are deleted; if no other references to such globals exist,
          this may help in assuring that imported modules are still
          available at the time when the *note __del__(): 2c4. method is
          called.

 -- Method: object.__repr__ (self)

     Called by the *note repr(): 3db. built-in function to compute the
     "official" string representation of an object.  If at all possible,
     this should look like a valid Python expression that could be used
     to recreate an object with the same value (given an appropriate
     environment).  If this is not possible, a string of the form
     ‘<...some useful description...>’ should be returned.  The return
     value must be a string object.  If a class defines *note
     __repr__(): 5a3. but not *note __str__(): 8c6, then *note
     __repr__(): 5a3. is also used when an "informal" string
     representation of instances of that class is required.

     This is typically used for debugging, so it is important that the
     representation is information-rich and unambiguous.

 -- Method: object.__str__ (self)

     Called by *note str(object): 178. and the built-in functions *note
     format(): 556. and *note print(): 21c. to compute the "informal" or
     nicely printable string representation of an object.  The return
     value must be a *note string: a16. object.

     This method differs from *note object.__repr__(): 5a3. in that
     there is no expectation that *note __str__(): 8c6. return a valid
     Python expression: a more convenient or concise representation can
     be used.

     The default implementation defined by the built-in type *note
     object: 381. calls *note object.__repr__(): 5a3.

 -- Method: object.__bytes__ (self)

     Called by *note bytes(): 179. to compute a byte-string
     representation of an object.  This should return a ‘bytes’ object.

 -- Method: object.__format__ (self, format_spec)

     Called by the *note format(): 556. built-in function (and by
     extension, the *note str.format(): 557. method of class *note str:
     178.) to produce a "formatted" string representation of an object.
     The ‘format_spec’ argument is a string that contains a description
     of the formatting options desired.  The interpretation of the
     ‘format_spec’ argument is up to the type implementing *note
     __format__(): 308, however most classes will either delegate
     formatting to one of the built-in types, or use a similar
     formatting option syntax.

     See *note Format Specification Mini-Language: c0f. for a
     description of the standard formatting syntax.

     The return value must be a string object.

     Changed in version 3.4: The __format__ method of ‘object’ itself
     raises a *note TypeError: 309. if passed any non-empty string.

 -- Method: object.__lt__ (self, other)
 -- Method: object.__le__ (self, other)
 -- Method: object.__eq__ (self, other)
 -- Method: object.__ne__ (self, other)
 -- Method: object.__gt__ (self, other)
 -- Method: object.__ge__ (self, other)

     These are the so-called "rich comparison" methods.  The
     correspondence between operator symbols and method names is as
     follows: ‘x<y’ calls ‘x.__lt__(y)’, ‘x<=y’ calls ‘x.__le__(y)’,
     ‘x==y’ calls ‘x.__eq__(y)’, ‘x!=y’ calls ‘x.__ne__(y)’, ‘x>y’ calls
     ‘x.__gt__(y)’, and ‘x>=y’ calls ‘x.__ge__(y)’.

     A rich comparison method may return the singleton ‘NotImplemented’
     if it does not implement the operation for a given pair of
     arguments.  By convention, ‘False’ and ‘True’ are returned for a
     successful comparison.  However, these methods can return any
     value, so if the comparison operator is used in a Boolean context
     (e.g., in the condition of an ‘if’ statement), Python will call
     *note bool(): 87a. on the value to determine if the result is true
     or false.

     There are no implied relationships among the comparison operators.
     The truth of ‘x==y’ does not imply that ‘x!=y’ is false.
     Accordingly, when defining *note __eq__(): 68d, one should also
     define *note __ne__(): 8e8. so that the operators will behave as
     expected.  See the paragraph on *note __hash__(): 39f. for some
     important notes on creating *note hashable: bfd. objects which
     support custom comparison operations and are usable as dictionary
     keys.

     There are no swapped-argument versions of these methods (to be used
     when the left argument does not support the operation but the right
     argument does); rather, *note __lt__(): 68c. and *note __gt__():
     710. are each other’s reflection, *note __le__(): 70f. and *note
     __ge__(): 711. are each other’s reflection, and *note __eq__():
     68d. and *note __ne__(): 8e8. are their own reflection.

     Arguments to rich comparison methods are never coerced.

     To automatically generate ordering operations from a single root
     operation, see *note functools.total_ordering(): 1d5.

 -- Method: object.__hash__ (self)

     Called by built-in function *note hash(): 39e. and for operations
     on members of hashed collections including *note set: 5a4, *note
     frozenset: 63c, and *note dict: 380.  *note __hash__(): 39f. should
     return an integer.  The only required property is that objects
     which compare equal have the same hash value; it is advised to
     somehow mix together (e.g.  using exclusive or) the hash values for
     the components of the object that also play a part in comparison of
     objects.

          Note: *note hash(): 39e. truncates the value returned from an
          object’s custom *note __hash__(): 39f. method to the size of a
          ‘Py_ssize_t’.  This is typically 8 bytes on 64-bit builds and
          4 bytes on 32-bit builds.  If an object’s *note __hash__():
          39f. must interoperate on builds of different bit sizes, be
          sure to check the width on all supported builds.  An easy way
          to do this is with ‘python -c "import sys;
          print(sys.hash_info.width)"’

     If a class does not define an *note __eq__(): 68d. method it should
     not define a *note __hash__(): 39f. operation either; if it defines
     *note __eq__(): 68d. but not *note __hash__(): 39f, its instances
     will not be usable as items in hashable collections.  If a class
     defines mutable objects and implements an *note __eq__(): 68d.
     method, it should not implement *note __hash__(): 39f, since the
     implementation of hashable collections requires that a key’s hash
     value is immutable (if the object’s hash value changes, it will be
     in the wrong hash bucket).

     User-defined classes have *note __eq__(): 68d. and *note
     __hash__(): 39f. methods by default; with them, all objects compare
     unequal (except with themselves) and ‘x.__hash__()’ returns an
     appropriate value such that ‘x == y’ implies both that ‘x is y’ and
     ‘hash(x) == hash(y)’.

     A class that overrides *note __eq__(): 68d. and does not define
     *note __hash__(): 39f. will have its *note __hash__(): 39f.
     implicitly set to ‘None’.  When the *note __hash__(): 39f. method
     of a class is ‘None’, instances of the class will raise an
     appropriate *note TypeError: 309. when a program attempts to
     retrieve their hash value, and will also be correctly identified as
     unhashable when checking ‘isinstance(obj, collections.Hashable’).

     If a class that overrides *note __eq__(): 68d. needs to retain the
     implementation of *note __hash__(): 39f. from a parent class, the
     interpreter must be told this explicitly by setting ‘__hash__ =
     <ParentClass>.__hash__’.

     If a class that does not override *note __eq__(): 68d. wishes to
     suppress hash support, it should include ‘__hash__ = None’ in the
     class definition.  A class which defines its own *note __hash__():
     39f. that explicitly raises a *note TypeError: 309. would be
     incorrectly identified as hashable by an ‘isinstance(obj,
     collections.Hashable)’ call.

          Note: By default, the *note __hash__(): 39f. values of str,
          bytes and datetime objects are "salted" with an unpredictable
          random value.  Although they remain constant within an
          individual Python process, they are not predictable between
          repeated invocations of Python.

          This is intended to provide protection against a
          denial-of-service caused by carefully-chosen inputs that
          exploit the worst case performance of a dict insertion, O(n^2)
          complexity.  See
          ‘http://www.ocert.org/advisories/ocert-2011-003.html’ for
          details.

          Changing hash values affects the iteration order of dicts,
          sets and other mappings.  Python has never made guarantees
          about this ordering (and it typically varies between 32-bit
          and 64-bit builds).

          See also *note PYTHONHASHSEED: 3a0.

     Changed in version 3.3: Hash randomization is enabled by default.

 -- Method: object.__bool__ (self)

     Called to implement truth value testing and the built-in operation
     ‘bool()’; should return ‘False’ or ‘True’.  When this method is not
     defined, *note __len__(): 84f. is called, if it is defined, and the
     object is considered true if its result is nonzero.  If a class
     defines neither *note __len__(): 84f. nor *note __bool__(): 6cc,
     all its instances are considered true.


File: python.info,  Node: Customizing attribute access,  Next: Customizing class creation,  Prev: Basic customization,  Up: Special method names

4.3.3.2 Customizing attribute access
....................................

The following methods can be defined to customize the meaning of
attribute access (use of, assignment to, or deletion of ‘x.name’) for
class instances.

 -- Method: object.__getattr__ (self, name)

     Called when an attribute lookup has not found the attribute in the
     usual places (i.e.  it is not an instance attribute nor is it found
     in the class tree for ‘self’).  ‘name’ is the attribute name.  This
     method should return the (computed) attribute value or raise an
     *note AttributeError: 320. exception.

     Note that if the attribute is found through the normal mechanism,
     *note __getattr__(): 560. is not called.  (This is an intentional
     asymmetry between *note __getattr__(): 560. and *note
     __setattr__(): 8ba.)  This is done both for efficiency reasons and
     because otherwise *note __getattr__(): 560. would have no way to
     access other attributes of the instance.  Note that at least for
     instance variables, you can fake total control by not inserting any
     values in the instance attribute dictionary (but instead inserting
     them in another object).  See the *note __getattribute__(): 561.
     method below for a way to actually get total control over attribute
     access.

 -- Method: object.__getattribute__ (self, name)

     Called unconditionally to implement attribute accesses for
     instances of the class.  If the class also defines *note
     __getattr__(): 560, the latter will not be called unless *note
     __getattribute__(): 561. either calls it explicitly or raises an
     *note AttributeError: 320.  This method should return the
     (computed) attribute value or raise an *note AttributeError: 320.
     exception.  In order to avoid infinite recursion in this method,
     its implementation should always call the base class method with
     the same name to access any attributes it needs, for example,
     ‘object.__getattribute__(self, name)’.

          Note: This method may still be bypassed when looking up
          special methods as the result of implicit invocation via
          language syntax or built-in functions.  See *note Special
          method lookup: c13.

 -- Method: object.__setattr__ (self, name, value)

     Called when an attribute assignment is attempted.  This is called
     instead of the normal mechanism (i.e.  store the value in the
     instance dictionary).  `name' is the attribute name, `value' is the
     value to be assigned to it.

     If *note __setattr__(): 8ba. wants to assign to an instance
     attribute, it should call the base class method with the same name,
     for example, ‘object.__setattr__(self, name, value)’.

 -- Method: object.__delattr__ (self, name)

     Like *note __setattr__(): 8ba. but for attribute deletion instead
     of assignment.  This should only be implemented if ‘del obj.name’
     is meaningful for the object.

 -- Method: object.__dir__ (self)

     Called when *note dir(): 7a8. is called on the object.  A sequence
     must be returned.  *note dir(): 7a8. converts the returned sequence
     to a list and sorts it.

* Menu:

* Implementing Descriptors:: 
* Invoking Descriptors:: 
* __slots__:: 


File: python.info,  Node: Implementing Descriptors,  Next: Invoking Descriptors,  Up: Customizing attribute access

4.3.3.3 Implementing Descriptors
................................

The following methods only apply when an instance of the class
containing the method (a so-called `descriptor' class) appears in an
`owner' class (the descriptor must be in either the owner’s class
dictionary or in the class dictionary for one of its parents).  In the
examples below, "the attribute" refers to the attribute whose name is
the key of the property in the owner class’ ‘__dict__’.

 -- Method: object.__get__ (self, instance, owner)

     Called to get the attribute of the owner class (class attribute
     access) or of an instance of that class (instance attribute
     access).  `owner' is always the owner class, while `instance' is
     the instance that the attribute was accessed through, or ‘None’
     when the attribute is accessed through the `owner'.  This method
     should return the (computed) attribute value or raise an *note
     AttributeError: 320. exception.

 -- Method: object.__set__ (self, instance, value)

     Called to set the attribute on an instance `instance' of the owner
     class to a new value, `value'.

 -- Method: object.__delete__ (self, instance)

     Called to delete the attribute on an instance `instance' of the
     owner class.

The attribute ‘__objclass__’ is interpreted by the *note inspect: 9d.
module as specifying the class where this object was defined (setting
this appropriately can assist in runtime introspection of dynamic class
attributes).  For callables, it may indicate that an instance of the
given type (or a subclass) is expected or required as the first
positional argument (for example, CPython sets this attribute for
unbound methods that are implemented in C).


File: python.info,  Node: Invoking Descriptors,  Next: __slots__,  Prev: Implementing Descriptors,  Up: Customizing attribute access

4.3.3.4 Invoking Descriptors
............................

In general, a descriptor is an object attribute with "binding behavior",
one whose attribute access has been overridden by methods in the
descriptor protocol: *note __get__(): c15, *note __set__(): c16, and
*note __delete__(): c17.  If any of those methods are defined for an
object, it is said to be a descriptor.

The default behavior for attribute access is to get, set, or delete the
attribute from an object’s dictionary.  For instance, ‘a.x’ has a lookup
chain starting with ‘a.__dict__['x']’, then ‘type(a).__dict__['x']’, and
continuing through the base classes of ‘type(a)’ excluding metaclasses.

However, if the looked-up value is an object defining one of the
descriptor methods, then Python may override the default behavior and
invoke the descriptor method instead.  Where this occurs in the
precedence chain depends on which descriptor methods were defined and
how they were called.

The starting point for descriptor invocation is a binding, ‘a.x’.  How
the arguments are assembled depends on ‘a’:

Direct Call

     The simplest and least common call is when user code directly
     invokes a descriptor method: ‘x.__get__(a)’.

Instance Binding

     If binding to an object instance, ‘a.x’ is transformed into the
     call: ‘type(a).__dict__['x'].__get__(a, type(a))’.

Class Binding

     If binding to a class, ‘A.x’ is transformed into the call:
     ‘A.__dict__['x'].__get__(None, A)’.

Super Binding

     If ‘a’ is an instance of *note super: 311, then the binding
     ‘super(B, obj).m()’ searches ‘obj.__class__.__mro__’ for the base
     class ‘A’ immediately preceding ‘B’ and then invokes the descriptor
     with the call: ‘A.__dict__['m'].__get__(obj, obj.__class__)’.

For instance bindings, the precedence of descriptor invocation depends
on the which descriptor methods are defined.  A descriptor can define
any combination of *note __get__(): c15, *note __set__(): c16. and *note
__delete__(): c17.  If it does not define *note __get__(): c15, then
accessing the attribute will return the descriptor object itself unless
there is a value in the object’s instance dictionary.  If the descriptor
defines *note __set__(): c16. and/or *note __delete__(): c17, it is a
data descriptor; if it defines neither, it is a non-data descriptor.
Normally, data descriptors define both *note __get__(): c15. and *note
__set__(): c16, while non-data descriptors have just the *note
__get__(): c15. method.  Data descriptors with *note __set__(): c16. and
*note __get__(): c15. defined always override a redefinition in an
instance dictionary.  In contrast, non-data descriptors can be
overridden by instances.

Python methods (including *note staticmethod(): 3b1. and *note
classmethod(): 3af.) are implemented as non-data descriptors.
Accordingly, instances can redefine and override methods.  This allows
individual instances to acquire behaviors that differ from other
instances of the same class.

The *note property(): 3ac. function is implemented as a data descriptor.
Accordingly, instances cannot override the behavior of a property.


File: python.info,  Node: __slots__,  Prev: Invoking Descriptors,  Up: Customizing attribute access

4.3.3.5 __slots__
.................

By default, instances of classes have a dictionary for attribute
storage.  This wastes space for objects having very few instance
variables.  The space consumption can become acute when creating large
numbers of instances.

The default can be overridden by defining `__slots__' in a class
definition.  The `__slots__' declaration takes a sequence of instance
variables and reserves just enough space in each instance to hold a
value for each variable.  Space is saved because `__dict__' is not
created for each instance.

 -- Data: object.__slots__

     This class variable can be assigned a string, iterable, or sequence
     of strings with variable names used by instances.  `__slots__'
     reserves space for the declared variables and prevents the
     automatic creation of `__dict__' and `__weakref__' for each
     instance.

* Menu:

* Notes on using __slots__:: 


File: python.info,  Node: Notes on using __slots__,  Up: __slots__

4.3.3.6 Notes on using `__slots__'
..................................

   * When inheriting from a class without `__slots__', the `__dict__'
     attribute of that class will always be accessible, so a `__slots__'
     definition in the subclass is meaningless.

   * Without a `__dict__' variable, instances cannot be assigned new
     variables not listed in the `__slots__' definition.  Attempts to
     assign to an unlisted variable name raises *note AttributeError:
     320.  If dynamic assignment of new variables is desired, then add
     ‘'__dict__'’ to the sequence of strings in the `__slots__'
     declaration.

   * Without a `__weakref__' variable for each instance, classes
     defining `__slots__' do not support weak references to its
     instances.  If weak reference support is needed, then add
     ‘'__weakref__'’ to the sequence of strings in the `__slots__'
     declaration.

   * `__slots__' are implemented at the class level by creating
     descriptors (*note Implementing Descriptors: c04.) for each
     variable name.  As a result, class attributes cannot be used to set
     default values for instance variables defined by `__slots__';
     otherwise, the class attribute would overwrite the descriptor
     assignment.

   * The action of a `__slots__' declaration is limited to the class
     where it is defined.  As a result, subclasses will have a
     `__dict__' unless they also define `__slots__' (which must only
     contain names of any `additional' slots).

   * If a class defines a slot also defined in a base class, the
     instance variable defined by the base class slot is inaccessible
     (except by retrieving its descriptor directly from the base class).
     This renders the meaning of the program undefined.  In the future,
     a check may be added to prevent this.

   * Nonempty `__slots__' does not work for classes derived from
     "variable-length" built-in types such as *note int: 185, *note
     bytes: 179. and *note tuple: 84e.

   * Any non-string iterable may be assigned to `__slots__'.  Mappings
     may also be used; however, in the future, special meaning may be
     assigned to the values corresponding to each key.

   * `__class__' assignment works only if both classes have the same
     `__slots__'.


File: python.info,  Node: Customizing class creation,  Next: Customizing instance and subclass checks,  Prev: Customizing attribute access,  Up: Special method names

4.3.3.7 Customizing class creation
..................................

By default, classes are constructed using *note type(): 8c1.  The class
body is executed in a new namespace and the class name is bound locally
to the result of ‘type(name, bases, namespace)’.

The class creation process can be customised by passing the ‘metaclass’
keyword argument in the class definition line, or by inheriting from an
existing class that included such an argument.  In the following
example, both ‘MyClass’ and ‘MySubclass’ are instances of ‘Meta’:

     class Meta(type):
         pass

     class MyClass(metaclass=Meta):
         pass

     class MySubclass(MyClass):
         pass

Any other keyword arguments that are specified in the class definition
are passed through to all metaclass operations described below.

When a class definition is executed, the following steps occur:

   * the appropriate metaclass is determined

   * the class namespace is prepared

   * the class body is executed

   * the class object is created

* Menu:

* Determining the appropriate metaclass:: 
* Preparing the class namespace:: 
* Executing the class body:: 
* Creating the class object:: 
* Metaclass example:: 


File: python.info,  Node: Determining the appropriate metaclass,  Next: Preparing the class namespace,  Up: Customizing class creation

4.3.3.8 Determining the appropriate metaclass
.............................................

The appropriate metaclass for a class definition is determined as
follows:

   * if no bases and no explicit metaclass are given, then *note type():
     8c1. is used

   * if an explicit metaclass is given and it is `not' an instance of
     *note type(): 8c1, then it is used directly as the metaclass

   * if an instance of *note type(): 8c1. is given as the explicit
     metaclass, or bases are defined, then the most derived metaclass is
     used

The most derived metaclass is selected from the explicitly specified
metaclass (if any) and the metaclasses (i.e.  ‘type(cls)’) of all
specified base classes.  The most derived metaclass is one which is a
subtype of `all' of these candidate metaclasses.  If none of the
candidate metaclasses meets that criterion, then the class definition
will fail with ‘TypeError’.


File: python.info,  Node: Preparing the class namespace,  Next: Executing the class body,  Prev: Determining the appropriate metaclass,  Up: Customizing class creation

4.3.3.9 Preparing the class namespace
.....................................

Once the appropriate metaclass has been identified, then the class
namespace is prepared.  If the metaclass has a ‘__prepare__’ attribute,
it is called as ‘namespace = metaclass.__prepare__(name, bases, **kwds)’
(where the additional keyword arguments, if any, come from the class
definition).

If the metaclass has no ‘__prepare__’ attribute, then the class
namespace is initialised as an empty *note dict(): 380. instance.

See also
........

PEP 3115(1) - Metaclasses in Python 3000

     Introduced the ‘__prepare__’ namespace hook

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-3115


File: python.info,  Node: Executing the class body,  Next: Creating the class object,  Prev: Preparing the class namespace,  Up: Customizing class creation

4.3.3.10 Executing the class body
.................................

The class body is executed (approximately) as ‘exec(body, globals(),
namespace)’.  The key difference from a normal call to *note exec():
6a0. is that lexical scoping allows the class body (including any
methods) to reference names from the current and outer scopes when the
class definition occurs inside a function.

However, even when the class definition occurs inside the function,
methods defined inside the class still cannot see names defined at the
class scope.  Class variables must be accessed through the first
parameter of instance or class methods, and cannot be accessed at all
from static methods.


File: python.info,  Node: Creating the class object,  Next: Metaclass example,  Prev: Executing the class body,  Up: Customizing class creation

4.3.3.11 Creating the class object
..................................

Once the class namespace has been populated by executing the class body,
the class object is created by calling ‘metaclass(name, bases,
namespace, **kwds)’ (the additional keywords passed here are the same as
those passed to ‘__prepare__’).

This class object is the one that will be referenced by the
zero-argument form of *note super(): 311.  ‘__class__’ is an implicit
closure reference created by the compiler if any methods in a class body
refer to either ‘__class__’ or ‘super’.  This allows the zero argument
form of *note super(): 311. to correctly identify the class being
defined based on lexical scoping, while the class or instance that was
used to make the current call is identified based on the first argument
passed to the method.

After the class object is created, it is passed to the class decorators
included in the class definition (if any) and the resulting object is
bound in the local namespace as the defined class.

See also
........

PEP 3135(1) - New super

     Describes the implicit ‘__class__’ closure reference

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-3135


File: python.info,  Node: Metaclass example,  Prev: Creating the class object,  Up: Customizing class creation

4.3.3.12 Metaclass example
..........................

The potential uses for metaclasses are boundless.  Some ideas that have
been explored include logging, interface checking, automatic delegation,
automatic property creation, proxies, frameworks, and automatic resource
locking/synchronization.

Here is an example of a metaclass that uses an *note
collections.OrderedDict: 587. to remember the order that class variables
are defined:

     class OrderedClass(type):

          @classmethod
          def __prepare__(metacls, name, bases, **kwds):
             return collections.OrderedDict()

          def __new__(cls, name, bases, namespace, **kwds):
             result = type.__new__(cls, name, bases, dict(namespace))
             result.members = tuple(namespace)
             return result

     class A(metaclass=OrderedClass):
         def one(self): pass
         def two(self): pass
         def three(self): pass
         def four(self): pass

     >>> A.members
     ('__module__', 'one', 'two', 'three', 'four')

When the class definition for `A' gets executed, the process begins with
calling the metaclass’s ‘__prepare__()’ method which returns an empty
*note collections.OrderedDict: 587.  That mapping records the methods
and attributes of `A' as they are defined within the body of the class
statement.  Once those definitions are executed, the ordered dictionary
is fully populated and the metaclass’s *note __new__(): 21f. method gets
invoked.  That method builds the new type and it saves the ordered
dictionary keys in an attribute called ‘members’.


File: python.info,  Node: Customizing instance and subclass checks,  Next: Emulating callable objects,  Prev: Customizing class creation,  Up: Special method names

4.3.3.13 Customizing instance and subclass checks
.................................................

The following methods are used to override the default behavior of the
*note isinstance(): 798. and *note issubclass(): 799. built-in
functions.

In particular, the metaclass *note abc.ABCMeta: 197. implements these
methods in order to allow the addition of Abstract Base Classes (ABCs)
as "virtual base classes" to any class or type (including built-in
types), including other ABCs.

 -- Method: class.__instancecheck__ (self, instance)

     Return true if `instance' should be considered a (direct or
     indirect) instance of `class'.  If defined, called to implement
     ‘isinstance(instance, class)’.

 -- Method: class.__subclasscheck__ (self, subclass)

     Return true if `subclass' should be considered a (direct or
     indirect) subclass of `class'.  If defined, called to implement
     ‘issubclass(subclass, class)’.

Note that these methods are looked up on the type (metaclass) of a
class.  They cannot be defined as class methods in the actual class.
This is consistent with the lookup of special methods that are called on
instances, only in this case the instance is itself a class.

See also
........

PEP 3119(1) - Introducing Abstract Base Classes

     Includes the specification for customizing *note isinstance(): 798.
     and *note issubclass(): 799. behavior through *note
     __instancecheck__(): c26. and *note __subclasscheck__(): c27, with
     motivation for this functionality in the context of adding Abstract
     Base Classes (see the *note abc: 4. module) to the language.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-3119


File: python.info,  Node: Emulating callable objects,  Next: Emulating container types,  Prev: Customizing instance and subclass checks,  Up: Special method names

4.3.3.14 Emulating callable objects
...................................

 -- Method: object.__call__ (self[, args...])

     Called when the instance is "called" as a function; if this method
     is defined, ‘x(arg1, arg2, ...)’ is a shorthand for
     ‘x.__call__(arg1, arg2, ...)’.


File: python.info,  Node: Emulating container types,  Next: Emulating numeric types,  Prev: Emulating callable objects,  Up: Special method names

4.3.3.15 Emulating container types
..................................

The following methods can be defined to implement container objects.
Containers usually are sequences (such as lists or tuples) or mappings
(like dictionaries), but can represent other containers as well.  The
first set of methods is used either to emulate a sequence or to emulate
a mapping; the difference is that for a sequence, the allowable keys
should be the integers `k' for which ‘0 <= k < N’ where `N' is the
length of the sequence, or slice objects, which define a range of items.
It is also recommended that mappings provide the methods ‘keys()’,
‘values()’, ‘items()’, ‘get()’, ‘clear()’, ‘setdefault()’, ‘pop()’,
‘popitem()’, ‘copy()’, and ‘update()’ behaving similar to those for
Python’s standard dictionary objects.  The *note collections: 1e. module
provides a *note MutableMapping: 3d9. abstract base class to help create
those methods from a base set of *note __getitem__(): 88d, *note
__setitem__(): 6c4, *note __delitem__(): 6c5, and ‘keys()’.  Mutable
sequences should provide methods ‘append()’, ‘count()’, ‘index()’,
‘extend()’, ‘insert()’, ‘pop()’, ‘remove()’, ‘reverse()’ and ‘sort()’,
like Python standard list objects.  Finally, sequence types should
implement addition (meaning concatenation) and multiplication (meaning
repetition) by defining the methods *note __add__(): c2c, *note
__radd__(): c2d, *note __iadd__(): 902, *note __mul__(): c2e, *note
__rmul__(): c2f. and *note __imul__(): c30. described below; they should
not define other numerical operators.  It is recommended that both
mappings and sequences implement the *note __contains__(): 79c. method
to allow efficient use of the ‘in’ operator; for mappings, ‘in’ should
search the mapping’s keys; for sequences, it should search through the
values.  It is further recommended that both mappings and sequences
implement the *note __iter__(): 79b. method to allow efficient iteration
through the container; for mappings, *note __iter__(): 79b. should be
the same as ‘keys()’; for sequences, it should iterate through the
values.

 -- Method: object.__len__ (self)

     Called to implement the built-in function *note len(): 358.  Should
     return the length of the object, an integer ‘>=’ 0.  Also, an
     object that doesn’t define a *note __bool__(): 6cc. method and
     whose *note __len__(): 84f. method returns zero is considered to be
     false in a Boolean context.

 -- Method: object.__length_hint__ (self)

     Called to implement *note operator.length_hint(): 210.  Should
     return an estimated length for the object (which may be greater or
     less than the actual length).  The length must be an integer ‘>=’
     0.  This method is purely an optimization and is never required for
     correctness.

     New in version 3.4.

     Note: Slicing is done exclusively with the following three methods.
     A call like

          a[1:2] = b

     is translated to

          a[slice(1, 2, None)] = b

     and so forth.  Missing slice items are always filled in with
     ‘None’.

 -- Method: object.__getitem__ (self, key)

     Called to implement evaluation of ‘self[key]’.  For sequence types,
     the accepted keys should be integers and slice objects.  Note that
     the special interpretation of negative indexes (if the class wishes
     to emulate a sequence type) is up to the *note __getitem__(): 88d.
     method.  If `key' is of an inappropriate type, *note TypeError:
     309. may be raised; if of a value outside the set of indexes for
     the sequence (after any special interpretation of negative values),
     *note IndexError: 908. should be raised.  For mapping types, if
     `key' is missing (not in the container), *note KeyError: 706.
     should be raised.

          Note: *note for: 688. loops expect that an *note IndexError:
          908. will be raised for illegal indexes to allow proper
          detection of the end of the sequence.

 -- Method: object.__missing__ (self, key)

     Called by *note dict: 380.*note __getitem__(): 88d. to implement
     ‘self[key]’ for dict subclasses when key is not in the dictionary.

 -- Method: object.__setitem__ (self, key, value)

     Called to implement assignment to ‘self[key]’.  Same note as for
     *note __getitem__(): 88d.  This should only be implemented for
     mappings if the objects support changes to the values for keys, or
     if new keys can be added, or for sequences if elements can be
     replaced.  The same exceptions should be raised for improper `key'
     values as for the *note __getitem__(): 88d. method.

 -- Method: object.__delitem__ (self, key)

     Called to implement deletion of ‘self[key]’.  Same note as for
     *note __getitem__(): 88d.  This should only be implemented for
     mappings if the objects support removal of keys, or for sequences
     if elements can be removed from the sequence.  The same exceptions
     should be raised for improper `key' values as for the *note
     __getitem__(): 88d. method.

 -- Method: object.__iter__ (self)

     This method is called when an iterator is required for a container.
     This method should return a new iterator object that can iterate
     over all the objects in the container.  For mappings, it should
     iterate over the keys of the container.

     Iterator objects also need to implement this method; they are
     required to return themselves.  For more information on iterator
     objects, see *note Iterator Types: c31.

 -- Method: object.__reversed__ (self)

     Called (if present) by the *note reversed(): 188. built-in to
     implement reverse iteration.  It should return a new iterator
     object that iterates over all the objects in the container in
     reverse order.

     If the *note __reversed__(): c32. method is not provided, the *note
     reversed(): 188. built-in will fall back to using the sequence
     protocol (*note __len__(): 84f. and *note __getitem__(): 88d.).
     Objects that support the sequence protocol should only provide
     *note __reversed__(): c32. if they can provide an implementation
     that is more efficient than the one provided by *note reversed():
     188.

The membership test operators (*note in: 6d5. and *note not in: c33.)
are normally implemented as an iteration through a sequence.  However,
container objects can supply the following special method with a more
efficient implementation, which also does not require the object be a
sequence.

 -- Method: object.__contains__ (self, item)

     Called to implement membership test operators.  Should return true
     if `item' is in `self', false otherwise.  For mapping objects, this
     should consider the keys of the mapping rather than the values or
     the key-item pairs.

     For objects that don’t define *note __contains__(): 79c, the
     membership test first tries iteration via *note __iter__(): 79b,
     then the old sequence iteration protocol via *note __getitem__():
     88d, see *note this section in the language reference: c34.


File: python.info,  Node: Emulating numeric types,  Next: With Statement Context Managers,  Prev: Emulating container types,  Up: Special method names

4.3.3.16 Emulating numeric types
................................

The following methods can be defined to emulate numeric objects.
Methods corresponding to operations that are not supported by the
particular kind of number implemented (e.g., bitwise operations for
non-integral numbers) should be left undefined.

 -- Method: object.__add__ (self, other)
 -- Method: object.__sub__ (self, other)
 -- Method: object.__mul__ (self, other)
 -- Method: object.__truediv__ (self, other)
 -- Method: object.__floordiv__ (self, other)
 -- Method: object.__mod__ (self, other)
 -- Method: object.__divmod__ (self, other)
 -- Method: object.__pow__ (self, other[, modulo])
 -- Method: object.__lshift__ (self, other)
 -- Method: object.__rshift__ (self, other)
 -- Method: object.__and__ (self, other)
 -- Method: object.__xor__ (self, other)
 -- Method: object.__or__ (self, other)

     These methods are called to implement the binary arithmetic
     operations (‘+’, ‘-’, ‘*’, ‘/’, ‘//’, ‘%’, *note divmod(): c40,
     *note pow(): 8e0, ‘**’, ‘<<’, ‘>>’, ‘&’, ‘^’, ‘|’).  For instance,
     to evaluate the expression ‘x + y’, where `x' is an instance of a
     class that has an *note __add__(): c2c. method, ‘x.__add__(y)’ is
     called.  The *note __divmod__(): c39. method should be the
     equivalent to using *note __floordiv__(): 8c4. and *note __mod__():
     c38.; it should not be related to *note __truediv__(): 8c3.  Note
     that *note __pow__(): c3a. should be defined to accept an optional
     third argument if the ternary version of the built-in *note pow():
     8e0. function is to be supported.

     If one of those methods does not support the operation with the
     supplied arguments, it should return ‘NotImplemented’.

 -- Method: object.__radd__ (self, other)
 -- Method: object.__rsub__ (self, other)
 -- Method: object.__rmul__ (self, other)
 -- Method: object.__rtruediv__ (self, other)
 -- Method: object.__rfloordiv__ (self, other)
 -- Method: object.__rmod__ (self, other)
 -- Method: object.__rdivmod__ (self, other)
 -- Method: object.__rpow__ (self, other)
 -- Method: object.__rlshift__ (self, other)
 -- Method: object.__rrshift__ (self, other)
 -- Method: object.__rand__ (self, other)
 -- Method: object.__rxor__ (self, other)
 -- Method: object.__ror__ (self, other)

     These methods are called to implement the binary arithmetic
     operations (‘+’, ‘-’, ‘*’, ‘/’, ‘//’, ‘%’, *note divmod(): c40,
     *note pow(): 8e0, ‘**’, ‘<<’, ‘>>’, ‘&’, ‘^’, ‘|’) with reflected
     (swapped) operands.  These functions are only called if the left
     operand does not support the corresponding operation and the
     operands are of different types.  (1) For instance, to evaluate the
     expression ‘x - y’, where `y' is an instance of a class that has an
     *note __rsub__(): c41. method, ‘y.__rsub__(x)’ is called if
     ‘x.__sub__(y)’ returns `NotImplemented'.

     Note that ternary *note pow(): 8e0. will not try calling *note
     __rpow__(): c46. (the coercion rules would become too complicated).

          Note: If the right operand’s type is a subclass of the left
          operand’s type and that subclass provides the reflected method
          for the operation, this method will be called before the left
          operand’s non-reflected method.  This behavior allows
          subclasses to override their ancestors’ operations.

 -- Method: object.__iadd__ (self, other)
 -- Method: object.__isub__ (self, other)
 -- Method: object.__imul__ (self, other)
 -- Method: object.__itruediv__ (self, other)
 -- Method: object.__ifloordiv__ (self, other)
 -- Method: object.__imod__ (self, other)
 -- Method: object.__ipow__ (self, other[, modulo])
 -- Method: object.__ilshift__ (self, other)
 -- Method: object.__irshift__ (self, other)
 -- Method: object.__iand__ (self, other)
 -- Method: object.__ixor__ (self, other)
 -- Method: object.__ior__ (self, other)

     These methods are called to implement the augmented arithmetic
     assignments (‘+=’, ‘-=’, ‘*=’, ‘/=’, ‘//=’, ‘%=’, ‘**=’, ‘<<=’,
     ‘>>=’, ‘&=’, ‘^=’, ‘|=’).  These methods should attempt to do the
     operation in-place (modifying `self') and return the result (which
     could be, but does not have to be, `self').  If a specific method
     is not defined, the augmented assignment falls back to the normal
     methods.  For instance, if `x' is an instance of a class with an
     *note __iadd__(): 902. method, ‘x += y’ is equivalent to ‘x =
     x.__iadd__(y)’ .  Otherwise, ‘x.__add__(y)’ and ‘y.__radd__(x)’ are
     considered, as with the evaluation of ‘x + y’.  In certain
     situations, augmented assignment can result in unexpected errors
     (see *note Why does a_tuple[i] += [’item’] raise an exception when
     the addition works?: c55.), but this behavior is in fact part of
     the data model.

 -- Method: object.__neg__ (self)
 -- Method: object.__pos__ (self)
 -- Method: object.__abs__ (self)
 -- Method: object.__invert__ (self)

     Called to implement the unary arithmetic operations (‘-’, ‘+’,
     *note abs(): aaa. and ‘~’).

 -- Method: object.__complex__ (self)
 -- Method: object.__int__ (self)
 -- Method: object.__float__ (self)
 -- Method: object.__round__ (self[, n])

     Called to implement the built-in functions *note complex(): 326,
     *note int(): 185, *note float(): 327. and *note round(): 6d1.
     Should return a value of the appropriate type.

 -- Method: object.__index__ (self)

     Called to implement *note operator.index(): c5c, and whenever
     Python needs to losslessly convert the numeric object to an integer
     object (such as in slicing, or in the built-in *note bin(): 69b,
     *note hex(): 6c9. and *note oct(): 6c8. functions).  Presence of
     this method indicates that the numeric object is an integer type.
     Must return an integer.

          Note: In order to have a coherent integer type class, when
          *note __index__(): 6ca. is defined *note __int__(): 727.
          should also be defined, and both should return the same value.

   ---------- Footnotes ----------

   (1) For operands of the same type, it is assumed that if the
non-reflected method (such as *note __add__(): c2c.) fails the operation
is not supported, which is why the reflected method is not called.


File: python.info,  Node: With Statement Context Managers,  Next: Special method lookup,  Prev: Emulating numeric types,  Up: Special method names

4.3.3.17 With Statement Context Managers
........................................

A `context manager' is an object that defines the runtime context to be
established when executing a *note with: 19b. statement.  The context
manager handles the entry into, and the exit from, the desired runtime
context for the execution of the block of code.  Context managers are
normally invoked using the *note with: 19b. statement (described in
section *note The with statement: 19b.), but can also be used by
directly invoking their methods.

Typical uses of context managers include saving and restoring various
kinds of global state, locking and unlocking resources, closing opened
files, etc.

For more information on context managers, see *note Context Manager
Types: c5f.

 -- Method: object.__enter__ (self)

     Enter the runtime context related to this object.  The *note with:
     19b. statement will bind this method’s return value to the
     target(s) specified in the *note as: 69e. clause of the statement,
     if any.

 -- Method: object.__exit__ (self, exc_type, exc_value, traceback)

     Exit the runtime context related to this object.  The parameters
     describe the exception that caused the context to be exited.  If
     the context was exited without an exception, all three arguments
     will be *note None: 2c6.

     If an exception is supplied, and the method wishes to suppress the
     exception (i.e., prevent it from being propagated), it should
     return a true value.  Otherwise, the exception will be processed
     normally upon exit from this method.

     Note that *note __exit__(): 703. methods should not reraise the
     passed-in exception; this is the caller’s responsibility.

See also
........

PEP 0343(1) - The "with" statement

     The specification, background, and examples for the Python *note
     with: 19b. statement.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0343


File: python.info,  Node: Special method lookup,  Prev: With Statement Context Managers,  Up: Special method names

4.3.3.18 Special method lookup
..............................

For custom classes, implicit invocations of special methods are only
guaranteed to work correctly if defined on an object’s type, not in the
object’s instance dictionary.  That behaviour is the reason why the
following code raises an exception:

     >>> class C:
     ...     pass
     ...
     >>> c = C()
     >>> c.__len__ = lambda: 5
     >>> len(c)
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
     TypeError: object of type 'C' has no len()

The rationale behind this behaviour lies with a number of special
methods such as *note __hash__(): 39f. and *note __repr__(): 5a3. that
are implemented by all objects, including type objects.  If the implicit
lookup of these methods used the conventional lookup process, they would
fail when invoked on the type object itself:

     >>> 1 .__hash__() == hash(1)
     True
     >>> int.__hash__() == hash(int)
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
     TypeError: descriptor '__hash__' of 'int' object needs an argument

Incorrectly attempting to invoke an unbound method of a class in this
way is sometimes referred to as ’metaclass confusion’, and is avoided by
bypassing the instance when looking up special methods:

     >>> type(1).__hash__(1) == hash(1)
     True
     >>> type(int).__hash__(int) == hash(int)
     True

In addition to bypassing any instance attributes in the interest of
correctness, implicit special method lookup generally also bypasses the
*note __getattribute__(): 561. method even of the object’s metaclass:

     >>> class Meta(type):
     ...    def __getattribute__(*args):
     ...       print("Metaclass getattribute invoked")
     ...       return type.__getattribute__(*args)
     ...
     >>> class C(object, metaclass=Meta):
     ...     def __len__(self):
     ...         return 10
     ...     def __getattribute__(*args):
     ...         print("Class getattribute invoked")
     ...         return object.__getattribute__(*args)
     ...
     >>> c = C()
     >>> c.__len__()                 # Explicit lookup via instance
     Class getattribute invoked
     10
     >>> type(c).__len__(c)          # Explicit lookup via type
     Metaclass getattribute invoked
     10
     >>> len(c)                      # Implicit lookup
     10

Bypassing the *note __getattribute__(): 561. machinery in this fashion
provides significant scope for speed optimisations within the
interpreter, at the cost of some flexibility in the handling of special
methods (the special method `must' be set on the class object itself in
order to be consistently invoked by the interpreter).


File: python.info,  Node: Execution model,  Next: The import system,  Prev: Data model,  Up: The Python Language Reference

4.4 Execution model
===================

* Menu:

* Naming and binding:: 
* Exceptions: Exceptions<2>. 


File: python.info,  Node: Naming and binding,  Next: Exceptions<2>,  Up: Execution model

4.4.1 Naming and binding
------------------------

`Names' refer to objects.  Names are introduced by name binding
operations.  Each occurrence of a name in the program text refers to the
`binding' of that name established in the innermost function block
containing the use.

A `block' is a piece of Python program text that is executed as a unit.
The following are blocks: a module, a function body, and a class
definition.  Each command typed interactively is a block.  A script file
(a file given as standard input to the interpreter or specified as a
command line argument to the interpreter) is a code block.  A script
command (a command specified on the interpreter command line with the
’`-c'’ option) is a code block.  The string argument passed to the
built-in functions *note eval(): 5d2. and *note exec(): 6a0. is a code
block.

A code block is executed in an `execution frame'.  A frame contains some
administrative information (used for debugging) and determines where and
how execution continues after the code block’s execution has completed.

A `scope' defines the visibility of a name within a block.  If a local
variable is defined in a block, its scope includes that block.  If the
definition occurs in a function block, the scope extends to any blocks
contained within the defining one, unless a contained block introduces a
different binding for the name.  The scope of names defined in a class
block is limited to the class block; it does not extend to the code
blocks of methods – this includes comprehensions and generator
expressions since they are implemented using a function scope.  This
means that the following will fail:

     class A:
         a = 42
         b = list(a + i for i in range(10))

When a name is used in a code block, it is resolved using the nearest
enclosing scope.  The set of all such scopes visible to a code block is
called the block’s `environment'.

If a name is bound in a block, it is a local variable of that block,
unless declared as *note nonlocal: 69a.  If a name is bound at the
module level, it is a global variable.  (The variables of the module
code block are local and global.)  If a variable is used in a code block
but not defined there, it is a `free variable'.

When a name is not found at all, a *note NameError: 7f8. exception is
raised.  If the name refers to a local variable that has not been bound,
an *note UnboundLocalError: 909. exception is raised.  *note
UnboundLocalError: 909. is a subclass of *note NameError: 7f8.

The following constructs bind names: formal parameters to functions,
*note import: 674. statements, class and function definitions (these
bind the class or function name in the defining block), and targets that
are identifiers if occurring in an assignment, *note for: 688. loop
header, or after *note as: 69e. in a *note with: 19b. statement or *note
except: 563. clause.  The *note import: 674. statement of the form ‘from
... import *’ binds all names defined in the imported module, except
those beginning with an underscore.  This form may only be used at the
module level.

A target occurring in a *note del: a5d. statement is also considered
bound for this purpose (though the actual semantics are to unbind the
name).

Each assignment or import statement occurs within a block defined by a
class or function definition or at the module level (the top-level code
block).

If a name binding operation occurs anywhere within a code block, all
uses of the name within the block are treated as references to the
current block.  This can lead to errors when a name is used within a
block before it is bound.  This rule is subtle.  Python lacks
declarations and allows name binding operations to occur anywhere within
a code block.  The local variables of a code block can be determined by
scanning the entire text of the block for name binding operations.

If the *note global: a38. statement occurs within a block, all uses of
the name specified in the statement refer to the binding of that name in
the top-level namespace.  Names are resolved in the top-level namespace
by searching the global namespace, i.e.  the namespace of the module
containing the code block, and the builtins namespace, the namespace of
the module *note builtins: 13.  The global namespace is searched first.
If the name is not found there, the builtins namespace is searched.  The
*note global: a38. statement must precede all uses of the name.

The builtins namespace associated with the execution of a code block is
actually found by looking up the name ‘__builtins__’ in its global
namespace; this should be a dictionary or a module (in the latter case
the module’s dictionary is used).  By default, when in the *note
__main__: 1. module, ‘__builtins__’ is the built-in module *note
builtins: 13.; when in any other module, ‘__builtins__’ is an alias for
the dictionary of the *note builtins: 13. module itself.  ‘__builtins__’
can be set to a user-created dictionary to create a weak form of
restricted execution.

`CPython implementation detail:' Users should not touch ‘__builtins__’;
it is strictly an implementation detail.  Users wanting to override
values in the builtins namespace should *note import: 674. the *note
builtins: 13. module and modify its attributes appropriately.

The namespace for a module is automatically created the first time a
module is imported.  The main module for a script is always called *note
__main__: 1.

The *note global: a38. statement has the same scope as a name binding
operation in the same block.  If the nearest enclosing scope for a free
variable contains a global statement, the free variable is treated as a
global.

A class definition is an executable statement that may use and define
names.  These references follow the normal rules for name resolution.
The namespace of the class definition becomes the attribute dictionary
of the class.  Names defined at the class scope are not visible in
methods.

* Menu:

* Interaction with dynamic features:: 


File: python.info,  Node: Interaction with dynamic features,  Up: Naming and binding

4.4.1.1 Interaction with dynamic features
.........................................

There are several cases where Python statements are illegal when used in
conjunction with nested scopes that contain free variables.

If a variable is referenced in an enclosing scope, it is illegal to
delete the name.  An error will be reported at compile time.

If the wild card form of import — ‘import *’ — is used in a function and
the function contains or is a nested block with free variables, the
compiler will raise a *note SyntaxError: 319.

The *note eval(): 5d2. and *note exec(): 6a0. functions do not have
access to the full environment for resolving names.  Names may be
resolved in the local and global namespaces of the caller.  Free
variables are not resolved in the nearest enclosing namespace, but in
the global namespace.  (1) The *note exec(): 6a0. and *note eval(): 5d2.
functions have optional arguments to override the global and local
namespace.  If only one namespace is specified, it is used for both.

   ---------- Footnotes ----------

   (1) This limitation occurs because the code that is executed by these
operations is not available at the time the module is compiled.


File: python.info,  Node: Exceptions<2>,  Prev: Naming and binding,  Up: Execution model

4.4.2 Exceptions
----------------

Exceptions are a means of breaking out of the normal flow of control of
a code block in order to handle errors or other exceptional conditions.
An exception is `raised' at the point where the error is detected; it
may be `handled' by the surrounding code block or by any code block that
directly or indirectly invoked the code block where the error occurred.

The Python interpreter raises an exception when it detects a run-time
error (such as division by zero).  A Python program can also explicitly
raise an exception with the *note raise: 69d. statement.  Exception
handlers are specified with the *note try: 7ee. ...  *note except: 563.
statement.  The *note finally: 2c5. clause of such a statement can be
used to specify cleanup code which does not handle the exception, but is
executed whether an exception occurred or not in the preceding code.

Python uses the "termination" model of error handling: an exception
handler can find out what happened and continue execution at an outer
level, but it cannot repair the cause of the error and retry the failing
operation (except by re-entering the offending piece of code from the
top).

When an exception is not handled at all, the interpreter terminates
execution of the program, or returns to its interactive main loop.  In
either case, it prints a stack backtrace, except when the exception is
*note SystemExit: 6bf.

Exceptions are identified by class instances.  The *note except: 563.
clause is selected depending on the class of the instance: it must
reference the class of the instance or a base class thereof.  The
instance can be received by the handler and can carry additional
information about the exceptional condition.

     Note: Exception messages are not part of the Python API. Their
     contents may change from one version of Python to the next without
     warning and should not be relied on by code which will run under
     multiple versions of the interpreter.

See also the description of the *note try: 7ee. statement in section
*note The try statement: 7ee. and *note raise: 69d. statement in section
*note The raise statement: 69d.


File: python.info,  Node: The import system,  Next: Expressions,  Prev: Execution model,  Up: The Python Language Reference

4.5 The import system
=====================

Python code in one *note module: c6c. gains access to the code in
another module by the process of *note importing: c6d. it.  The *note
import: 674. statement is the most common way of invoking the import
machinery, but it is not the only way.  Functions such as *note
importlib.import_module(): 52a. and built-in *note __import__(): 383.
can also be used to invoke the import machinery.

The *note import: 674. statement combines two operations; it searches
for the named module, then it binds the results of that search to a name
in the local scope.  The search operation of the *note import: 674.
statement is defined as a call to the *note __import__(): 383. function,
with the appropriate arguments.  The return value of *note __import__():
383. is used to perform the name binding operation of the *note import:
674. statement.  See the *note import: 674. statement for the exact
details of that name binding operation.

A direct call to *note __import__(): 383. performs only the module
search and, if found, the module creation operation.  While certain
side-effects may occur, such as the importing of parent packages, and
the updating of various caches (including *note sys.modules: c6e.), only
the *note import: 674. statement performs a name binding operation.

When calling *note __import__(): 383. as part of an import statement,
the import system first checks the module global namespace for a
function by that name.  If it is not found, then the standard builtin
*note __import__(): 383. is called.  Other mechanisms for invoking the
import system (such as *note importlib.import_module(): 52a.) do not
perform this check and will always use the standard import system.

When a module is first imported, Python searches for the module and if
found, it creates a module object (1), initializing it.  If the named
module cannot be found, an *note ImportError: 318. is raised.  Python
implements various strategies to search for the named module when the
import machinery is invoked.  These strategies can be modified and
extended by using various hooks described in the sections below.

Changed in version 3.3: The import system has been updated to fully
implement the second phase of PEP 302(2).  There is no longer any
implicit import machinery - the full import system is exposed through
*note sys.meta_path: 392.  In addition, native namespace package support
has been implemented (see PEP 420(3)).

* Menu:

* importlib: importlib<2>. 
* Packages: Packages<2>. 
* Searching:: 
* Loading:: 
* The Path Based Finder:: 
* Replacing the standard import system:: 
* Special considerations for __main__:: 
* Open issues:: 
* References:: 

   ---------- Footnotes ----------

   (1) See *note types.ModuleType: c6f.

   (2) https://www.python.org/dev/peps/pep-0302

   (3) https://www.python.org/dev/peps/pep-0420


File: python.info,  Node: importlib<2>,  Next: Packages<2>,  Up: The import system

4.5.1 ‘importlib’
-----------------

The *note importlib: 99. module provides a rich API for interacting with
the import system.  For example *note importlib.import_module(): 52a.
provides a recommended, simpler API than built-in *note __import__():
383. for invoking the import machinery.  Refer to the *note importlib:
99. library documentation for additional detail.


File: python.info,  Node: Packages<2>,  Next: Searching,  Prev: importlib<2>,  Up: The import system

4.5.2 Packages
--------------

Python has only one type of module object, and all modules are of this
type, regardless of whether the module is implemented in Python, C, or
something else.  To help organize modules and provide a naming
hierarchy, Python has a concept of *note packages: c72.

You can think of packages as the directories on a file system and
modules as files within directories, but don’t take this analogy too
literally since packages and modules need not originate from the file
system.  For the purposes of this documentation, we’ll use this
convenient analogy of directories and files.  Like file system
directories, packages are organized hierarchically, and packages may
themselves contain subpackages, as well as regular modules.

It’s important to keep in mind that all packages are modules, but not
all modules are packages.  Or put another way, packages are just a
special kind of module.  Specifically, any module that contains a
‘__path__’ attribute is considered a package.

All modules have a name.  Subpackage names are separated from their
parent package name by dots, akin to Python’s standard attribute access
syntax.  Thus you might have a module called *note sys: f8. and a
package called *note email: 67, which in turn has a subpackage called
*note email.mime: 71. and a module within that subpackage called
‘email.mime.text’.

* Menu:

* Regular packages:: 
* Namespace packages:: 


File: python.info,  Node: Regular packages,  Next: Namespace packages,  Up: Packages<2>

4.5.2.1 Regular packages
........................

Python defines two types of packages, *note regular packages: c74. and
*note namespace packages: c75.  Regular packages are traditional
packages as they existed in Python 3.2 and earlier.  A regular package
is typically implemented as a directory containing an ‘__init__.py’
file.  When a regular package is imported, this ‘__init__.py’ file is
implicitly executed, and the objects it defines are bound to names in
the package’s namespace.  The ‘__init__.py’ file can contain the same
Python code that any other module can contain, and Python will add some
additional attributes to the module when it is imported.

For example, the following file system layout defines a top level
‘parent’ package with three subpackages:

     parent/
         __init__.py
         one/
             __init__.py
         two/
             __init__.py
         three/
             __init__.py

Importing ‘parent.one’ will implicitly execute ‘parent/__init__.py’ and
‘parent/one/__init__.py’.  Subsequent imports of ‘parent.two’ or
‘parent.three’ will execute ‘parent/two/__init__.py’ and
‘parent/three/__init__.py’ respectively.


File: python.info,  Node: Namespace packages,  Prev: Regular packages,  Up: Packages<2>

4.5.2.2 Namespace packages
..........................

A namespace package is a composite of various *note portions: c77, where
each portion contributes a subpackage to the parent package.  Portions
may reside in different locations on the file system.  Portions may also
be found in zip files, on the network, or anywhere else that Python
searches during import.  Namespace packages may or may not correspond
directly to objects on the file system; they may be virtual modules that
have no concrete representation.

Namespace packages do not use an ordinary list for their ‘__path__’
attribute.  They instead use a custom iterable type which will
automatically perform a new search for package portions on the next
import attempt within that package if the path of their parent package
(or *note sys.path: 2d5. for a top level package) changes.

With namespace packages, there is no ‘parent/__init__.py’ file.  In
fact, there may be multiple ‘parent’ directories found during import
search, where each one is provided by a different portion.  Thus
‘parent/one’ may not be physically located next to ‘parent/two’.  In
this case, Python will create a namespace package for the top-level
‘parent’ package whenever it or one of its subpackages is imported.

See also PEP 420(1) for the namespace package specification.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0420


File: python.info,  Node: Searching,  Next: Loading,  Prev: Packages<2>,  Up: The import system

4.5.3 Searching
---------------

To begin the search, Python needs the *note fully qualified: c00. name
of the module (or package, but for the purposes of this discussion, the
difference is immaterial) being imported.  This name may come from
various arguments to the *note import: 674. statement, or from the
parameters to the *note importlib.import_module(): 52a. or *note
__import__(): 383. functions.

This name will be used in various phases of the import search, and it
may be the dotted path to a submodule, e.g.  ‘foo.bar.baz’.  In this
case, Python first tries to import ‘foo’, then ‘foo.bar’, and finally
‘foo.bar.baz’.  If any of the intermediate imports fail, an *note
ImportError: 318. is raised.

* Menu:

* The module cache:: 
* Finders and loaders:: 
* Import hooks:: 
* The meta path:: 

