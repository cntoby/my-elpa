This is python.info, produced by makeinfo version 5.2 from python.texi.

     Python 3.4.3, September 02, 2015

     Copyright © 1990-2015, Python Software Foundation

INFO-DIR-SECTION Python
START-INFO-DIR-ENTRY
* Python: (python.info). The Python reference manual.
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.3.1.


File: python.info,  Node: The module cache,  Next: Finders and loaders,  Up: Searching

4.5.3.1 The module cache
........................

The first place checked during import search is *note sys.modules: c6e.
This mapping serves as a cache of all modules that have been previously
imported, including the intermediate paths.  So if ‘foo.bar.baz’ was
previously imported, *note sys.modules: c6e. will contain entries for
‘foo’, ‘foo.bar’, and ‘foo.bar.baz’.  Each key will have as its value
the corresponding module object.

During import, the module name is looked up in *note sys.modules: c6e.
and if present, the associated value is the module satisfying the
import, and the process completes.  However, if the value is ‘None’,
then an *note ImportError: 318. is raised.  If the module name is
missing, Python will continue searching for the module.

*note sys.modules: c6e. is writable.  Deleting a key may not destroy the
associated module (as other modules may hold references to it), but it
will invalidate the cache entry for the named module, causing Python to
search anew for the named module upon its next import.  The key can also
be assigned to ‘None’, forcing the next import of the module to result
in an *note ImportError: 318.

Beware though, as if you keep a reference to the module object,
invalidate its cache entry in *note sys.modules: c6e, and then re-import
the named module, the two module objects will `not' be the same.  By
contrast, *note imp.reload(): 6d4. will reuse the `same' module object,
and simply reinitialise the module contents by rerunning the module’s
code.


File: python.info,  Node: Finders and loaders,  Next: Import hooks,  Prev: The module cache,  Up: Searching

4.5.3.2 Finders and loaders
...........................

If the named module is not found in *note sys.modules: c6e, then
Python’s import protocol is invoked to find and load the module.  This
protocol consists of two conceptual objects, *note finders: c7b. and
*note loaders: c7c.  A finder’s job is to determine whether it can find
the named module using whatever strategy it knows about.  Objects that
implement both of these interfaces are referred to as *note importers:
c7d. - they return themselves when they find that they can load the
requested module.

Python includes a number of default finders and importers.  The first
one knows how to locate built-in modules, and the second knows how to
locate frozen modules.  A third default finder searches an *note import
path: c7e. for modules.  The *note import path: c7e. is a list of
locations that may name file system paths or zip files.  It can also be
extended to search for any locatable resource, such as those identified
by URLs.

The import machinery is extensible, so new finders can be added to
extend the range and scope of module searching.

Finders do not actually load modules.  If they can find the named
module, they return a `module spec', an encapsulation of the module’s
import-related information, which the import machinery then uses when
loading the module.

The following sections describe the protocol for finders and loaders in
more detail, including how you can create and register new ones to
extend the import machinery.

Changed in version 3.4: In previous versions of Python, finders returned
*note loaders: c7c. directly, whereas now they return module specs which
`contain' loaders.  Loaders are still used during import but have fewer
responsibilities.


File: python.info,  Node: Import hooks,  Next: The meta path,  Prev: Finders and loaders,  Up: Searching

4.5.3.3 Import hooks
....................

The import machinery is designed to be extensible; the primary mechanism
for this are the `import hooks'.  There are two types of import hooks:
`meta hooks' and `import path hooks'.

Meta hooks are called at the start of import processing, before any
other import processing has occurred, other than *note sys.modules: c6e.
cache look up.  This allows meta hooks to override *note sys.path: 2d5.
processing, frozen modules, or even built-in modules.  Meta hooks are
registered by adding new finder objects to *note sys.meta_path: 392, as
described below.

Import path hooks are called as part of *note sys.path: 2d5. (or
‘package.__path__’) processing, at the point where their associated path
item is encountered.  Import path hooks are registered by adding new
callables to *note sys.path_hooks: 31d. as described below.


File: python.info,  Node: The meta path,  Prev: Import hooks,  Up: Searching

4.5.3.4 The meta path
.....................

When the named module is not found in *note sys.modules: c6e, Python
next searches *note sys.meta_path: 392, which contains a list of meta
path finder objects.  These finders are queried in order to see if they
know how to handle the named module.  Meta path finders must implement a
method called *note find_spec(): 2e8. which takes three arguments: a
name, an import path, and (optionally) a target module.  The meta path
finder can use any strategy it wants to determine whether it can handle
the named module or not.

If the meta path finder knows how to handle the named module, it returns
a spec object.  If it cannot handle the named module, it returns ‘None’.
If *note sys.meta_path: 392. processing reaches the end of its list
without returning a spec, then an *note ImportError: 318. is raised.
Any other exceptions raised are simply propagated up, aborting the
import process.

The *note find_spec(): 2e8. method of meta path finders is called with
two or three arguments.  The first is the fully qualified name of the
module being imported, for example ‘foo.bar.baz’.  The second argument
is the path entries to use for the module search.  For top-level
modules, the second argument is ‘None’, but for submodules or
subpackages, the second argument is the value of the parent package’s
‘__path__’ attribute.  If the appropriate ‘__path__’ attribute cannot be
accessed, an *note ImportError: 318. is raised.  The third argument is
an existing module object that will be the target of loading later.  The
import system passes in a target module only during reload.

The meta path may be traversed multiple times for a single import
request.  For example, assuming none of the modules involved has already
been cached, importing ‘foo.bar.baz’ will first perform a top level
import, calling ‘mpf.find_spec("foo", None, None)’ on each meta path
finder (‘mpf’).  After ‘foo’ has been imported, ‘foo.bar’ will be
imported by traversing the meta path a second time, calling
‘mpf.find_spec("foo.bar", foo.__path__, None)’.  Once ‘foo.bar’ has been
imported, the final traversal will call ‘mpf.find_spec("foo.bar.baz",
foo.bar.__path__, None)’.

Some meta path finders only support top level imports.  These importers
will always return ‘None’ when anything other than ‘None’ is passed as
the second argument.

Python’s default *note sys.meta_path: 392. has three meta path finders,
one that knows how to import built-in modules, one that knows how to
import frozen modules, and one that knows how to import modules from an
*note import path: c7e. (i.e.  the *note path based finder: c81.).

Changed in version 3.4: The *note find_spec(): 2e8. method of meta path
finders replaced *note find_module(): 2e7, which is now deprecated.
While it will continue to work without change, the import machinery will
try it only if the finder does not implement ‘find_spec()’.


File: python.info,  Node: Loading,  Next: The Path Based Finder,  Prev: Searching,  Up: The import system

4.5.4 Loading
-------------

If and when a module spec is found, the import machinery will use it
(and the loader it contains) when loading the module.  Here is an
approximation of what happens during the loading portion of import:

     module = None
     if spec.loader is not None and hasattr(spec.loader, 'create_module'):
         module = spec.loader.create_module(spec)
     if module is None:
         module = ModuleType(spec.name)
     # The import-related module attributes get set here:
     _init_module_attrs(spec, module)

     if spec.loader is None:
         if spec.submodule_search_locations is not None:
             # namespace package
             sys.modules[spec.name] = module
         else:
             # unsupported
             raise ImportError
     elif not hasattr(spec.loader, 'exec_module'):
         module = spec.loader.load_module(spec.name)
         # Set __loader__ and __package__ if missing.
     else:
         sys.modules[spec.name] = module
         try:
             spec.loader.exec_module(module)
         except BaseException:
             try:
                 del sys.modules[spec.name]
             except KeyError:
                 pass
             raise
     return sys.modules[spec.name]

Note the following details:

        * If there is an existing module object with the given name in
          *note sys.modules: c6e, import will have already returned it.

        * The module will exist in *note sys.modules: c6e. before the
          loader executes the module code.  This is crucial because the
          module code may (directly or indirectly) import itself; adding
          it to *note sys.modules: c6e. beforehand prevents unbounded
          recursion in the worst case and multiple loading in the best.

        * If loading fails, the failing module – and only the failing
          module – gets removed from *note sys.modules: c6e.  Any module
          already in the *note sys.modules: c6e. cache, and any module
          that was successfully loaded as a side-effect, must remain in
          the cache.  This contrasts with reloading where even the
          failing module is left in *note sys.modules: c6e.

        * After the module is created but before execution, the import
          machinery sets the import-related module attributes
          ("_init_module_attrs" in the pseudo-code example above), as
          summarized in a *note later section: c83.

        * Module execution is the key moment of loading in which the
          module’s namespace gets populated.  Execution is entirely
          delegated to the loader, which gets to decide what gets
          populated and how.

        * The module created during loading and passed to exec_module()
          may not be the one returned at the end of import (1).

Changed in version 3.4: The import system has taken over the boilerplate
responsibilities of loaders.  These were previously performed by the
*note importlib.abc.Loader.load_module(): 2ec. method.

* Menu:

* Loaders:: 
* Module spec:: 
* Import-related module attributes:: 
* module.__path__: module __path__. 
* Module reprs:: 

   ---------- Footnotes ----------

   (1) The importlib implementation avoids using the return value
directly.  Instead, it gets the module object by looking the module name
up in *note sys.modules: c6e.  The indirect effect of this is that an
imported module may replace itself in *note sys.modules: c6e.  This is
implementation-specific behavior that is not guaranteed to work in other
Python implementations.


File: python.info,  Node: Loaders,  Next: Module spec,  Up: Loading

4.5.4.1 Loaders
...............

Module loaders provide the critical function of loading: module
execution.  The import machinery calls the *note
importlib.abc.Loader.exec_module(): 2f0. method with a single argument,
the module object to execute.  Any value returned from *note
exec_module(): 2f0. is ignored.

Loaders must satisfy the following requirements:

        * If the module is a Python module (as opposed to a built-in
          module or a dynamically loaded extension), the loader should
          execute the module’s code in the module’s global name space
          (‘module.__dict__’).

        * If the loader cannot execute the module, it should raise an
          *note ImportError: 318, although any other exception raised
          during *note exec_module(): 2f0. will be propagated.

In many cases, the finder and loader can be the same object; in such
cases the *note find_spec(): 2e8. method would just return a spec with
the loader set to ‘self’.

Module loaders may opt in to creating the module object during loading
by implementing a *note create_module(): c85. method.  It takes one
argument, the module spec, and returns the new module object to use
during loading.  ‘create_module()’ does not need to set any attributes
on the module object.  If the loader does not define ‘create_module()’,
the import machinery will create the new module itself.

New in version 3.4: The create_module() method of loaders.

Changed in version 3.4: The *note load_module(): 2ec. method was
replaced by *note exec_module(): 2f0. and the import machinery assumed
all the boilerplate responsibilities of loading.

For compatibility with existing loaders, the import machinery will use
the ‘load_module()’ method of loaders if it exists and the loader does
not also implement ‘exec_module()’.  However, ‘load_module()’ has been
deprecated and loaders should implement ‘exec_module()’ instead.

The ‘load_module()’ method must implement all the boilerplate loading
functionality described above in addition to executing the module.  All
the same constraints apply, with some additional clarification:

        * If there is an existing module object with the given name in
          *note sys.modules: c6e, the loader must use that existing
          module.  (Otherwise, *note importlib.reload(): 1ed. will not
          work correctly.)  If the named module does not exist in *note
          sys.modules: c6e, the loader must create a new module object
          and add it to *note sys.modules: c6e.

        * The module `must' exist in *note sys.modules: c6e. before the
          loader executes the module code, to prevent unbounded
          recursion or multiple loading.

        * If loading fails, the loader must remove any modules it has
          inserted into *note sys.modules: c6e, but it must remove
          `only' the failing module, and only if the loader itself has
          loaded it explicitly.


File: python.info,  Node: Module spec,  Next: Import-related module attributes,  Prev: Loaders,  Up: Loading

4.5.4.2 Module spec
...................

The import machinery uses a variety of information about each module
during import, especially before loading.  Most of the information is
common to all modules.  The purpose of a module’s spec is to encapsulate
this import-related information on a per-module basis.

Using a spec during import allows state to be transferred between import
system components, e.g.  between the finder that creates the module spec
and the loader that executes it.  Most importantly, it allows the import
machinery to perform the boilerplate operations of loading, whereas
without a module spec the loader had that responsibility.

See *note ModuleSpec: c87. for more specifics on what information a
module’s spec may hold.

New in version 3.4.


File: python.info,  Node: Import-related module attributes,  Next: module __path__,  Prev: Module spec,  Up: Loading

4.5.4.3 Import-related module attributes
........................................

The import machinery fills in these attributes on each module object
during loading, based on the module’s spec, before the loader executes
the module.

 -- Attribute: __name__

     The ‘__name__’ attribute must be set to the fully-qualified name of
     the module.  This name is used to uniquely identify the module in
     the import system.

 -- Attribute: __loader__

     The ‘__loader__’ attribute must be set to the loader object that
     the import machinery used when loading the module.  This is mostly
     for introspection, but can be used for additional loader-specific
     functionality, for example getting data associated with a loader.

 -- Attribute: __package__

     The module’s ‘__package__’ attribute must be set.  Its value must
     be a string, but it can be the same value as its ‘__name__’.  When
     the module is a package, its ‘__package__’ value should be set to
     its ‘__name__’.  When the module is not a package, ‘__package__’
     should be set to the empty string for top-level modules, or for
     submodules, to the parent package’s name.  See PEP 366(1) for
     further details.

     This attribute is used instead of ‘__name__’ to calculate explicit
     relative imports for main modules, as defined in PEP 366(2).

 -- Attribute: __spec__

     The ‘__spec__’ attribute must be set to the module spec that was
     used when importing the module.  This is used primarily for
     introspection and during reloading.  Setting ‘__spec__’
     appropriately applies equally to *note modules initialized during
     interpreter startup: c8a.  The one exception is ‘__main__’, where
     ‘__spec__’ is *note set to None in some cases: c8b.

     New in version 3.4.

 -- Attribute: __path__

     If the module is a package (either regular or namespace), the
     module object’s ‘__path__’ attribute must be set.  The value must
     be iterable, but may be empty if ‘__path__’ has no further
     significance.  If ‘__path__’ is not empty, it must produce strings
     when iterated over.  More details on the semantics of ‘__path__’
     are given *note below: c8c.

     Non-package modules should not have a ‘__path__’ attribute.

 -- Attribute: __file__

 -- Attribute: __cached__

     ‘__file__’ is optional.  If set, this attribute’s value must be a
     string.  The import system may opt to leave ‘__file__’ unset if it
     has no semantic meaning (e.g.  a module loaded from a database).

     If ‘__file__’ is set, it may also be appropriate to set the
     ‘__cached__’ attribute which is the path to any compiled version of
     the code (e.g.  byte-compiled file).  The file does not need to
     exist to set this attribute; the path can simply point to where the
     compiled file would exist (see PEP 3147(3)).

     It is also appropriate to set ‘__cached__’ when ‘__file__’ is not
     set.  However, that scenario is quite atypical.  Ultimately, the
     loader is what makes use of ‘__file__’ and/or ‘__cached__’.  So if
     a loader can load from a cached module but otherwise does not load
     from a file, that atypical scenario may be appropriate.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0366

   (2) https://www.python.org/dev/peps/pep-0366

   (3) https://www.python.org/dev/peps/pep-3147


File: python.info,  Node: module __path__,  Next: Module reprs,  Prev: Import-related module attributes,  Up: Loading

4.5.4.4 module.__path__
.......................

By definition, if a module has an ‘__path__’ attribute, it is a package,
regardless of its value.

A package’s ‘__path__’ attribute is used during imports of its
subpackages.  Within the import machinery, it functions much the same as
*note sys.path: 2d5, i.e.  providing a list of locations to search for
modules during import.  However, ‘__path__’ is typically much more
constrained than *note sys.path: 2d5.

‘__path__’ must be an iterable of strings, but it may be empty.  The
same rules used for *note sys.path: 2d5. also apply to a package’s
‘__path__’, and *note sys.path_hooks: 31d. (described below) are
consulted when traversing a package’s ‘__path__’.

A package’s ‘__init__.py’ file may set or alter the package’s ‘__path__’
attribute, and this was typically the way namespace packages were
implemented prior to PEP 420(1).  With the adoption of PEP 420(2),
namespace packages no longer need to supply ‘__init__.py’ files
containing only ‘__path__’ manipulation code; the import machinery
automatically sets ‘__path__’ correctly for the namespace package.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0420

   (2) https://www.python.org/dev/peps/pep-0420


File: python.info,  Node: Module reprs,  Prev: module __path__,  Up: Loading

4.5.4.5 Module reprs
....................

By default, all modules have a usable repr, however depending on the
attributes set above, and in the module’s spec, you can more explicitly
control the repr of module objects.

If the module has a spec (‘__spec__’), the import machinery will try to
generate a repr from it.  If that fails or there is no spec, the import
system will craft a default repr using whatever information is available
on the module.  It will try to use the ‘module.__name__’,
‘module.__file__’, and ‘module.__loader__’ as input into the repr, with
defaults for whatever information is missing.

Here are the exact rules used:

        * If the module has a ‘__spec__’ attribute, the information in
          the spec is used to generate the repr.  The "name", "loader",
          "origin", and "has_location" attributes are consulted.

        * If the module has a ‘__file__’ attribute, this is used as part
          of the module’s repr.

        * If the module has no ‘__file__’ but does have a ‘__loader__’
          that is not ‘None’, then the loader’s repr is used as part of
          the module’s repr.

        * Otherwise, just use the module’s ‘__name__’ in the repr.

Changed in version 3.4: Use of *note loader.module_repr(): 2f3. has been
deprecated and the module spec is now used by the import machinery to
generate a module repr.

For backward compatibility with Python 3.3, the module repr will be
generated by calling the loader’s *note module_repr(): 2f3. method, if
defined, before trying either approach described above.  However, the
method is deprecated.


File: python.info,  Node: The Path Based Finder,  Next: Replacing the standard import system,  Prev: Loading,  Up: The import system

4.5.5 The Path Based Finder
---------------------------

As mentioned previously, Python comes with several default meta path
finders.  One of these, called the *note path based finder: c81. (*note
PathFinder: 31c.), searches an *note import path: c7e, which contains a
list of *note path entries: c90.  Each path entry names a location to
search for modules.

The path based finder itself doesn’t know how to import anything.
Instead, it traverses the individual path entries, associating each of
them with a path entry finder that knows how to handle that particular
kind of path.

The default set of path entry finders implement all the semantics for
finding modules on the file system, handling special file types such as
Python source code (‘.py’ files), Python byte code (‘.pyc’ and ‘.pyo’
files) and shared libraries (e.g.  ‘.so’ files).  When supported by the
*note zipimport: 13b. module in the standard library, the default path
entry finders also handle loading all of these file types (other than
shared libraries) from zipfiles.

Path entries need not be limited to file system locations.  They can
refer to URLs, database queries, or any other location that can be
specified as a string.

The path based finder provides additional hooks and protocols so that
you can extend and customize the types of searchable path entries.  For
example, if you wanted to support path entries as network URLs, you
could write a hook that implements HTTP semantics to find modules on the
web.  This hook (a callable) would return a *note path entry finder:
388. supporting the protocol described below, which was then used to get
a loader for the module from the web.

A word of warning: this section and the previous both use the term
`finder', distinguishing between them by using the terms *note meta path
finder: 387. and *note path entry finder: 388.  These two types of
finders are very similar, support similar protocols, and function in
similar ways during the import process, but it’s important to keep in
mind that they are subtly different.  In particular, meta path finders
operate at the beginning of the import process, as keyed off the *note
sys.meta_path: 392. traversal.

By contrast, path entry finders are in a sense an implementation detail
of the path based finder, and in fact, if the path based finder were to
be removed from *note sys.meta_path: 392, none of the path entry finder
semantics would be invoked.

* Menu:

* Path entry finders:: 
* Path entry finder protocol:: 


File: python.info,  Node: Path entry finders,  Next: Path entry finder protocol,  Up: The Path Based Finder

4.5.5.1 Path entry finders
..........................

The *note path based finder: c81. is responsible for finding and loading
Python modules and packages whose location is specified with a string
*note path entry: c90.  Most path entries name locations in the file
system, but they need not be limited to this.

As a meta path finder, the *note path based finder: c81. implements the
*note find_spec(): 2e8. protocol previously described, however it
exposes additional hooks that can be used to customize how modules are
found and loaded from the *note import path: c7e.

Three variables are used by the *note path based finder: c81, *note
sys.path: 2d5, *note sys.path_hooks: 31d. and *note
sys.path_importer_cache: 31e.  The ‘__path__’ attributes on package
objects are also used.  These provide additional ways that the import
machinery can be customized.

*note sys.path: 2d5. contains a list of strings providing search
locations for modules and packages.  It is initialized from the
‘PYTHONPATH’ environment variable and various other installation- and
implementation-specific defaults.  Entries in *note sys.path: 2d5. can
name directories on the file system, zip files, and potentially other
"locations" (see the *note site: e6. module) that should be searched for
modules, such as URLs, or database queries.  Only strings and bytes
should be present on *note sys.path: 2d5.; all other data types are
ignored.  The encoding of bytes entries is determined by the individual
*note path entry finders: 388.

The *note path based finder: c81. is a *note meta path finder: 387, so
the import machinery begins the *note import path: c7e. search by
calling the path based finder’s *note find_spec(): 2e6. method as
described previously.  When the ‘path’ argument to *note find_spec():
2e6. is given, it will be a list of string paths to traverse - typically
a package’s ‘__path__’ attribute for an import within that package.  If
the ‘path’ argument is ‘None’, this indicates a top level import and
*note sys.path: 2d5. is used.

The path based finder iterates over every entry in the search path, and
for each of these, looks for an appropriate *note path entry finder:
388. (*note PathEntryFinder: 38a.) for the path entry.  Because this can
be an expensive operation (e.g.  there may be ‘stat()’ call overheads
for this search), the path based finder maintains a cache mapping path
entries to path entry finders.  This cache is maintained in *note
sys.path_importer_cache: 31e. (despite the name, this cache actually
stores finder objects rather than being limited to *note importer: c7d.
objects).  In this way, the expensive search for a particular *note path
entry: c90. location’s *note path entry finder: 388. need only be done
once.  User code is free to remove cache entries from *note
sys.path_importer_cache: 31e. forcing the path based finder to perform
the path entry search again (1).

If the path entry is not present in the cache, the path based finder
iterates over every callable in *note sys.path_hooks: 31d.  Each of the
*note path entry hooks: c92. in this list is called with a single
argument, the path entry to be searched.  This callable may either
return a *note path entry finder: 388. that can handle the path entry,
or it may raise *note ImportError: 318.  An *note ImportError: 318. is
used by the path based finder to signal that the hook cannot find a
*note path entry finder: 388.  for that *note path entry: c90.  The
exception is ignored and *note import path: c7e. iteration continues.
The hook should expect either a string or bytes object; the encoding of
bytes objects is up to the hook (e.g.  it may be a file system encoding,
UTF-8, or something else), and if the hook cannot decode the argument,
it should raise *note ImportError: 318.

If *note sys.path_hooks: 31d. iteration ends with no *note path entry
finder: 388. being returned, then the path based finder’s *note
find_spec(): 2e6. method will store ‘None’ in *note
sys.path_importer_cache: 31e. (to indicate that there is no finder for
this path entry) and return ‘None’, indicating that this *note meta path
finder: 387. could not find the module.

If a *note path entry finder: 388. `is' returned by one of the *note
path entry hook: c92. callables on *note sys.path_hooks: 31d, then the
following protocol is used to ask the finder for a module spec, which is
then used when loading the module.

   ---------- Footnotes ----------

   (1) In legacy code, it is possible to find instances of *note
imp.NullImporter: 393. in the *note sys.path_importer_cache: 31e.  It is
recommended that code be changed to use ‘None’ instead.  See *note
Porting Python code: 529. for more details.


File: python.info,  Node: Path entry finder protocol,  Prev: Path entry finders,  Up: The Path Based Finder

4.5.5.2 Path entry finder protocol
..................................

In order to support imports of modules and initialized packages and also
to contribute portions to namespace packages, path entry finders must
implement the *note find_spec(): 2eb. method.

*note find_spec(): 2eb. takes two argument, the fully qualified name of
the module being imported, and the (optional) target module.
‘find_spec()’ returns a fully populated spec for the module.  This spec
will always have "loader" set (with one exception).

To indicate to the import machinery that the spec represents a namespace
*note portion: c77.  the path entry finder sets "loader" on the spec to
‘None’ and "submodule_search_locations" to a list containing the
portion.

Changed in version 3.4: *note find_spec(): 2eb. replaced *note
find_loader(): 2e9. and *note find_module(): 2ea, both of which are now
deprecated, but will be used if ‘find_spec()’ is not defined.

Older path entry finders may implement one of these two deprecated
methods instead of ‘find_spec()’.  The methods are still respected for
the sake of backward compatibility.  Howevever, if ‘find_spec()’ is
implemented on the path entry finder, the legacy methods are ignored.

*note find_loader(): 2e9. takes one argument, the fully qualified name
of the module being imported.  ‘find_loader()’ returns a 2-tuple where
the first item is the loader and the second item is a namespace *note
portion: c77.  When the first item (i.e.  the loader) is ‘None’, this
means that while the path entry finder does not have a loader for the
named module, it knows that the path entry contributes to a namespace
portion for the named module.  This will almost always be the case where
Python is asked to import a namespace package that has no physical
presence on the file system.  When a path entry finder returns ‘None’
for the loader, the second item of the 2-tuple return value must be a
sequence, although it can be empty.

If ‘find_loader()’ returns a non-‘None’ loader value, the portion is
ignored and the loader is returned from the path based finder,
terminating the search through the path entries.

For backwards compatibility with other implementations of the import
protocol, many path entry finders also support the same, traditional
‘find_module()’ method that meta path finders support.  However path
entry finder ‘find_module()’ methods are never called with a ‘path’
argument (they are expected to record the appropriate path information
from the initial call to the path hook).

The ‘find_module()’ method on path entry finders is deprecated, as it
does not allow the path entry finder to contribute portions to namespace
packages.  If both ‘find_loader()’ and ‘find_module()’ exist on a path
entry finder, the import system will always call ‘find_loader()’ in
preference to ‘find_module()’.


File: python.info,  Node: Replacing the standard import system,  Next: Special considerations for __main__,  Prev: The Path Based Finder,  Up: The import system

4.5.6 Replacing the standard import system
------------------------------------------

The most reliable mechanism for replacing the entire import system is to
delete the default contents of *note sys.meta_path: 392, replacing them
entirely with a custom meta path hook.

If it is acceptable to only alter the behaviour of import statements
without affecting other APIs that access the import system, then
replacing the builtin *note __import__(): 383. function may be
sufficient.  This technique may also be employed at the module level to
only alter the behaviour of import statements within that module.

To selectively prevent import of some modules from a hook early on the
meta path (rather than disabling the standard import system entirely),
it is sufficient to raise *note ImportError: 318. directly from *note
find_spec(): 2e8. instead of returning ‘None’.  The latter indicates
that the meta path search should continue, while raising an exception
terminates it immediately.


File: python.info,  Node: Special considerations for __main__,  Next: Open issues,  Prev: Replacing the standard import system,  Up: The import system

4.5.7 Special considerations for __main__
-----------------------------------------

The *note __main__: 1. module is a special case relative to Python’s
import system.  As noted *note elsewhere: c8a, the ‘__main__’ module is
directly initialized at interpreter startup, much like *note sys: f8.
and *note builtins: 13.  However, unlike those two, it doesn’t strictly
qualify as a built-in module.  This is because the manner in which
‘__main__’ is initialized depends on the flags and other options with
which the interpreter is invoked.

* Menu:

* __main__.__spec__: __main__ __spec__. 


File: python.info,  Node: __main__ __spec__,  Up: Special considerations for __main__

4.5.7.1 __main__.__spec__
.........................

Depending on how *note __main__: 1. is initialized, ‘__main__.__spec__’
gets set appropriately or to ‘None’.

When Python is started with the *note -m: 6a8. option, ‘__spec__’ is set
to the module spec of the corresponding module or package.  ‘__spec__’
is also populated when the ‘__main__’ module is loaded as part of
executing a directory, zipfile or other *note sys.path: 2d5. entry.

In *note the remaining cases: b23. ‘__main__.__spec__’ is set to ‘None’,
as the code used to populate the *note __main__: 1. does not correspond
directly with an importable module:

   - interactive prompt

   - -c switch

   - running from stdin

   - running directly from a source or bytecode file

Note that ‘__main__.__spec__’ is always ‘None’ in the last case, `even
if' the file could technically be imported directly as a module instead.
Use the *note -m: 6a8. switch if valid module metadata is desired in
*note __main__: 1.

Note also that even when ‘__main__’ corresponds with an importable
module and ‘__main__.__spec__’ is set accordingly, they’re still
considered `distinct' modules.  This is due to the fact that blocks
guarded by ‘if __name__ == "__main__":’ checks only execute when the
module is used to populate the ‘__main__’ namespace, and not during
normal import.


File: python.info,  Node: Open issues,  Next: References,  Prev: Special considerations for __main__,  Up: The import system

4.5.8 Open issues
-----------------

XXX It would be really nice to have a diagram.

XXX * (import_machinery.rst) how about a section devoted just to the
attributes of modules and packages, perhaps expanding upon or
supplanting the related entries in the data model reference page?

XXX runpy, pkgutil, et al in the library manual should all get "See
Also" links at the top pointing to the new import system section.

XXX Add more explanation regarding the different ways in which
‘__main__’ is initialized?

XXX Add more info on ‘__main__’ quirks/pitfalls (i.e.  copy from PEP
395(1)).

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0395


File: python.info,  Node: References,  Prev: Open issues,  Up: The import system

4.5.9 References
----------------

The import machinery has evolved considerably since Python’s early days.
The original specification for packages(1) is still available to read,
although some details have changed since the writing of that document.

The original specification for *note sys.meta_path: 392. was PEP 302(2),
with subsequent extension in PEP 420(3).

PEP 420(4) introduced *note namespace packages: c75. for Python 3.3.
PEP 420(5) also introduced the ‘find_loader()’ protocol as an
alternative to ‘find_module()’.

PEP 366(6) describes the addition of the ‘__package__’ attribute for
explicit relative imports in main modules.

PEP 328(7) introduced absolute and explicit relative imports and
initially proposed ‘__name__’ for semantics PEP 366(8) would eventually
specify for ‘__package__’.

PEP 338(9) defines executing modules as scripts.

PEP 451(10) adds the encapsulation of per-module import state in spec
objects.  It also off-loads most of the boilerplate responsibilities of
loaders back onto the import machinery.  These changes allow the
deprecation of several APIs in the import system and also addition of
new methods to finders and loaders.

   ---------- Footnotes ----------

   (1) http://legacy.python.org/doc/essays/packages.html

   (2) https://www.python.org/dev/peps/pep-0302

   (3) https://www.python.org/dev/peps/pep-0420

   (4) https://www.python.org/dev/peps/pep-0420

   (5) https://www.python.org/dev/peps/pep-0420

   (6) https://www.python.org/dev/peps/pep-0366

   (7) https://www.python.org/dev/peps/pep-0328

   (8) https://www.python.org/dev/peps/pep-0366

   (9) https://www.python.org/dev/peps/pep-0338

   (10) https://www.python.org/dev/peps/pep-0451


File: python.info,  Node: Expressions,  Next: Simple statements,  Prev: The import system,  Up: The Python Language Reference

4.6 Expressions
===============

This chapter explains the meaning of the elements of expressions in
Python.

`Syntax Notes:' In this and the following chapters, extended BNF
notation will be used to describe syntax, not lexical analysis.  When
(one alternative of) a syntax rule has the form

     name ::= othername

and no semantics are given, the semantics of this form of ‘name’ are the
same as for ‘othername’.

* Menu:

* Arithmetic conversions:: 
* Atoms:: 
* Primaries:: 
* The power operator:: 
* Unary arithmetic and bitwise operations:: 
* Binary arithmetic operations:: 
* Shifting operations:: 
* Binary bitwise operations:: 
* Comparisons:: 
* Boolean operations:: 
* Conditional expressions:: 
* Lambdas:: 
* Expression lists:: 
* Evaluation order:: 
* Operator precedence:: 


File: python.info,  Node: Arithmetic conversions,  Next: Atoms,  Up: Expressions

4.6.1 Arithmetic conversions
----------------------------

When a description of an arithmetic operator below uses the phrase "the
numeric arguments are converted to a common type," this means that the
operator implementation for built-in types works as follows:

   * If either argument is a complex number, the other is converted to
     complex;

   * otherwise, if either argument is a floating point number, the other
     is converted to floating point;

   * otherwise, both must be integers and no conversion is necessary.

Some additional rules apply for certain operators (e.g., a string as a
left argument to the ’%’ operator).  Extensions must define their own
conversion behavior.


File: python.info,  Node: Atoms,  Next: Primaries,  Prev: Arithmetic conversions,  Up: Expressions

4.6.2 Atoms
-----------

Atoms are the most basic elements of expressions.  The simplest atoms
are identifiers or literals.  Forms enclosed in parentheses, brackets or
braces are also categorized syntactically as atoms.  The syntax for
atoms is:

     atom      ::= identifier | literal | enclosure
     enclosure ::= parenth_form | list_display | dict_display | set_display
                   | generator_expression | yield_atom

* Menu:

* Identifiers (Names): Identifiers Names. 
* Literals: Literals<2>. 
* Parenthesized forms:: 
* Displays for lists, sets and dictionaries: Displays for lists sets and dictionaries. 
* List displays:: 
* Set displays:: 
* Dictionary displays:: 
* Generator expressions:: 
* Yield expressions:: 


File: python.info,  Node: Identifiers Names,  Next: Literals<2>,  Up: Atoms

4.6.2.1 Identifiers (Names)
...........................

An identifier occurring as an atom is a name.  See section *note
Identifiers and keywords: bac. for lexical definition and section *note
Naming and binding: c65. for documentation of naming and binding.

When the name is bound to an object, evaluation of the atom yields that
object.  When a name is not bound, an attempt to evaluate it raises a
*note NameError: 7f8. exception.

`Private name mangling:' When an identifier that textually occurs in a
class definition begins with two or more underscore characters and does
not end in two or more underscores, it is considered a `private name' of
that class.  Private names are transformed to a longer form before code
is generated for them.  The transformation inserts the class name, with
leading underscores removed and a single underscore inserted, in front
of the name.  For example, the identifier ‘__spam’ occurring in a class
named ‘Ham’ will be transformed to ‘_Ham__spam’.  This transformation is
independent of the syntactical context in which the identifier is used.
If the transformed name is extremely long (longer than 255 characters),
implementation defined truncation may happen.  If the class name
consists only of underscores, no transformation is done.


File: python.info,  Node: Literals<2>,  Next: Parenthesized forms,  Prev: Identifiers Names,  Up: Atoms

4.6.2.2 Literals
................

Python supports string and bytes literals and various numeric literals:

     literal ::= stringliteral | bytesliteral
                 | integer | floatnumber | imagnumber

Evaluation of a literal yields an object of the given type (string,
bytes, integer, floating point number, complex number) with the given
value.  The value may be approximated in the case of floating point and
imaginary (complex) literals.  See section *note Literals: bb8. for
details.

All literals correspond to immutable data types, and hence the object’s
identity is less important than its value.  Multiple evaluations of
literals with the same value (either the same occurrence in the program
text or a different occurrence) may obtain the same object or a
different object with the same value.


File: python.info,  Node: Parenthesized forms,  Next: Displays for lists sets and dictionaries,  Prev: Literals<2>,  Up: Atoms

4.6.2.3 Parenthesized forms
...........................

A parenthesized form is an optional expression list enclosed in
parentheses:

     parenth_form ::= "(" [expression_list] ")"

A parenthesized expression list yields whatever that expression list
yields: if the list contains at least one comma, it yields a tuple;
otherwise, it yields the single expression that makes up the expression
list.

An empty pair of parentheses yields an empty tuple object.  Since tuples
are immutable, the rules for literals apply (i.e., two occurrences of
the empty tuple may or may not yield the same object).

Note that tuples are not formed by the parentheses, but rather by use of
the comma operator.  The exception is the empty tuple, for which
parentheses `are' required — allowing unparenthesized "nothing" in
expressions would cause ambiguities and allow common typos to pass
uncaught.


File: python.info,  Node: Displays for lists sets and dictionaries,  Next: List displays,  Prev: Parenthesized forms,  Up: Atoms

4.6.2.4 Displays for lists, sets and dictionaries
.................................................

For constructing a list, a set or a dictionary Python provides special
syntax called "displays", each of them in two flavors:

   * either the container contents are listed explicitly, or

   * they are computed via a set of looping and filtering instructions,
     called a `comprehension'.

Common syntax elements for comprehensions are:

     comprehension ::= expression comp_for
     comp_for      ::= "for" target_list "in" or_test [comp_iter]
     comp_iter     ::= comp_for | comp_if
     comp_if       ::= "if" expression_nocond [comp_iter]

The comprehension consists of a single expression followed by at least
one *note for: 688. clause and zero or more *note for: 688. or *note if:
86d. clauses.  In this case, the elements of the new container are those
that would be produced by considering each of the *note for: 688. or
*note if: 86d. clauses a block, nesting from left to right, and
evaluating the expression to produce an element each time the innermost
block is reached.

Note that the comprehension is executed in a separate scope, so names
assigned to in the target list don’t "leak" into the enclosing scope.


File: python.info,  Node: List displays,  Next: Set displays,  Prev: Displays for lists sets and dictionaries,  Up: Atoms

4.6.2.5 List displays
.....................

A list display is a possibly empty series of expressions enclosed in
square brackets:

     list_display ::= "[" [expression_list | comprehension] "]"

A list display yields a new list object, the contents being specified by
either a list of expressions or a comprehension.  When a comma-separated
list of expressions is supplied, its elements are evaluated from left to
right and placed into the list object in that order.  When a
comprehension is supplied, the list is constructed from the elements
resulting from the comprehension.


File: python.info,  Node: Set displays,  Next: Dictionary displays,  Prev: List displays,  Up: Atoms

4.6.2.6 Set displays
....................

A set display is denoted by curly braces and distinguishable from
dictionary displays by the lack of colons separating keys and values:

     set_display ::= "{" (expression_list | comprehension) "}"

A set display yields a new mutable set object, the contents being
specified by either a sequence of expressions or a comprehension.  When
a comma-separated list of expressions is supplied, its elements are
evaluated from left to right and added to the set object.  When a
comprehension is supplied, the set is constructed from the elements
resulting from the comprehension.

An empty set cannot be constructed with ‘{}’; this literal constructs an
empty dictionary.


File: python.info,  Node: Dictionary displays,  Next: Generator expressions,  Prev: Set displays,  Up: Atoms

4.6.2.7 Dictionary displays
...........................

A dictionary display is a possibly empty series of key/datum pairs
enclosed in curly braces:

     dict_display       ::= "{" [key_datum_list | dict_comprehension] "}"
     key_datum_list     ::= key_datum ("," key_datum)* [","]
     key_datum          ::= expression ":" expression
     dict_comprehension ::= expression ":" expression comp_for

A dictionary display yields a new dictionary object.

If a comma-separated sequence of key/datum pairs is given, they are
evaluated from left to right to define the entries of the dictionary:
each key object is used as a key into the dictionary to store the
corresponding datum.  This means that you can specify the same key
multiple times in the key/datum list, and the final dictionary’s value
for that key will be the last one given.

A dict comprehension, in contrast to list and set comprehensions, needs
two expressions separated with a colon followed by the usual "for" and
"if" clauses.  When the comprehension is run, the resulting key and
value elements are inserted in the new dictionary in the order they are
produced.

Restrictions on the types of the key values are listed earlier in
section *note The standard type hierarchy: bf3.  (To summarize, the key
type should be *note hashable: bfd, which excludes all mutable objects.)
Clashes between duplicate keys are not detected; the last datum
(textually rightmost in the display) stored for a given key value
prevails.


File: python.info,  Node: Generator expressions,  Next: Yield expressions,  Prev: Dictionary displays,  Up: Atoms

4.6.2.8 Generator expressions
.............................

A generator expression is a compact generator notation in parentheses:

     generator_expression ::= "(" expression comp_for ")"

A generator expression yields a new generator object.  Its syntax is the
same as for comprehensions, except that it is enclosed in parentheses
instead of brackets or curly braces.

Variables used in the generator expression are evaluated lazily when the
*note __next__(): ac7. method is called for the generator object (in the
same fashion as normal generators).  However, the leftmost *note for:
688. clause is immediately evaluated, so that an error produced by it
can be seen before any other possible error in the code that handles the
generator expression.  Subsequent *note for: 688. clauses cannot be
evaluated immediately since they may depend on the previous *note for:
688. loop.  For example: ‘(x*y for x in range(10) for y in bar(x))’.

The parentheses can be omitted on calls with only one argument.  See
section *note Calls: bff. for details.


File: python.info,  Node: Yield expressions,  Prev: Generator expressions,  Up: Atoms

4.6.2.9 Yield expressions
.........................

     yield_atom       ::= "(" yield_expression ")"
     yield_expression ::= "yield" [expression_list | "from" expression]

The yield expression is only used when defining a *note generator: 374.
function and thus can only be used in the body of a function definition.
Using a yield expression in a function’s body causes that function to be
a generator.

When a generator function is called, it returns an iterator known as a
generator.  That generator then controls the execution of a generator
function.  The execution starts when one of the generator’s methods is
called.  At that time, the execution proceeds to the first yield
expression, where it is suspended again, returning the value of *note
expression_list: cc2. to the generator’s caller.  By suspended, we mean
that all local state is retained, including the current bindings of
local variables, the instruction pointer, the internal evaluation stack,
and the state of any exception handling.  When the execution is resumed
by calling one of the generator’s methods, the function can proceed
exactly as if the yield expression were just another external call.  The
value of the yield expression after resuming depends on the method which
resumed the execution.  If *note __next__(): ac7. is used (typically via
either a *note for: 688. or the *note next(): 6c6. builtin) then the
result is *note None: 2c6.  Otherwise, if *note send(): cc3. is used,
then the result will be the value passed in to that method.

All of this makes generator functions quite similar to coroutines; they
yield multiple times, they have more than one entry point and their
execution can be suspended.  The only difference is that a generator
function cannot control where the execution should continue after it
yields; the control is always transferred to the generator’s caller.

Yield expressions are allowed anywhere in a *note try: 7ee. construct.
If the generator is not resumed before it is finalized (by reaching a
zero reference count or by being garbage collected), the
generator-iterator’s *note close(): cc4. method will be called, allowing
any pending *note finally: 2c5. clauses to execute.

When ‘yield from <expr>’ is used, it treats the supplied expression as a
subiterator.  All values produced by that subiterator are passed
directly to the caller of the current generator’s methods.  Any values
passed in with *note send(): cc3. and any exceptions passed in with
*note throw(): cc5. are passed to the underlying iterator if it has the
appropriate methods.  If this is not the case, then *note send(): cc3.
will raise *note AttributeError: 320. or *note TypeError: 309, while
*note throw(): cc5. will just raise the passed in exception immediately.

When the underlying iterator is complete, the ‘value’ attribute of the
raised *note StopIteration: 7a5. instance becomes the value of the yield
expression.  It can be either set explicitly when raising *note
StopIteration: 7a5, or automatically when the sub-iterator is a
generator (by returning a value from the sub-generator).

     Changed in version 3.3: Added ‘yield from <expr>’ to delegate
     control flow to a subiterator

The parentheses may be omitted when the yield expression is the sole
expression on the right hand side of an assignment statement.

See also
........

PEP 0255(1) - Simple Generators

     The proposal for adding generators and the *note yield: 21b.
     statement to Python.

PEP 0342(2) - Coroutines via Enhanced Generators

     The proposal to enhance the API and syntax of generators, making
     them usable as simple coroutines.

PEP 0380(3) - Syntax for Delegating to a Subgenerator

     The proposal to introduce the ‘yield_from’ syntax, making
     delegation to sub-generators easy.

* Menu:

* Generator-iterator methods:: 
* Examples:: 

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0255

   (2) https://www.python.org/dev/peps/pep-0342

   (3) https://www.python.org/dev/peps/pep-0380


File: python.info,  Node: Generator-iterator methods,  Next: Examples,  Up: Yield expressions

4.6.2.10 Generator-iterator methods
...................................

This subsection describes the methods of a generator iterator.  They can
be used to control the execution of a generator function.

Note that calling any of the generator methods below when the generator
is already executing raises a *note ValueError: 321. exception.

 -- Method: generator.__next__ ()

     Starts the execution of a generator function or resumes it at the
     last executed yield expression.  When a generator function is
     resumed with a *note __next__(): ac7. method, the current yield
     expression always evaluates to *note None: 2c6.  The execution then
     continues to the next yield expression, where the generator is
     suspended again, and the value of the *note expression_list: cc2.
     is returned to *note __next__(): ac7.’s caller.  If the generator
     exits without yielding another value, a *note StopIteration: 7a5.
     exception is raised.

     This method is normally called implicitly, e.g.  by a *note for:
     688. loop, or by the built-in *note next(): 6c6. function.

 -- Method: generator.send (value)

     Resumes the execution and "sends" a value into the generator
     function.  The `value' argument becomes the result of the current
     yield expression.  The *note send(): cc3. method returns the next
     value yielded by the generator, or raises *note StopIteration: 7a5.
     if the generator exits without yielding another value.  When *note
     send(): cc3. is called to start the generator, it must be called
     with *note None: 2c6. as the argument, because there is no yield
     expression that could receive the value.

 -- Method: generator.throw (type[, value[, traceback]])

     Raises an exception of type ‘type’ at the point where the generator
     was paused, and returns the next value yielded by the generator
     function.  If the generator exits without yielding another value, a
     *note StopIteration: 7a5. exception is raised.  If the generator
     function does not catch the passed-in exception, or raises a
     different exception, then that exception propagates to the caller.

 -- Method: generator.close ()

     Raises a *note GeneratorExit: 7a7. at the point where the generator
     function was paused.  If the generator function then raises *note
     StopIteration: 7a5. (by exiting normally, or due to already being
     closed) or *note GeneratorExit: 7a7. (by not catching the
     exception), close returns to its caller.  If the generator yields a
     value, a *note RuntimeError: 7f0. is raised.  If the generator
     raises any other exception, it is propagated to the caller.  *note
     close(): cc4. does nothing if the generator has already exited due
     to an exception or normal exit.


File: python.info,  Node: Examples,  Prev: Generator-iterator methods,  Up: Yield expressions

4.6.2.11 Examples
.................

Here is a simple example that demonstrates the behavior of generators
and generator functions:

     >>> def echo(value=None):
     ...     print("Execution starts when 'next()' is called for the first time.")
     ...     try:
     ...         while True:
     ...             try:
     ...                 value = (yield value)
     ...             except Exception as e:
     ...                 value = e
     ...     finally:
     ...         print("Don't forget to clean up when 'close()' is called.")
     ...
     >>> generator = echo(1)
     >>> print(next(generator))
     Execution starts when 'next()' is called for the first time.
     1
     >>> print(next(generator))
     None
     >>> print(generator.send(2))
     2
     >>> generator.throw(TypeError, "spam")
     TypeError('spam',)
     >>> generator.close()
     Don't forget to clean up when 'close()' is called.

For examples using ‘yield from’, see *note PEP 380; Syntax for
Delegating to a Subgenerator: 345. in "What’s New in Python."


File: python.info,  Node: Primaries,  Next: The power operator,  Prev: Atoms,  Up: Expressions

4.6.3 Primaries
---------------

Primaries represent the most tightly bound operations of the language.
Their syntax is:

     primary ::= atom | attributeref | subscription | slicing | call

* Menu:

* Attribute references:: 
* Subscriptions:: 
* Slicings:: 
* Calls:: 


File: python.info,  Node: Attribute references,  Next: Subscriptions,  Up: Primaries

4.6.3.1 Attribute references
............................

An attribute reference is a primary followed by a period and a name:

     attributeref ::= primary "." identifier

The primary must evaluate to an object of a type that supports attribute
references, which most objects do.  This object is then asked to produce
the attribute whose name is the identifier.  This production can be
customized by overriding the *note __getattr__(): 560. method.  If this
attribute is not available, the exception *note AttributeError: 320. is
raised.  Otherwise, the type and value of the object produced is
determined by the object.  Multiple evaluations of the same attribute
reference may yield different objects.


File: python.info,  Node: Subscriptions,  Next: Slicings,  Prev: Attribute references,  Up: Primaries

4.6.3.2 Subscriptions
.....................

A subscription selects an item of a sequence (string, tuple or list) or
mapping (dictionary) object:

     subscription ::= primary "[" expression_list "]"

The primary must evaluate to an object that supports subscription (lists
or dictionaries for example).  User-defined objects can support
subscription by defining a *note __getitem__(): 88d. method.

For built-in objects, there are two types of objects that support
subscription:

If the primary is a mapping, the expression list must evaluate to an
object whose value is one of the keys of the mapping, and the
subscription selects the value in the mapping that corresponds to that
key.  (The expression list is a tuple except if it has exactly one
item.)

If the primary is a sequence, the expression (list) must evaluate to an
integer or a slice (as discussed in the following section).

The formal syntax makes no special provision for negative indices in
sequences; however, built-in sequences all provide a *note
__getitem__(): 88d. method that interprets negative indices by adding
the length of the sequence to the index (so that ‘x[-1]’ selects the
last item of ‘x’).  The resulting value must be a nonnegative integer
less than the number of items in the sequence, and the subscription
selects the item whose index is that value (counting from zero).  Since
the support for negative indices and slicing occurs in the object’s
*note __getitem__(): 88d. method, subclasses overriding this method will
need to explicitly add that support.

A string’s items are characters.  A character is not a separate data
type but a string of exactly one character.


File: python.info,  Node: Slicings,  Next: Calls,  Prev: Subscriptions,  Up: Primaries

4.6.3.3 Slicings
................

A slicing selects a range of items in a sequence object (e.g., a string,
tuple or list).  Slicings may be used as expressions or as targets in
assignment or *note del: a5d. statements.  The syntax for a slicing:

     slicing      ::= primary "[" slice_list "]"
     slice_list   ::= slice_item ("," slice_item)* [","]
     slice_item   ::= expression | proper_slice
     proper_slice ::= [lower_bound] ":" [upper_bound] [ ":" [stride] ]
     lower_bound  ::= expression
     upper_bound  ::= expression
     stride       ::= expression

There is ambiguity in the formal syntax here: anything that looks like
an expression list also looks like a slice list, so any subscription can
be interpreted as a slicing.  Rather than further complicating the
syntax, this is disambiguated by defining that in this case the
interpretation as a subscription takes priority over the interpretation
as a slicing (this is the case if the slice list contains no proper
slice).

The semantics for a slicing are as follows.  The primary is indexed
(using the same *note __getitem__(): 88d. method as normal subscription)
with a key that is constructed from the slice list, as follows.  If the
slice list contains at least one comma, the key is a tuple containing
the conversion of the slice items; otherwise, the conversion of the lone
slice item is the key.  The conversion of a slice item that is an
expression is that expression.  The conversion of a proper slice is a
slice object (see section *note The standard type hierarchy: bf3.) whose
‘start’, ‘stop’ and ‘step’ attributes are the values of the expressions
given as lower bound, upper bound and stride, respectively, substituting
‘None’ for missing expressions.


File: python.info,  Node: Calls,  Prev: Slicings,  Up: Primaries

4.6.3.4 Calls
.............

A call calls a callable object (e.g., a *note function: cdb.) with a
possibly empty series of *note arguments: cdc.:

     call                 ::= primary "(" [argument_list [","] | comprehension] ")"
     argument_list        ::= positional_arguments ["," keyword_arguments]
                                ["," "*" expression] ["," keyword_arguments]
                                ["," "**" expression]
                              | keyword_arguments ["," "*" expression]
                                ["," keyword_arguments] ["," "**" expression]
                              | "*" expression ["," keyword_arguments] ["," "**" expression]
                              | "**" expression
     positional_arguments ::= expression ("," expression)*
     keyword_arguments    ::= keyword_item ("," keyword_item)*
     keyword_item         ::= identifier "=" expression

An optional trailing comma may be present after the positional and
keyword arguments but does not affect the semantics.

The primary must evaluate to a callable object (user-defined functions,
built-in functions, methods of built-in objects, class objects, methods
of class instances, and all objects having a *note __call__(): c01.
method are callable).  All argument expressions are evaluated before the
call is attempted.  Please refer to section *note Function definitions:
a4b. for the syntax of formal *note parameter: ce2. lists.

If keyword arguments are present, they are first converted to positional
arguments, as follows.  First, a list of unfilled slots is created for
the formal parameters.  If there are N positional arguments, they are
placed in the first N slots.  Next, for each keyword argument, the
identifier is used to determine the corresponding slot (if the
identifier is the same as the first formal parameter name, the first
slot is used, and so on).  If the slot is already filled, a *note
TypeError: 309. exception is raised.  Otherwise, the value of the
argument is placed in the slot, filling it (even if the expression is
‘None’, it fills the slot).  When all arguments have been processed, the
slots that are still unfilled are filled with the corresponding default
value from the function definition.  (Default values are calculated,
once, when the function is defined; thus, a mutable object such as a
list or dictionary used as default value will be shared by all calls
that don’t specify an argument value for the corresponding slot; this
should usually be avoided.)  If there are any unfilled slots for which
no default value is specified, a *note TypeError: 309. exception is
raised.  Otherwise, the list of filled slots is used as the argument
list for the call.

`CPython implementation detail:' An implementation may provide built-in
functions whose positional parameters do not have names, even if they
are ’named’ for the purpose of documentation, and which therefore cannot
be supplied by keyword.  In CPython, this is the case for functions
implemented in C that use *note PyArg_ParseTuple(): 4fa. to parse their
arguments.

If there are more positional arguments than there are formal parameter
slots, a *note TypeError: 309. exception is raised, unless a formal
parameter using the syntax ‘*identifier’ is present; in this case, that
formal parameter receives a tuple containing the excess positional
arguments (or an empty tuple if there were no excess positional
arguments).

If any keyword argument does not correspond to a formal parameter name,
a *note TypeError: 309. exception is raised, unless a formal parameter
using the syntax ‘**identifier’ is present; in this case, that formal
parameter receives a dictionary containing the excess keyword arguments
(using the keywords as keys and the argument values as corresponding
values), or a (new) empty dictionary if there were no excess keyword
arguments.

If the syntax ‘*expression’ appears in the function call, ‘expression’
must evaluate to an iterable.  Elements from this iterable are treated
as if they were additional positional arguments; if there are positional
arguments `x1', ..., `xN', and ‘expression’ evaluates to a sequence
`y1', ..., `yM', this is equivalent to a call with M+N positional
arguments `x1', ..., `xN', `y1', ..., `yM'.

A consequence of this is that although the ‘*expression’ syntax may
appear `after' some keyword arguments, it is processed `before' the
keyword arguments (and the ‘**expression’ argument, if any – see below).
So:

     >>> def f(a, b):
     ...  print(a, b)
     ...
     >>> f(b=1, *(2,))
     2 1
     >>> f(a=1, *(2,))
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: f() got multiple values for keyword argument 'a'
     >>> f(1, *(2,))
     1 2

It is unusual for both keyword arguments and the ‘*expression’ syntax to
be used in the same call, so in practice this confusion does not arise.

If the syntax ‘**expression’ appears in the function call, ‘expression’
must evaluate to a mapping, the contents of which are treated as
additional keyword arguments.  In the case of a keyword appearing in
both ‘expression’ and as an explicit keyword argument, a *note
TypeError: 309. exception is raised.

Formal parameters using the syntax ‘*identifier’ or ‘**identifier’
cannot be used as positional argument slots or as keyword argument
names.

A call always returns some value, possibly ‘None’, unless it raises an
exception.  How this value is computed depends on the type of the
callable object.

If it is—

a user-defined function:

     The code block for the function is executed, passing it the
     argument list.  The first thing the code block will do is bind the
     formal parameters to the arguments; this is described in section
     *note Function definitions: a4b.  When the code block executes a
     *note return: 781. statement, this specifies the return value of
     the function call.

a built-in function or method:

     The result is up to the interpreter; see *note Built-in Functions:
     645. for the descriptions of built-in functions and methods.

a class object:

     A new instance of that class is returned.

a class instance method:

     The corresponding user-defined function is called, with an argument
     list that is one longer than the argument list of the call: the
     instance becomes the first argument.

a class instance:

     The class must define a *note __call__(): c01. method; the effect
     is then the same as if that method was called.


File: python.info,  Node: The power operator,  Next: Unary arithmetic and bitwise operations,  Prev: Primaries,  Up: Expressions

4.6.4 The power operator
------------------------

The power operator binds more tightly than unary operators on its left;
it binds less tightly than unary operators on its right.  The syntax is:

     power ::= primary ["**" u_expr]

Thus, in an unparenthesized sequence of power and unary operators, the
operators are evaluated from right to left (this does not constrain the
evaluation order for the operands): ‘-1**2’ results in ‘-1’.

The power operator has the same semantics as the built-in *note pow():
8e0. function, when called with two arguments: it yields its left
argument raised to the power of its right argument.  The numeric
arguments are first converted to a common type, and the result is of
that type.

For int operands, the result has the same type as the operands unless
the second argument is negative; in that case, all arguments are
converted to float and a float result is delivered.  For example,
‘10**2’ returns ‘100’, but ‘10**-2’ returns ‘0.01’.

Raising ‘0.0’ to a negative power results in a *note ZeroDivisionError:
a98.  Raising a negative number to a fractional power results in a *note
complex: 326. number.  (In earlier versions it raised a *note
ValueError: 321.)


File: python.info,  Node: Unary arithmetic and bitwise operations,  Next: Binary arithmetic operations,  Prev: The power operator,  Up: Expressions

4.6.5 Unary arithmetic and bitwise operations
---------------------------------------------

All unary arithmetic and bitwise operations have the same priority:

     u_expr ::= power | "-" u_expr | "+" u_expr | "~" u_expr

The unary ‘-’ (minus) operator yields the negation of its numeric
argument.

The unary ‘+’ (plus) operator yields its numeric argument unchanged.

The unary ‘~’ (invert) operator yields the bitwise inversion of its
integer argument.  The bitwise inversion of ‘x’ is defined as ‘-(x+1)’.
It only applies to integral numbers.

In all three cases, if the argument does not have the proper type, a
*note TypeError: 309. exception is raised.


File: python.info,  Node: Binary arithmetic operations,  Next: Shifting operations,  Prev: Unary arithmetic and bitwise operations,  Up: Expressions

4.6.6 Binary arithmetic operations
----------------------------------

The binary arithmetic operations have the conventional priority levels.
Note that some of these operations also apply to certain non-numeric
types.  Apart from the power operator, there are only two levels, one
for multiplicative operators and one for additive operators:

     m_expr ::= u_expr | m_expr "*" u_expr | m_expr "//" u_expr | m_expr "/" u_expr
                | m_expr "%" u_expr
     a_expr ::= m_expr | a_expr "+" m_expr | a_expr "-" m_expr

The ‘*’ (multiplication) operator yields the product of its arguments.
The arguments must either both be numbers, or one argument must be an
integer and the other must be a sequence.  In the former case, the
numbers are converted to a common type and then multiplied together.  In
the latter case, sequence repetition is performed; a negative repetition
factor yields an empty sequence.

The ‘/’ (division) and ‘//’ (floor division) operators yield the
quotient of their arguments.  The numeric arguments are first converted
to a common type.  Division of integers yields a float, while floor
division of integers results in an integer; the result is that of
mathematical division with the ’floor’ function applied to the result.
Division by zero raises the *note ZeroDivisionError: a98. exception.

The ‘%’ (modulo) operator yields the remainder from the division of the
first argument by the second.  The numeric arguments are first converted
to a common type.  A zero right argument raises the *note
ZeroDivisionError: a98. exception.  The arguments may be floating point
numbers, e.g., ‘3.14%0.7’ equals ‘0.34’ (since ‘3.14’ equals ‘4*0.7 +
0.34’.)  The modulo operator always yields a result with the same sign
as its second operand (or zero); the absolute value of the result is
strictly smaller than the absolute value of the second operand (1).

The floor division and modulo operators are connected by the following
identity: ‘x == (x//y)*y + (x%y)’.  Floor division and modulo are also
connected with the built-in function *note divmod(): c40.: ‘divmod(x, y)
== (x//y, x%y)’.  (2).

In addition to performing the modulo operation on numbers, the ‘%’
operator is also overloaded by string objects to perform old-style
string formatting (also known as interpolation).  The syntax for string
formatting is described in the Python Library Reference, section *note
printf-style String Formatting: a19.

The floor division operator, the modulo operator, and the *note
divmod(): c40. function are not defined for complex numbers.  Instead,
convert to a floating point number using the *note abs(): aaa. function
if appropriate.

The ‘+’ (addition) operator yields the sum of its arguments.  The
arguments must either both be numbers or both be sequences of the same
type.  In the former case, the numbers are converted to a common type
and then added together.  In the latter case, the sequences are
concatenated.

The ‘-’ (subtraction) operator yields the difference of its arguments.
The numeric arguments are first converted to a common type.

   ---------- Footnotes ----------

   (1) While ‘abs(x%y) < abs(y)’ is true mathematically, for floats it
may not be true numerically due to roundoff.  For example, and assuming
a platform on which a Python float is an IEEE 754 double-precision
number, in order that ‘-1e-100 % 1e100’ have the same sign as ‘1e100’,
the computed result is ‘-1e-100 + 1e100’, which is numerically exactly
equal to ‘1e100’.  The function *note math.fmod(): ced. returns a result
whose sign matches the sign of the first argument instead, and so
returns ‘-1e-100’ in this case.  Which approach is more appropriate
depends on the application.

   (2) If x is very close to an exact integer multiple of y, it’s
possible for ‘x//y’ to be one larger than ‘(x-x%y)//y’ due to rounding.
In such cases, Python returns the latter result, in order to preserve
that ‘divmod(x,y)[0] * y + x % y’ be very close to ‘x’.


File: python.info,  Node: Shifting operations,  Next: Binary bitwise operations,  Prev: Binary arithmetic operations,  Up: Expressions

4.6.7 Shifting operations
-------------------------

The shifting operations have lower priority than the arithmetic
operations:

     shift_expr ::= a_expr | shift_expr ( "<<" | ">>" ) a_expr

These operators accept integers as arguments.  They shift the first
argument to the left or right by the number of bits given by the second
argument.

A right shift by `n' bits is defined as floor division by ‘pow(2,n)’.  A
left shift by `n' bits is defined as multiplication with ‘pow(2,n)’.

     Note: In the current implementation, the right-hand operand is
     required to be at most *note sys.maxsize: 56b.  If the right-hand
     operand is larger than *note sys.maxsize: 56b. an *note
     OverflowError: 325. exception is raised.


File: python.info,  Node: Binary bitwise operations,  Next: Comparisons,  Prev: Shifting operations,  Up: Expressions

4.6.8 Binary bitwise operations
-------------------------------

Each of the three bitwise operations has a different priority level:

     and_expr ::= shift_expr | and_expr "&" shift_expr
     xor_expr ::= and_expr | xor_expr "^" and_expr
     or_expr  ::= xor_expr | or_expr "|" xor_expr

The ‘&’ operator yields the bitwise AND of its arguments, which must be
integers.

The ‘^’ operator yields the bitwise XOR (exclusive OR) of its arguments,
which must be integers.

The ‘|’ operator yields the bitwise (inclusive) OR of its arguments,
which must be integers.


File: python.info,  Node: Comparisons,  Next: Boolean operations,  Prev: Binary bitwise operations,  Up: Expressions

4.6.9 Comparisons
-----------------

Unlike C, all comparison operations in Python have the same priority,
which is lower than that of any arithmetic, shifting or bitwise
operation.  Also unlike C, expressions like ‘a < b < c’ have the
interpretation that is conventional in mathematics:

     comparison    ::= or_expr ( comp_operator or_expr )*
     comp_operator ::= "<" | ">" | "==" | ">=" | "<=" | "!="
                       | "is" ["not"] | ["not"] "in"

Comparisons yield boolean values: ‘True’ or ‘False’.

Comparisons can be chained arbitrarily, e.g., ‘x < y <= z’ is equivalent
to ‘x < y and y <= z’, except that ‘y’ is evaluated only once (but in
both cases ‘z’ is not evaluated at all when ‘x < y’ is found to be
false).

Formally, if `a', `b', `c', ..., `y', `z' are expressions and `op1',
`op2', ..., `opN' are comparison operators, then ‘a op1 b op2 c ... y
opN z’ is equivalent to ‘a op1 b and b op2 c and ... y opN z’, except
that each expression is evaluated at most once.

Note that ‘a op1 b op2 c’ doesn’t imply any kind of comparison between
`a' and `c', so that, e.g., ‘x < y > z’ is perfectly legal (though
perhaps not pretty).

The operators ‘<’, ‘>’, ‘==’, ‘>=’, ‘<=’, and ‘!=’ compare the values of
two objects.  The objects need not have the same type.  If both are
numbers, they are converted to a common type.  Otherwise, the ‘==’ and
‘!=’ operators `always' consider objects of different types to be
unequal, while the ‘<’, ‘>’, ‘>=’ and ‘<=’ operators raise a *note
TypeError: 309. when comparing objects of different types that do not
implement these operators for the given pair of types.  You can control
comparison behavior of objects of non-built-in types by defining rich
comparison methods like *note __gt__(): 710, described in section *note
Basic customization: c0c.

Comparison of objects of the same type depends on the type:

   * Numbers are compared arithmetically.

   * The values ‘float('NaN')’ and ‘Decimal('NaN')’ are special.  The
     are identical to themselves, ‘x is x’ but are not equal to
     themselves, ‘x != x’.  Additionally, comparing any value to a
     not-a-number value will return ‘False’.  For example, both ‘3 <
     float('NaN')’ and ‘float('NaN') < 3’ will return ‘False’.

   * Bytes objects are compared lexicographically using the numeric
     values of their elements.

   * Strings are compared lexicographically using the numeric
     equivalents (the result of the built-in function *note ord(): bfa.)
     of their characters.  (1) String and bytes object can’t be
     compared!

   * Tuples and lists are compared lexicographically using comparison of
     corresponding elements.  This means that to compare equal, each
     element must compare equal and the two sequences must be of the
     same type and have the same length.

     If not equal, the sequences are ordered the same as their first
     differing elements.  For example, ‘[1,2,x] <= [1,2,y]’ has the same
     value as ‘x <= y’.  If the corresponding element does not exist,
     the shorter sequence is ordered first (for example, ‘[1,2] <
     [1,2,3]’).

   * Mappings (dictionaries) compare equal if and only if they have the
     same ‘(key, value)’ pairs.  Order comparisons ‘('<', '<=', '>=',
     '>')’ raise *note TypeError: 309.

   * Sets and frozensets define comparison operators to mean subset and
     superset tests.  Those relations do not define total orderings (the
     two sets ‘{1,2}’ and {2,3} are not equal, nor subsets of one
     another, nor supersets of one another).  Accordingly, sets are not
     appropriate arguments for functions which depend on total ordering.
     For example, *note min(): 182, *note max(): 183, and *note
     sorted(): 63e. produce undefined results given a list of sets as
     inputs.

   * Most other objects of built-in types compare unequal unless they
     are the same object; the choice whether one object is considered
     smaller or larger than another one is made arbitrarily but
     consistently within one execution of a program.

Comparison of objects of differing types depends on whether either of
the types provide explicit support for the comparison.  Most numeric
types can be compared with one another.  When cross-type comparison is
not supported, the comparison method returns ‘NotImplemented’.  The
operators *note in: 6d5. and *note not in: c33. test for membership.  ‘x
in s’ evaluates to true if `x' is a member of `s', and false otherwise.
‘x not in s’ returns the negation of ‘x in s’.  All built-in sequences
and set types support this as well as dictionary, for which *note in:
6d5. tests whether the dictionary has a given key.  For container types
such as list, tuple, set, frozenset, dict, or collections.deque, the
expression ‘x in y’ is equivalent to ‘any(x is e or x == e for e in y)’.

For the string and bytes types, ‘x in y’ is true if and only if `x' is a
substring of `y'.  An equivalent test is ‘y.find(x) != -1’.  Empty
strings are always considered to be a substring of any other string, so
‘"" in "abc"’ will return ‘True’.

For user-defined classes which define the *note __contains__(): 79c.
method, ‘x in y’ is true if and only if ‘y.__contains__(x)’ is true.

For user-defined classes which do not define *note __contains__(): 79c.
but do define *note __iter__(): 79b, ‘x in y’ is true if some value ‘z’
with ‘x == z’ is produced while iterating over ‘y’.  If an exception is
raised during the iteration, it is as if *note in: 6d5. raised that
exception.

Lastly, the old-style iteration protocol is tried: if a class defines
*note __getitem__(): 88d, ‘x in y’ is true if and only if there is a
non-negative integer index `i' such that ‘x == y[i]’, and all lower
integer indices do not raise *note IndexError: 908. exception.  (If any
other exception is raised, it is as if *note in: 6d5. raised that
exception).

The operator *note not in: c33. is defined to have the inverse true
value of *note in: 6d5.

The operators *note is: bf2. and *note is not: cf7. test for object
identity: ‘x is y’ is true if and only if `x' and `y' are the same
object.  ‘x is not y’ yields the inverse truth value.  (2)

   ---------- Footnotes ----------

   (1) While comparisons between strings make sense at the byte level,
they may be counter-intuitive to users.  For example, the strings
‘"\u00C7"’ and ‘"\u0327\u0043"’ compare differently, even though they
both represent the same unicode character (LATIN CAPITAL LETTER C WITH
CEDILLA). To compare strings in a human recognizable way, compare using
*note unicodedata.normalize(): cfb.

   (2) Due to automatic garbage-collection, free lists, and the dynamic
nature of descriptors, you may notice seemingly unusual behaviour in
certain uses of the *note is: bf2. operator, like those involving
comparisons between instance methods, or constants.  Check their
documentation for more info.


File: python.info,  Node: Boolean operations,  Next: Conditional expressions,  Prev: Comparisons,  Up: Expressions

4.6.10 Boolean operations
-------------------------

     or_test  ::= and_test | or_test "or" and_test
     and_test ::= not_test | and_test "and" not_test
     not_test ::= comparison | "not" not_test

In the context of Boolean operations, and also when expressions are used
by control flow statements, the following values are interpreted as
false: ‘False’, ‘None’, numeric zero of all types, and empty strings and
containers (including strings, tuples, lists, dictionaries, sets and
frozensets).  All other values are interpreted as true.  User-defined
objects can customize their truth value by providing a *note __bool__():
6cc. method.

The operator *note not: d00. yields ‘True’ if its argument is false,
‘False’ otherwise.

The expression ‘x and y’ first evaluates `x'; if `x' is false, its value
is returned; otherwise, `y' is evaluated and the resulting value is
returned.

The expression ‘x or y’ first evaluates `x'; if `x' is true, its value
is returned; otherwise, `y' is evaluated and the resulting value is
returned.

(Note that neither *note and: cfd. nor *note or: cfe. restrict the value
and type they return to ‘False’ and ‘True’, but rather return the last
evaluated argument.  This is sometimes useful, e.g., if ‘s’ is a string
that should be replaced by a default value if it is empty, the
expression ‘s or 'foo'’ yields the desired value.  Because *note not:
d00. has to create a new value, it returns a boolean value regardless of
the type of its argument (for example, ‘not 'foo'’ produces ‘False’
rather than ‘''’.)


File: python.info,  Node: Conditional expressions,  Next: Lambdas,  Prev: Boolean operations,  Up: Expressions

4.6.11 Conditional expressions
------------------------------

     conditional_expression ::= or_test ["if" or_test "else" expression]
     expression             ::= conditional_expression | lambda_expr
     expression_nocond      ::= or_test | lambda_expr_nocond

Conditional expressions (sometimes called a "ternary operator") have the
lowest priority of all Python operations.

The expression ‘x if C else y’ first evaluates the condition, `C' rather
than `x'.  If `C' is true, `x' is evaluated and its value is returned;
otherwise, `y' is evaluated and its value is returned.

See PEP 308(1) for more details about conditional expressions.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0308


File: python.info,  Node: Lambdas,  Next: Expression lists,  Prev: Conditional expressions,  Up: Expressions

4.6.12 Lambdas
--------------

     lambda_expr        ::= "lambda" [parameter_list]: expression
     lambda_expr_nocond ::= "lambda" [parameter_list]: expression_nocond

Lambda expressions (sometimes called lambda forms) are used to create
anonymous functions.  The expression ‘lambda arguments: expression’
yields a function object.  The unnamed object behaves like a function
object defined with

     def <lambda>(arguments):
         return expression

See section *note Function definitions: a4b. for the syntax of parameter
lists.  Note that functions created with lambda expressions cannot
contain statements or annotations.


File: python.info,  Node: Expression lists,  Next: Evaluation order,  Prev: Lambdas,  Up: Expressions

4.6.13 Expression lists
-----------------------

     expression_list ::= expression ( "," expression )* [","]

An expression list containing at least one comma yields a tuple.  The
length of the tuple is the number of expressions in the list.  The
expressions are evaluated from left to right.

The trailing comma is required only to create a single tuple (a.k.a.  a
`singleton'); it is optional in all other cases.  A single expression
without a trailing comma doesn’t create a tuple, but rather yields the
value of that expression.  (To create an empty tuple, use an empty pair
of parentheses: ‘()’.)


File: python.info,  Node: Evaluation order,  Next: Operator precedence,  Prev: Expression lists,  Up: Expressions

4.6.14 Evaluation order
-----------------------

Python evaluates expressions from left to right.  Notice that while
evaluating an assignment, the right-hand side is evaluated before the
left-hand side.

In the following lines, expressions will be evaluated in the arithmetic
order of their suffixes:

     expr1, expr2, expr3, expr4
     (expr1, expr2, expr3, expr4)
     {expr1: expr2, expr3: expr4}
     expr1 + expr2 * (expr3 - expr4)
     expr1(expr2, expr3, *expr4, **expr5)
     expr3, expr4 = expr1, expr2


File: python.info,  Node: Operator precedence,  Prev: Evaluation order,  Up: Expressions

4.6.15 Operator precedence
--------------------------

The following table summarizes the operator precedence in Python, from
lowest precedence (least binding) to highest precedence (most binding).
Operators in the same box have the same precedence.  Unless the syntax
is explicitly given, operators are binary.  Operators in the same box
group left to right (except for exponentiation, which groups from right
to left).

Note that comparisons, membership tests, and identity tests, all have
the same precedence and have a left-to-right chaining feature as
described in the *note Comparisons: cf6. section.

Operator                                            Description
                                                    
----------------------------------------------------------------------------------------------
                                                    
*note lambda: 687.                                  Lambda expression
                                                    
                                                    
*note if: 86d. – *note else: a27.                   Conditional expression
                                                    
                                                    
*note or: cfe.                                      Boolean OR
                                                    
                                                    
*note and: cfd.                                     Boolean AND
                                                    
                                                    
*note not: d00. ‘x’                                 Boolean NOT
                                                    
                                                    
*note in: 6d5, *note not in: c33, *note is: bf2,    Comparisons, including membership tests
*note is not: cf7, ‘<’, ‘<=’, ‘>’, ‘>=’, ‘!=’,      and identity tests
‘==’                                                

‘|’                                                 Bitwise OR
                                                    
                                                    
‘^’                                                 Bitwise XOR
                                                    
                                                    
‘&’                                                 Bitwise AND
                                                    
                                                    
‘<<’, ‘>>’                                          Shifts
                                                    
                                                    
‘+’, ‘-’                                            Addition and subtraction
                                                    
                                                    
‘*’, ‘/’, ‘//’, ‘%’                                 Multiplication, division, remainder (1)
                                                    
                                                    
‘+x’, ‘-x’, ‘~x’                                    Positive, negative, bitwise NOT
                                                    
                                                    
‘**’                                                Exponentiation (2)
                                                    
                                                    
‘x[index]’, ‘x[index:index]’, ‘x(arguments...)’,    Subscription, slicing, call, attribute
‘x.attribute’                                       reference
                                                    
                                                    
‘(expressions...)’, ‘[expressions...]’, ‘{key:      Binding or tuple display, list display,
value...}’, ‘{expressions...}’                      dictionary display, set display
                                                    

   ---------- Footnotes ----------

   (1) The ‘%’ operator is also used for string formatting; the same
precedence applies.

   (2) The power operator ‘**’ binds less tightly than an arithmetic or
bitwise unary operator on its right, that is, ‘2**-1’ is ‘0.5’.


File: python.info,  Node: Simple statements,  Next: Compound statements,  Prev: Expressions,  Up: The Python Language Reference

4.7 Simple statements
=====================

A simple statement is comprised within a single logical line.  Several
simple statements may occur on a single line separated by semicolons.
The syntax for simple statements is:

     simple_stmt ::= expression_stmt
                     | assert_stmt
                     | assignment_stmt
                     | augmented_assignment_stmt
                     | pass_stmt
                     | del_stmt
                     | return_stmt
                     | yield_stmt
                     | raise_stmt
                     | break_stmt
                     | continue_stmt
                     | import_stmt
                     | global_stmt
                     | nonlocal_stmt

* Menu:

* Expression statements:: 
* Assignment statements:: 
* The assert statement:: 
* The pass statement:: 
* The del statement: The del statement<2>. 
* The return statement:: 
* The yield statement:: 
* The raise statement:: 
* The break statement:: 
* The continue statement:: 
* The import statement:: 
* The global statement:: 
* The nonlocal statement:: 


File: python.info,  Node: Expression statements,  Next: Assignment statements,  Up: Simple statements

4.7.1 Expression statements
---------------------------

Expression statements are used (mostly interactively) to compute and
write a value, or (usually) to call a procedure (a function that returns
no meaningful result; in Python, procedures return the value ‘None’).
Other uses of expression statements are allowed and occasionally useful.
The syntax for an expression statement is:

     expression_stmt ::= expression_list

An expression statement evaluates the expression list (which may be a
single expression).

In interactive mode, if the value is not ‘None’, it is converted to a
string using the built-in *note repr(): 3db. function and the resulting
string is written to standard output on a line by itself (except if the
result is ‘None’, so that procedure calls do not cause any output.)


File: python.info,  Node: Assignment statements,  Next: The assert statement,  Prev: Expression statements,  Up: Simple statements

4.7.2 Assignment statements
---------------------------

Assignment statements are used to (re)bind names to values and to modify
attributes or items of mutable objects:

     assignment_stmt ::= (target_list "=")+ (expression_list | yield_expression)
     target_list     ::= target ("," target)* [","]
     target          ::= identifier
                         | "(" target_list ")"
                         | "[" target_list "]"
                         | attributeref
                         | subscription
                         | slicing
                         | "*" target

(See section *note Primaries: cc8. for the syntax definitions for
`attributeref', `subscription', and `slicing'.)

An assignment statement evaluates the expression list (remember that
this can be a single expression or a comma-separated list, the latter
yielding a tuple) and assigns the single resulting object to each of the
target lists, from left to right.

Assignment is defined recursively depending on the form of the target
(list).  When a target is part of a mutable object (an attribute
reference, subscription or slicing), the mutable object must ultimately
perform the assignment and decide about its validity, and may raise an
exception if the assignment is unacceptable.  The rules observed by
various types and the exceptions raised are given with the definition of
the object types (see section *note The standard type hierarchy: bf3.).

Assignment of an object to a target list, optionally enclosed in
parentheses or square brackets, is recursively defined as follows.

   * If the target list is a single target: The object is assigned to
     that target.

   * If the target list is a comma-separated list of targets: The object
     must be an iterable with the same number of items as there are
     targets in the target list, and the items are assigned, from left
     to right, to the corresponding targets.

        * If the target list contains one target prefixed with an
          asterisk, called a "starred" target: The object must be a
          sequence with at least as many items as there are targets in
          the target list, minus one.  The first items of the sequence
          are assigned, from left to right, to the targets before the
          starred target.  The final items of the sequence are assigned
          to the targets after the starred target.  A list of the
          remaining items in the sequence is then assigned to the
          starred target (the list can be empty).

        * Else: The object must be a sequence with the same number of
          items as there are targets in the target list, and the items
          are assigned, from left to right, to the corresponding
          targets.

Assignment of an object to a single target is recursively defined as
follows.

   * If the target is an identifier (name):

        * If the name does not occur in a *note global: a38. or *note
          nonlocal: 69a. statement in the current code block: the name
          is bound to the object in the current local namespace.

        * Otherwise: the name is bound to the object in the global
          namespace or the outer namespace determined by *note nonlocal:
          69a, respectively.

     The name is rebound if it was already bound.  This may cause the
     reference count for the object previously bound to the name to
     reach zero, causing the object to be deallocated and its destructor
     (if it has one) to be called.

   * If the target is a target list enclosed in parentheses or in square
     brackets: The object must be an iterable with the same number of
     items as there are targets in the target list, and its items are
     assigned, from left to right, to the corresponding targets.

   * If the target is an attribute reference: The primary expression in
     the reference is evaluated.  It should yield an object with
     assignable attributes; if this is not the case, *note TypeError:
     309. is raised.  That object is then asked to assign the assigned
     object to the given attribute; if it cannot perform the assignment,
     it raises an exception (usually but not necessarily *note
     AttributeError: 320.).  Note: If the object is a class instance and
     the attribute reference occurs on both sides of the assignment
     operator, the RHS expression, ‘a.x’ can access either an instance
     attribute or (if no instance attribute exists) a class attribute.
     The LHS target ‘a.x’ is always set as an instance attribute,
     creating it if necessary.  Thus, the two occurrences of ‘a.x’ do
     not necessarily refer to the same attribute: if the RHS expression
     refers to a class attribute, the LHS creates a new instance
     attribute as the target of the assignment:

          class Cls:
              x = 3             # class variable
          inst = Cls()
          inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3

     This description does not necessarily apply to descriptor
     attributes, such as properties created with *note property(): 3ac.

   * If the target is a subscription: The primary expression in the
     reference is evaluated.  It should yield either a mutable sequence
     object (such as a list) or a mapping object (such as a dictionary).
     Next, the subscript expression is evaluated.

     If the primary is a mutable sequence object (such as a list), the
     subscript must yield an integer.  If it is negative, the sequence’s
     length is added to it.  The resulting value must be a nonnegative
     integer less than the sequence’s length, and the sequence is asked
     to assign the assigned object to its item with that index.  If the
     index is out of range, *note IndexError: 908. is raised (assignment
     to a subscripted sequence cannot add new items to a list).

     If the primary is a mapping object (such as a dictionary), the
     subscript must have a type compatible with the mapping’s key type,
     and the mapping is then asked to create a key/datum pair which maps
     the subscript to the assigned object.  This can either replace an
     existing key/value pair with the same key value, or insert a new
     key/value pair (if no key with the same value existed).

     For user-defined objects, the *note __setitem__(): 6c4. method is
     called with appropriate arguments.

   * If the target is a slicing: The primary expression in the reference
     is evaluated.  It should yield a mutable sequence object (such as a
     list).  The assigned object should be a sequence object of the same
     type.  Next, the lower and upper bound expressions are evaluated,
     insofar they are present; defaults are zero and the sequence’s
     length.  The bounds should evaluate to integers.  If either bound
     is negative, the sequence’s length is added to it.  The resulting
     bounds are clipped to lie between zero and the sequence’s length,
     inclusive.  Finally, the sequence object is asked to replace the
     slice with the items of the assigned sequence.  The length of the
     slice may be different from the length of the assigned sequence,
     thus changing the length of the target sequence, if the target
     sequence allows it.

`CPython implementation detail:' In the current implementation, the
syntax for targets is taken to be the same as for expressions, and
invalid syntax is rejected during the code generation phase, causing
less detailed error messages.

Although the definition of assignment implies that overlaps between the
left-hand side and the right-hand side are ’simultanenous’ (for example
‘a, b = b, a’ swaps two variables), overlaps `within' the collection of
assigned-to variables occur left-to-right, sometimes resulting in
confusion.  For instance, the following program prints ‘[0, 2]’:

     x = [0, 1]
     i = 0
     i, x[i] = 1, 2         # i is updated, then x[i] is updated
     print(x)

See also
........

PEP 3132(1) - Extended Iterable Unpacking

     The specification for the ‘*target’ feature.

* Menu:

* Augmented assignment statements:: 

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-3132


File: python.info,  Node: Augmented assignment statements,  Up: Assignment statements

4.7.2.1 Augmented assignment statements
.......................................

Augmented assignment is the combination, in a single statement, of a
binary operation and an assignment statement:

     augmented_assignment_stmt ::= augtarget augop (expression_list | yield_expression)
     augtarget                 ::= identifier | attributeref | subscription | slicing
     augop                     ::= "+=" | "-=" | "*=" | "/=" | "//=" | "%=" | "**="
                                   | ">>=" | "<<=" | "&=" | "^=" | "|="

(See section *note Primaries: cc8. for the syntax definitions of the
last three symbols.)

An augmented assignment evaluates the target (which, unlike normal
assignment statements, cannot be an unpacking) and the expression list,
performs the binary operation specific to the type of assignment on the
two operands, and assigns the result to the original target.  The target
is only evaluated once.

An augmented assignment expression like ‘x += 1’ can be rewritten as ‘x
= x + 1’ to achieve a similar, but not exactly equal effect.  In the
augmented version, ‘x’ is only evaluated once.  Also, when possible, the
actual operation is performed `in-place', meaning that rather than
creating a new object and assigning that to the target, the old object
is modified instead.

Unlike normal assignments, augmented assignments evaluate the left-hand
side `before' evaluating the right-hand side.  For example, ‘a[i] +=
f(x)’ first looks-up ‘a[i]’, then it evaluates ‘f(x)’ and performs the
addition, and lastly, it writes the result back to ‘a[i]’.

With the exception of assigning to tuples and multiple targets in a
single statement, the assignment done by augmented assignment statements
is handled the same way as normal assignments.  Similarly, with the
exception of the possible `in-place' behavior, the binary operation
performed by augmented assignment is the same as the normal binary
operations.

For targets which are attribute references, the same *note caveat about
class and instance attributes: d1e. applies as for regular assignments.


File: python.info,  Node: The assert statement,  Next: The pass statement,  Prev: Assignment statements,  Up: Simple statements

4.7.3 The ‘assert’ statement
----------------------------

Assert statements are a convenient way to insert debugging assertions
into a program:

     assert_stmt ::= "assert" expression ["," expression]

The simple form, ‘assert expression’, is equivalent to

     if __debug__:
        if not expression: raise AssertionError

The extended form, ‘assert expression1, expression2’, is equivalent to

     if __debug__:
        if not expression1: raise AssertionError(expression2)

These equivalences assume that *note __debug__: d26. and *note
AssertionError: d27. refer to the built-in variables with those names.
In the current implementation, the built-in variable *note __debug__:
d26. is ‘True’ under normal circumstances, ‘False’ when optimization is
requested (command line option -O). The current code generator emits no
code for an assert statement when optimization is requested at compile
time.  Note that it is unnecessary to include the source code for the
expression that failed in the error message; it will be displayed as
part of the stack trace.

Assignments to *note __debug__: d26. are illegal.  The value for the
built-in variable is determined when the interpreter starts.


File: python.info,  Node: The pass statement,  Next: The del statement<2>,  Prev: The assert statement,  Up: Simple statements

4.7.4 The ‘pass’ statement
--------------------------

     pass_stmt ::= "pass"

*note pass: a34. is a null operation — when it is executed, nothing
happens.  It is useful as a placeholder when a statement is required
syntactically, but no code needs to be executed, for example:

     def f(arg): pass    # a function that does nothing (yet)

     class C: pass       # a class with no methods (yet)


File: python.info,  Node: The del statement<2>,  Next: The return statement,  Prev: The pass statement,  Up: Simple statements

4.7.5 The ‘del’ statement
-------------------------

     del_stmt ::= "del" target_list

Deletion is recursively defined very similar to the way assignment is
defined.  Rather than spelling it out in full details, here are some
hints.

Deletion of a target list recursively deletes each target, from left to
right.

Deletion of a name removes the binding of that name from the local or
global namespace, depending on whether the name occurs in a *note
global: a38. statement in the same code block.  If the name is unbound,
a *note NameError: 7f8. exception will be raised.

Deletion of attribute references, subscriptions and slicings is passed
to the primary object involved; deletion of a slicing is in general
equivalent to assignment of an empty slice of the right type (but even
this is determined by the sliced object).

Changed in version 3.2: Previously it was illegal to delete a name from
the local namespace if it occurs as a free variable in a nested block.


File: python.info,  Node: The return statement,  Next: The yield statement,  Prev: The del statement<2>,  Up: Simple statements

4.7.6 The ‘return’ statement
----------------------------

     return_stmt ::= "return" [expression_list]

*note return: 781. may only occur syntactically nested in a function
definition, not within a nested class definition.

If an expression list is present, it is evaluated, else ‘None’ is
substituted.

*note return: 781. leaves the current function call with the expression
list (or ‘None’) as return value.

When *note return: 781. passes control out of a *note try: 7ee.
statement with a *note finally: 2c5. clause, that *note finally: 2c5.
clause is executed before really leaving the function.

In a generator function, the *note return: 781. statement indicates that
the generator is done and will cause *note StopIteration: 7a5. to be
raised.  The returned value (if any) is used as an argument to construct
*note StopIteration: 7a5. and becomes the ‘StopIteration.value’
attribute.


File: python.info,  Node: The yield statement,  Next: The raise statement,  Prev: The return statement,  Up: Simple statements

4.7.7 The ‘yield’ statement
---------------------------

     yield_stmt ::= yield_expression

A *note yield: 21b. statement is semantically equivalent to a *note
yield expression: cbf.  The yield statement can be used to omit the
parentheses that would otherwise be required in the equivalent yield
expression statement.  For example, the yield statements

     yield <expr>
     yield from <expr>

are equivalent to the yield expression statements

     (yield <expr>)
     (yield from <expr>)

Yield expressions and statements are only used when defining a *note
generator: 374. function, and are only used in the body of the generator
function.  Using yield in a function definition is sufficient to cause
that definition to create a generator function instead of a normal
function.

For full details of *note yield: 21b. semantics, refer to the *note
Yield expressions: cbf. section.


File: python.info,  Node: The raise statement,  Next: The break statement,  Prev: The yield statement,  Up: Simple statements

4.7.8 The ‘raise’ statement
---------------------------

     raise_stmt ::= "raise" [expression ["from" expression]]

If no expressions are present, *note raise: 69d. re-raises the last
exception that was active in the current scope.  If no exception is
active in the current scope, a *note RuntimeError: 7f0. exception is
raised indicating that this is an error.

Otherwise, *note raise: 69d. evaluates the first expression as the
exception object.  It must be either a subclass or an instance of *note
BaseException: 6bd.  If it is a class, the exception instance will be
obtained when needed by instantiating the class with no arguments.

The `type' of the exception is the exception instance’s class, the
`value' is the instance itself.

A traceback object is normally created automatically when an exception
is raised and attached to it as the ‘__traceback__’ attribute, which is
writable.  You can create an exception and set your own traceback in one
step using the ‘with_traceback()’ exception method (which returns the
same exception instance, with its traceback set to its argument), like
so:

     raise Exception("foo occurred").with_traceback(tracebackobj)

The ‘from’ clause is used for exception chaining: if given, the second
`expression' must be another exception class or instance, which will
then be attached to the raised exception as the ‘__cause__’ attribute
(which is writable).  If the raised exception is not handled, both
exceptions will be printed:

     >>> try:
     ...     print(1 / 0)
     ... except Exception as exc:
     ...     raise RuntimeError("Something bad happened") from exc
     ...
     Traceback (most recent call last):
       File "<stdin>", line 2, in <module>
     ZeroDivisionError: int division or modulo by zero

     The above exception was the direct cause of the following exception:

     Traceback (most recent call last):
       File "<stdin>", line 4, in <module>
     RuntimeError: Something bad happened

A similar mechanism works implicitly if an exception is raised inside an
exception handler or a *note finally: 2c5. clause: the previous
exception is then attached as the new exception’s ‘__context__’
attribute:

     >>> try:
     ...     print(1 / 0)
     ... except:
     ...     raise RuntimeError("Something bad happened")
     ...
     Traceback (most recent call last):
       File "<stdin>", line 2, in <module>
     ZeroDivisionError: int division or modulo by zero

     During handling of the above exception, another exception occurred:

     Traceback (most recent call last):
       File "<stdin>", line 4, in <module>
     RuntimeError: Something bad happened

Additional information on exceptions can be found in section *note
Exceptions: c69, and information about handling exceptions is in section
*note The try statement: 7ee.


File: python.info,  Node: The break statement,  Next: The continue statement,  Prev: The raise statement,  Up: Simple statements

4.7.9 The ‘break’ statement
---------------------------

     break_stmt ::= "break"

*note break: a2f. may only occur syntactically nested in a *note for:
688. or *note while: a20. loop, but not nested in a function or class
definition within that loop.

It terminates the nearest enclosing loop, skipping the optional *note
else: a27. clause if the loop has one.

If a *note for: 688. loop is terminated by *note break: a2f, the loop
control target keeps its current value.

When *note break: a2f. passes control out of a *note try: 7ee. statement
with a *note finally: 2c5. clause, that *note finally: 2c5. clause is
executed before really leaving the loop.


File: python.info,  Node: The continue statement,  Next: The import statement,  Prev: The break statement,  Up: Simple statements

4.7.10 The ‘continue’ statement
-------------------------------

     continue_stmt ::= "continue"

*note continue: a31. may only occur syntactically nested in a *note for:
688. or *note while: a20. loop, but not nested in a function or class
definition or *note finally: 2c5. clause within that loop.  It continues
with the next cycle of the nearest enclosing loop.

When *note continue: a31. passes control out of a *note try: 7ee.
statement with a *note finally: 2c5. clause, that *note finally: 2c5.
clause is executed before really starting the next loop cycle.


File: python.info,  Node: The import statement,  Next: The global statement,  Prev: The continue statement,  Up: Simple statements

4.7.11 The ‘import’ statement
-----------------------------

     import_stmt     ::= "import" module ["as" name] ( "," module ["as" name] )*
                         | "from" relative_module "import" identifier ["as" name]
                         ( "," identifier ["as" name] )*
                         | "from" relative_module "import" "(" identifier ["as" name]
                         ( "," identifier ["as" name] )* [","] ")"
                         | "from" module "import" "*"
     module          ::= (identifier ".")* identifier
     relative_module ::= "."* module | "."+
     name            ::= identifier

The basic import statement (no *note from: 6a1. clause) is executed in
two steps:

  1. find a module, loading and initializing it if necessary

  2. define a name or names in the local namespace for the scope where
     the *note import: 674. statement occurs.

When the statement contains multiple clauses (separated by commas) the
two steps are carried out separately for each clause, just as though the
clauses had been separated out into individiual import statements.

The details of the first step, finding and loading modules are described
in greater detail in the section on the *note import system: c02, which
also describes the various types of packages and modules that can be
imported, as well as all the hooks that can be used to customize the
import system.  Note that failures in this step may indicate either that
the module could not be located, `or' that an error occurred while
initializing the module, which includes execution of the module’s code.

If the requested module is retrieved successfully, it will be made
available in the local namespace in one of three ways:

   * If the module name is followed by *note as: 69e, then the name
     following *note as: 69e. is bound directly to the imported module.

   * If no other name is specified, and the module being imported is a
     top level module, the module’s name is bound in the local namespace
     as a reference to the imported module

   * If the module being imported is `not' a top level module, then the
     name of the top level package that contains the module is bound in
     the local namespace as a reference to the top level package.  The
     imported module must be accessed using its full qualified name
     rather than directly

The *note from: 6a1. form uses a slightly more complex process:

  1. find the module specified in the *note from: 6a1. clause, loading
     and initializing it if necessary;

  2. for each of the identifiers specified in the *note import: 674.
     clauses:

       1. check if the imported module has an attribute by that name

       2. if not, attempt to import a submodule with that name and then
          check the imported module again for that attribute

       3. if the attribute is not found, *note ImportError: 318. is
          raised.

       4. otherwise, a reference to that value is stored in the local
          namespace, using the name in the *note as: 69e. clause if it
          is present, otherwise using the attribute name

Examples:

     import foo                 # foo imported and bound locally
     import foo.bar.baz         # foo.bar.baz imported, foo bound locally
     import foo.bar.baz as fbb  # foo.bar.baz imported and bound as fbb
     from foo.bar import baz    # foo.bar.baz imported and bound as baz
     from foo import attr       # foo imported and foo.attr bound as attr

If the list of identifiers is replaced by a star (‘'*'’), all public
names defined in the module are bound in the local namespace for the
scope where the *note import: 674. statement occurs.

The `public names' defined by a module are determined by checking the
module’s namespace for a variable named ‘__all__’; if defined, it must
be a sequence of strings which are names defined or imported by that
module.  The names given in ‘__all__’ are all considered public and are
required to exist.  If ‘__all__’ is not defined, the set of public names
includes all names found in the module’s namespace which do not begin
with an underscore character (‘'_'’).  ‘__all__’ should contain the
entire public API. It is intended to avoid accidentally exporting items
that are not part of the API (such as library modules which were
imported and used within the module).

The wild card form of import — ‘from module import *’ — is only allowed
at the module level.  Attempting to use it in class or function
definitions will raise a *note SyntaxError: 319.

When specifying what module to import you do not have to specify the
absolute name of the module.  When a module or package is contained
within another package it is possible to make a relative import within
the same top package without having to mention the package name.  By
using leading dots in the specified module or package after *note from:
6a1. you can specify how high to traverse up the current package
hierarchy without specifying exact names.  One leading dot means the
current package where the module making the import exists.  Two dots
means up one package level.  Three dots is up two levels, etc.  So if
you execute ‘from . import mod’ from a module in the ‘pkg’ package then
you will end up importing ‘pkg.mod’.  If you execute ‘from ..subpkg2
import mod’ from within ‘pkg.subpkg1’ you will import ‘pkg.subpkg2.mod’.
The specification for relative imports is contained within PEP 328(1).

*note importlib.import_module(): 52a. is provided to support
applications that determine dynamically the modules to be loaded.

* Menu:

* Future statements:: 

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0328


File: python.info,  Node: Future statements,  Up: The import statement

4.7.11.1 Future statements
..........................

A `future statement' is a directive to the compiler that a particular
module should be compiled using syntax or semantics that will be
available in a specified future release of Python where the feature
becomes standard.

The future statement is intended to ease migration to future versions of
Python that introduce incompatible changes to the language.  It allows
use of the new features on a per-module basis before the release in
which the feature becomes standard.

     future_statement ::= "from" "__future__" "import" feature ["as" name]
                          ("," feature ["as" name])*
                          | "from" "__future__" "import" "(" feature ["as" name]
                          ("," feature ["as" name])* [","] ")"
     feature          ::= identifier
     name             ::= identifier

A future statement must appear near the top of the module.  The only
lines that can appear before a future statement are:

   * the module docstring (if any),

   * comments,

   * blank lines, and

   * other future statements.

The features recognized by Python 3.0 are ‘absolute_import’, ‘division’,
‘generators’, ‘unicode_literals’, ‘print_function’, ‘nested_scopes’ and
‘with_statement’.  They are all redundant because they are always
enabled, and only kept for backwards compatibility.

A future statement is recognized and treated specially at compile time:
Changes to the semantics of core constructs are often implemented by
generating different code.  It may even be the case that a new feature
introduces new incompatible syntax (such as a new reserved word), in
which case the compiler may need to parse the module differently.  Such
decisions cannot be pushed off until runtime.

For any given release, the compiler knows which feature names have been
defined, and raises a compile-time error if a future statement contains
a feature not known to it.

The direct runtime semantics are the same as for any import statement:
there is a standard module *note __future__: 0, described later, and it
will be imported in the usual way at the time the future statement is
executed.

The interesting runtime semantics depend on the specific feature enabled
by the future statement.

Note that there is nothing special about the statement:

     import __future__ [as name]

That is not a future statement; it’s an ordinary import statement with
no special semantics or syntax restrictions.

Code compiled by calls to the built-in functions *note exec(): 6a0. and
*note compile(): 6fe. that occur in a module ‘M’ containing a future
statement will, by default, use the new syntax or semantics associated
with the future statement.  This can be controlled by optional arguments
to *note compile(): 6fe. — see the documentation of that function for
details.

A future statement typed at an interactive interpreter prompt will take
effect for the rest of the interpreter session.  If an interpreter is
started with the *note -i: 8ab. option, is passed a script name to
execute, and the script includes a future statement, it will be in
effect in the interactive session started after the script is executed.

See also
........

PEP 236(1) - Back to the __future__

     The original proposal for the __future__ mechanism.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0236


File: python.info,  Node: The global statement,  Next: The nonlocal statement,  Prev: The import statement,  Up: Simple statements

4.7.12 The ‘global’ statement
-----------------------------

     global_stmt ::= "global" identifier ("," identifier)*

The *note global: a38. statement is a declaration which holds for the
entire current code block.  It means that the listed identifiers are to
be interpreted as globals.  It would be impossible to assign to a global
variable without *note global: a38, although free variables may refer to
globals without being declared global.

Names listed in a *note global: a38. statement must not be used in the
same code block textually preceding that *note global: a38. statement.

Names listed in a *note global: a38. statement must not be defined as
formal parameters or in a *note for: 688. loop control target, *note
class: 6ce. definition, function definition, or *note import: 674.
statement.

`CPython implementation detail:' The current implementation does not
enforce the two restrictions, but programs should not abuse this
freedom, as future implementations may enforce them or silently change
the meaning of the program.

`Programmer’s note:' the *note global: a38. is a directive to the
parser.  It applies only to code parsed at the same time as the *note
global: a38. statement.  In particular, a *note global: a38. statement
contained in a string or code object supplied to the built-in *note
exec(): 6a0. function does not affect the code block `containing' the
function call, and code contained in such a string is unaffected by
*note global: a38. statements in the code containing the function call.
The same applies to the *note eval(): 5d2. and *note compile(): 6fe.
functions.


File: python.info,  Node: The nonlocal statement,  Prev: The global statement,  Up: Simple statements

4.7.13 The ‘nonlocal’ statement
-------------------------------

     nonlocal_stmt ::= "nonlocal" identifier ("," identifier)*

The *note nonlocal: 69a. statement causes the listed identifiers to
refer to previously bound variables in the nearest enclosing scope
excluding globals.  This is important because the default behavior for
binding is to search the local namespace first.  The statement allows
encapsulated code to rebind variables outside of the local scope besides
the global (module) scope.

Names listed in a *note nonlocal: 69a. statement, unlike those listed in
a *note global: a38. statement, must refer to pre-existing bindings in
an enclosing scope (the scope in which a new binding should be created
cannot be determined unambiguously).

Names listed in a *note nonlocal: 69a. statement must not collide with
pre-existing bindings in the local scope.

See also
........

PEP 3104(1) - Access to Names in Outer Scopes

     The specification for the *note nonlocal: 69a. statement.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-3104


File: python.info,  Node: Compound statements,  Next: Top-level components,  Prev: Simple statements,  Up: The Python Language Reference

4.8 Compound statements
=======================

Compound statements contain (groups of) other statements; they affect or
control the execution of those other statements in some way.  In
general, compound statements span multiple lines, although in simple
incarnations a whole compound statement may be contained in one line.

The *note if: 86d, *note while: a20. and *note for: 688. statements
implement traditional control flow constructs.  *note try: 7ee.
specifies exception handlers and/or cleanup code for a group of
statements, while the *note with: 19b. statement allows the execution of
initialization and finalization code around a block of code.  Function
and class definitions are also syntactically compound statements.

A compound statement consists of one or more ’clauses.’ A clause
consists of a header and a ’suite.’ The clause headers of a particular
compound statement are all at the same indentation level.  Each clause
header begins with a uniquely identifying keyword and ends with a colon.
A suite is a group of statements controlled by a clause.  A suite can be
one or more semicolon-separated simple statements on the same line as
the header, following the header’s colon, or it can be one or more
indented statements on subsequent lines.  Only the latter form of a
suite can contain nested compound statements; the following is illegal,
mostly because it wouldn’t be clear to which *note if: 86d. clause a
following *note else: a27. clause would belong:

     if test1: if test2: print(x)

Also note that the semicolon binds tighter than the colon in this
context, so that in the following example, either all or none of the
*note print(): 21c. calls are executed:

     if x < y < z: print(x); print(y); print(z)

Summarizing:

     compound_stmt ::= if_stmt
                       | while_stmt
                       | for_stmt
                       | try_stmt
                       | with_stmt
                       | funcdef
                       | classdef
     suite         ::= stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT
     statement     ::= stmt_list NEWLINE | compound_stmt
     stmt_list     ::= simple_stmt (";" simple_stmt)* [";"]

Note that statements always end in a ‘NEWLINE’ possibly followed by a
‘DEDENT’.  Also note that optional continuation clauses always begin
with a keyword that cannot start a statement, thus there are no
ambiguities (the ’dangling *note else: a27.’ problem is solved in Python
by requiring nested *note if: 86d. statements to be indented).

The formatting of the grammar rules in the following sections places
each clause on a separate line for clarity.
* Menu:

* The if statement:: 
* The while statement:: 
* The for statement:: 
* The try statement:: 
* The with statement:: 
* Function definitions:: 
* Class definitions:: 


File: python.info,  Node: The if statement,  Next: The while statement,  Up: Compound statements

4.8.1 The ‘if’ statement
------------------------

The *note if: 86d. statement is used for conditional execution:

     if_stmt ::= "if" expression ":" suite
                 ( "elif" expression ":" suite )*
                 ["else" ":" suite]

It selects exactly one of the suites by evaluating the expressions one
by one until one is found to be true (see section *note Boolean
operations: cfc. for the definition of true and false); then that suite
is executed (and no other part of the *note if: 86d. statement is
executed or evaluated).  If all expressions are false, the suite of the
*note else: a27. clause, if present, is executed.


File: python.info,  Node: The while statement,  Next: The for statement,  Prev: The if statement,  Up: Compound statements

4.8.2 The ‘while’ statement
---------------------------

The *note while: a20. statement is used for repeated execution as long
as an expression is true:

     while_stmt ::= "while" expression ":" suite
                    ["else" ":" suite]

This repeatedly tests the expression and, if it is true, executes the
first suite; if the expression is false (which may be the first time it
is tested) the suite of the *note else: a27. clause, if present, is
executed and the loop terminates.

A *note break: a2f. statement executed in the first suite terminates the
loop without executing the *note else: a27. clause’s suite.  A *note
continue: a31. statement executed in the first suite skips the rest of
the suite and goes back to testing the expression.


File: python.info,  Node: The for statement,  Next: The try statement,  Prev: The while statement,  Up: Compound statements

4.8.3 The ‘for’ statement
-------------------------

The *note for: 688. statement is used to iterate over the elements of a
sequence (such as a string, tuple or list) or other iterable object:

     for_stmt ::= "for" target_list "in" expression_list ":" suite
                  ["else" ":" suite]

The expression list is evaluated once; it should yield an iterable
object.  An iterator is created for the result of the ‘expression_list’.
The suite is then executed once for each item provided by the iterator,
in the order returned by the iterator.  Each item in turn is assigned to
the target list using the standard rules for assignments (see *note
Assignment statements: d19.), and then the suite is executed.  When the
items are exhausted (which is immediately when the sequence is empty or
an iterator raises a *note StopIteration: 7a5. exception), the suite in
the *note else: a27. clause, if present, is executed, and the loop
terminates.

A *note break: a2f. statement executed in the first suite terminates the
loop without executing the *note else: a27. clause’s suite.  A *note
continue: a31. statement executed in the first suite skips the rest of
the suite and continues with the next item, or with the *note else: a27.
clause if there is no next item.

The for-loop makes assignments to the variables(s) in the target list.
This overwrites all previous assignments to those variables including
those made in the suite of the for-loop:

     for i in range(10):
         print(i)
         i = 5             # this will not affect the for-loop
                           # because i will be overwritten with the next
                           # index in the range

Names in the target list are not deleted when the loop is finished, but
if the sequence is empty, they will not have been assigned to at all by
the loop.  Hint: the built-in function *note range(): 396. returns an
iterator of integers suitable to emulate the effect of Pascal’s ‘for i
:= a to b do’; e.g., ‘list(range(3))’ returns the list ‘[0, 1, 2]’.

     Note: 
     There is a subtlety when the sequence is being modified by the loop
     (this can only occur for mutable sequences, i.e.  lists).  An
     internal counter is used to keep track of which item is used next,
     and this is incremented on each iteration.  When this counter has
     reached the length of the sequence the loop terminates.  This means
     that if the suite deletes the current (or a previous) item from the
     sequence, the next item will be skipped (since it gets the index of
     the current item which has already been treated).  Likewise, if the
     suite inserts an item in the sequence before the current item, the
     current item will be treated again the next time through the loop.
     This can lead to nasty bugs that can be avoided by making a
     temporary copy using a slice of the whole sequence, e.g.,

          for x in a[:]:
              if x < 0: a.remove(x)


File: python.info,  Node: The try statement,  Next: The with statement,  Prev: The for statement,  Up: Compound statements

4.8.4 The ‘try’ statement
-------------------------

The *note try: 7ee. statement specifies exception handlers and/or
cleanup code for a group of statements:

     try_stmt  ::= try1_stmt | try2_stmt
     try1_stmt ::= "try" ":" suite
                   ("except" [expression ["as" identifier]] ":" suite)+
                   ["else" ":" suite]
                   ["finally" ":" suite]
     try2_stmt ::= "try" ":" suite
                   "finally" ":" suite

The *note except: 563. clause(s) specify one or more exception handlers.
When no exception occurs in the *note try: 7ee. clause, no exception
handler is executed.  When an exception occurs in the *note try: 7ee.
suite, a search for an exception handler is started.  This search
inspects the except clauses in turn until one is found that matches the
exception.  An expression-less except clause, if present, must be last;
it matches any exception.  For an except clause with an expression, that
expression is evaluated, and the clause matches the exception if the
resulting object is "compatible" with the exception.  An object is
compatible with an exception if it is the class or a base class of the
exception object or a tuple containing an item compatible with the
exception.

If no except clause matches the exception, the search for an exception
handler continues in the surrounding code and on the invocation stack.
(1)

If the evaluation of an expression in the header of an except clause
raises an exception, the original search for a handler is canceled and a
search starts for the new exception in the surrounding code and on the
call stack (it is treated as if the entire *note try: 7ee. statement
raised the exception).

When a matching except clause is found, the exception is assigned to the
target specified after the *note as: 69e. keyword in that except clause,
if present, and the except clause’s suite is executed.  All except
clauses must have an executable block.  When the end of this block is
reached, execution continues normally after the entire try statement.
(This means that if two nested handlers exist for the same exception,
and the exception occurs in the try clause of the inner handler, the
outer handler will not handle the exception.)

When an exception has been assigned using ‘as target’, it is cleared at
the end of the except clause.  This is as if

     except E as N:
         foo

was translated to

     except E as N:
         try:
             foo
         finally:
             del N

This means the exception must be assigned to a different name to be able
to refer to it after the except clause.  Exceptions are cleared because
with the traceback attached to them, they form a reference cycle with
the stack frame, keeping all locals in that frame alive until the next
garbage collection occurs.

Before an except clause’s suite is executed, details about the exception
are stored in the *note sys: f8. module and can be accessed via *note
sys.exc_info(): 6c1.  *note sys.exc_info(): 6c1. returns a 3-tuple
consisting of the exception class, the exception instance and a
traceback object (see section *note The standard type hierarchy: bf3.)
identifying the point in the program where the exception occurred.
*note sys.exc_info(): 6c1. values are restored to their previous values
(before the call) when returning from a function that handled an
exception.

The optional *note else: a27. clause is executed if and when control
flows off the end of the *note try: 7ee. clause.  (2) Exceptions in the
*note else: a27. clause are not handled by the preceding *note except:
563. clauses.

If *note finally: 2c5. is present, it specifies a ’cleanup’ handler.
The *note try: 7ee. clause is executed, including any *note except: 563.
and *note else: a27. clauses.  If an exception occurs in any of the
clauses and is not handled, the exception is temporarily saved.  The
*note finally: 2c5. clause is executed.  If there is a saved exception
it is re-raised at the end of the *note finally: 2c5. clause.  If the
*note finally: 2c5. clause raises another exception, the saved exception
is set as the context of the new exception.  If the *note finally: 2c5.
clause executes a *note return: 781. or *note break: a2f. statement, the
saved exception is discarded:

     >>> def f():
     ...     try:
     ...         1/0
     ...     finally:
     ...         return 42
     ...
     >>> f()
     42

The exception information is not available to the program during
execution of the *note finally: 2c5. clause.

When a *note return: 781, *note break: a2f. or *note continue: a31.
statement is executed in the *note try: 7ee. suite of a *note try:
7ee...*note finally: 2c5. statement, the *note finally: 2c5. clause is
also executed ’on the way out.’ A *note continue: a31. statement is
illegal in the *note finally: 2c5. clause.  (The reason is a problem
with the current implementation — this restriction may be lifted in the
future).

The return value of a function is determined by the last *note return:
781. statement executed.  Since the *note finally: 2c5. clause always
executes, a *note return: 781. statement executed in the *note finally:
2c5. clause will always be the last one executed:

     >>> def foo():
     ...     try:
     ...         return 'try'
     ...     finally:
     ...         return 'finally'
     ...
     >>> foo()
     'finally'

Additional information on exceptions can be found in section *note
Exceptions: c69, and information on using the *note raise: 69d.
statement to generate exceptions may be found in section *note The raise
statement: 69d.

   ---------- Footnotes ----------

   (1) The exception is propagated to the invocation stack unless there
is a *note finally: 2c5. clause which happens to raise another
exception.  That new exception causes the old one to be lost.

   (2) Currently, control "flows off the end" except in the case of an
exception or the execution of a *note return: 781, *note continue: a31,
or *note break: a2f. statement.


File: python.info,  Node: The with statement,  Next: Function definitions,  Prev: The try statement,  Up: Compound statements

4.8.5 The ‘with’ statement
--------------------------

The *note with: 19b. statement is used to wrap the execution of a block
with methods defined by a context manager (see section *note With
Statement Context Managers: c5d.).  This allows common *note try:
7ee...*note except: 563...*note finally: 2c5. usage patterns to be
encapsulated for convenient reuse.

     with_stmt ::= "with" with_item ("," with_item)* ":" suite
     with_item ::= expression ["as" target]

The execution of the *note with: 19b. statement with one "item" proceeds
as follows:

  1. The context expression (the expression given in the *note
     with_item: d57.) is evaluated to obtain a context manager.

  2. The context manager’s *note __exit__(): 703. is loaded for later
     use.

  3. The context manager’s *note __enter__(): 702. method is invoked.

  4. If a target was included in the *note with: 19b. statement, the
     return value from *note __enter__(): 702. is assigned to it.

          Note: The *note with: 19b. statement guarantees that if the
          *note __enter__(): 702. method returns without an error, then
          *note __exit__(): 703. will always be called.  Thus, if an
          error occurs during the assignment to the target list, it will
          be treated the same as an error occurring within the suite
          would be.  See step 6 below.

  5. The suite is executed.

  6. The context manager’s *note __exit__(): 703. method is invoked.  If
     an exception caused the suite to be exited, its type, value, and
     traceback are passed as arguments to *note __exit__(): 703.
     Otherwise, three *note None: 2c6. arguments are supplied.

     If the suite was exited due to an exception, and the return value
     from the *note __exit__(): 703. method was false, the exception is
     reraised.  If the return value was true, the exception is
     suppressed, and execution continues with the statement following
     the *note with: 19b. statement.

     If the suite was exited for any reason other than an exception, the
     return value from *note __exit__(): 703. is ignored, and execution
     proceeds at the normal location for the kind of exit that was
     taken.

With more than one item, the context managers are processed as if
multiple *note with: 19b. statements were nested:

     with A() as a, B() as b:
         suite

is equivalent to

     with A() as a:
         with B() as b:
             suite

Changed in version 3.1: Support for multiple context expressions.

See also
........

PEP 0343(1) - The "with" statement

     The specification, background, and examples for the Python *note
     with: 19b. statement.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0343


File: python.info,  Node: Function definitions,  Next: Class definitions,  Prev: The with statement,  Up: Compound statements

4.8.6 Function definitions
--------------------------

A function definition defines a user-defined function object (see
section *note The standard type hierarchy: bf3.):

     funcdef        ::= [decorators] "def" funcname "(" [parameter_list] ")" ["->" expression] ":" suite
     decorators     ::= decorator+
     decorator      ::= "@" dotted_name ["(" [parameter_list [","]] ")"] NEWLINE
     dotted_name    ::= identifier ("." identifier)*
     parameter_list ::= (defparameter ",")*
                        | "*" [parameter] ("," defparameter)* ["," "**" parameter]
                        | "**" parameter
                        | defparameter [","] )
     parameter      ::= identifier [":" expression]
     defparameter   ::= parameter ["=" expression]
     funcname       ::= identifier

A function definition is an executable statement.  Its execution binds
the function name in the current local namespace to a function object (a
wrapper around the executable code for the function).  This function
object contains a reference to the current global namespace as the
global namespace to be used when the function is called.

The function definition does not execute the function body; this gets
executed only when the function is called.  (1)

A function definition may be wrapped by one or more *note decorator:
d62. expressions.  Decorator expressions are evaluated when the function
is defined, in the scope that contains the function definition.  The
result must be a callable, which is invoked with the function object as
the only argument.  The returned value is bound to the function name
instead of the function object.  Multiple decorators are applied in
nested fashion.  For example, the following code

     @f1(arg)
     @f2
     def func(): pass

is equivalent to

     def func(): pass
     func = f1(arg)(f2(func))

When one or more *note parameters: ce2. have the form `parameter' ‘=’
`expression', the function is said to have "default parameter values."
For a parameter with a default value, the corresponding *note argument:
cdc. may be omitted from a call, in which case the parameter’s default
value is substituted.  If a parameter has a default value, all following
parameters up until the "‘*’" must also have a default value — this is a
syntactic restriction that is not expressed by the grammar.

`Default parameter values are evaluated from left to right when the
function definition is executed.'  This means that the expression is
evaluated once, when the function is defined, and that the same
"pre-computed" value is used for each call.  This is especially
important to understand when a default parameter is a mutable object,
such as a list or a dictionary: if the function modifies the object
(e.g.  by appending an item to a list), the default value is in effect
modified.  This is generally not what was intended.  A way around this
is to use ‘None’ as the default, and explicitly test for it in the body
of the function, e.g.:

     def whats_on_the_telly(penguin=None):
         if penguin is None:
             penguin = []
         penguin.append("property of the zoo")
         return penguin

Function call semantics are described in more detail in section *note
Calls: bff.  A function call always assigns values to all parameters
mentioned in the parameter list, either from position arguments, from
keyword arguments, or from default values.  If the form "‘*identifier’"
is present, it is initialized to a tuple receiving any excess positional
parameters, defaulting to the empty tuple.  If the form "‘**identifier’"
is present, it is initialized to a new dictionary receiving any excess
keyword arguments, defaulting to a new empty dictionary.  Parameters
after "‘*’" or "‘*identifier’" are keyword-only parameters and may only
be passed used keyword arguments.

Parameters may have annotations of the form "‘: expression’" following
the parameter name.  Any parameter may have an annotation even those of
the form ‘*identifier’ or ‘**identifier’.  Functions may have "return"
annotation of the form "‘-> expression’" after the parameter list.
These annotations can be any valid Python expression and are evaluated
when the function definition is executed.  Annotations may be evaluated
in a different order than they appear in the source code.  The presence
of annotations does not change the semantics of a function.  The
annotation values are available as values of a dictionary keyed by the
parameters’ names in the ‘__annotations__’ attribute of the function
object.

It is also possible to create anonymous functions (functions not bound
to a name), for immediate use in expressions.  This uses lambda
expressions, described in section *note Lambdas: 687.  Note that the
lambda expression is merely a shorthand for a simplified function
definition; a function defined in a "*note def: 841." statement can be
passed around or assigned to another name just like a function defined
by a lambda expression.  The "*note def: 841." form is actually more
powerful since it allows the execution of multiple statements and
annotations.

`Programmer’s note:' Functions are first-class objects.  A "‘def’"
statement executed inside a function definition defines a local function
that can be returned or passed around.  Free variables used in the
nested function can access the local variables of the function
containing the def.  See section *note Naming and binding: c65. for
details.

See also
........

PEP 3107(2) - Function Annotations

     The original specification for function annotations.

   ---------- Footnotes ----------

   (1) A string literal appearing as the first statement in the function
body is transformed into the function’s ‘__doc__’ attribute and
therefore the function’s *note docstring: d61.

   (2) https://www.python.org/dev/peps/pep-3107


File: python.info,  Node: Class definitions,  Prev: Function definitions,  Up: Compound statements

4.8.7 Class definitions
-----------------------

A class definition defines a class object (see section *note The
standard type hierarchy: bf3.):

     classdef    ::= [decorators] "class" classname [inheritance] ":" suite
     inheritance ::= "(" [parameter_list] ")"
     classname   ::= identifier

A class definition is an executable statement.  The inheritance list
usually gives a list of base classes (see *note Customizing class
creation: c1f. for more advanced uses), so each item in the list should
evaluate to a class object which allows subclassing.  Classes without an
inheritance list inherit, by default, from the base class *note object:
381.; hence,

     class Foo:
         pass

is equivalent to

     class Foo(object):
         pass

The class’s suite is then executed in a new execution frame (see *note
Naming and binding: c65.), using a newly created local namespace and the
original global namespace.  (Usually, the suite contains mostly function
definitions.)  When the class’s suite finishes execution, its execution
frame is discarded but its local namespace is saved.  (1) A class object
is then created using the inheritance list for the base classes and the
saved local namespace for the attribute dictionary.  The class name is
bound to this class object in the original local namespace.

Class creation can be customized heavily using *note metaclasses: c1f.

Classes can also be decorated: just like when decorating functions,

     @f1(arg)
     @f2
     class Foo: pass

is equivalent to

     class Foo: pass
     Foo = f1(arg)(f2(Foo))

The evaluation rules for the decorator expressions are the same as for
function decorators.  The result must be a class object, which is then
bound to the class name.

`Programmer’s note:' Variables defined in the class definition are class
attributes; they are shared by instances.  Instance attributes can be
set in a method with ‘self.name = value’.  Both class and instance
attributes are accessible through the notation "‘self.name’", and an
instance attribute hides a class attribute with the same name when
accessed in this way.  Class attributes can be used as defaults for
instance attributes, but using mutable values there can lead to
unexpected results.  *note Descriptors: c04. can be used to create
instance variables with different implementation details.

See also
........

PEP 3115(2) - Metaclasses in Python 3 PEP 3129(3) - Class Decorators

   ---------- Footnotes ----------

   (1) A string literal appearing as the first statement in the class
body is transformed into the namespace’s ‘__doc__’ item and therefore
the class’s *note docstring: d61.

   (2) https://www.python.org/dev/peps/pep-3115

   (3) https://www.python.org/dev/peps/pep-3129


File: python.info,  Node: Top-level components,  Next: Full Grammar specification,  Prev: Compound statements,  Up: The Python Language Reference

4.9 Top-level components
========================

The Python interpreter can get its input from a number of sources: from
a script passed to it as standard input or as program argument, typed in
interactively, from a module source file, etc.  This chapter gives the
syntax used in these cases.

* Menu:

* Complete Python programs:: 
* File input:: 
* Interactive input:: 
* Expression input:: 


File: python.info,  Node: Complete Python programs,  Next: File input,  Up: Top-level components

4.9.1 Complete Python programs
------------------------------

While a language specification need not prescribe how the language
interpreter is invoked, it is useful to have a notion of a complete
Python program.  A complete Python program is executed in a minimally
initialized environment: all built-in and standard modules are
available, but none have been initialized, except for *note sys: f8.
(various system services), *note builtins: 13. (built-in functions,
exceptions and ‘None’) and *note __main__: 1.  The latter is used to
provide the local and global namespace for execution of the complete
program.

The syntax for a complete Python program is that for file input,
described in the next section.

The interpreter may also be invoked in interactive mode; in this case,
it does not read and execute a complete program but reads and executes
one statement (possibly compound) at a time.  The initial environment is
identical to that of a complete program; each statement is executed in
the namespace of *note __main__: 1.

Under Unix, a complete program can be passed to the interpreter in three
forms: with the *note -c: 738. `string' command line option, as a file
passed as the first command line argument, or as standard input.  If the
file or standard input is a tty device, the interpreter enters
interactive mode; otherwise, it executes the file as a complete program.


File: python.info,  Node: File input,  Next: Interactive input,  Prev: Complete Python programs,  Up: Top-level components

4.9.2 File input
----------------

All input read from non-interactive files has the same form:

     file_input ::= (NEWLINE | statement)*

This syntax is used in the following situations:

   * when parsing a complete Python program (from a file or from a
     string);

   * when parsing a module;

   * when parsing a string passed to the *note exec(): 6a0. function;


File: python.info,  Node: Interactive input,  Next: Expression input,  Prev: File input,  Up: Top-level components

4.9.3 Interactive input
-----------------------

Input in interactive mode is parsed using the following grammar:

     interactive_input ::= [stmt_list] NEWLINE | compound_stmt NEWLINE

Note that a (top-level) compound statement must be followed by a blank
line in interactive mode; this is needed to help the parser detect the
end of the input.


File: python.info,  Node: Expression input,  Prev: Interactive input,  Up: Top-level components

4.9.4 Expression input
----------------------

*note eval(): 5d2. is used for expression input.  It ignores leading
whitespace.  The string argument to *note eval(): 5d2. must have the
following form:

     eval_input ::= expression_list NEWLINE*


File: python.info,  Node: Full Grammar specification,  Prev: Top-level components,  Up: The Python Language Reference

4.10 Full Grammar specification
===============================

This is the full Python grammar, as it is read by the parser generator
and used to parse Python source files:

     # Grammar for Python

     # Note:  Changing the grammar specified in this file will most likely
     #        require corresponding changes in the parser module
     #        (../Modules/parsermodule.c).  If you can't make the changes to
     #        that module yourself, please co-ordinate the required changes
     #        with someone who can; ask around on python-dev for help.  Fred
     #        Drake <fdrake@acm.org> will probably be listening there.

     # NOTE WELL: You should also follow all the steps listed in PEP 306,
     # "How to Change Python's Grammar"

     # Start symbols for the grammar:
     #       single_input is a single interactive statement;
     #       file_input is a module or sequence of commands read from an input file;
     #       eval_input is the input for the eval() functions.
     # NB: compound_stmt in single_input is followed by extra NEWLINE!
     single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE
     file_input: (NEWLINE | stmt)* ENDMARKER
     eval_input: testlist NEWLINE* ENDMARKER

     decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE
     decorators: decorator+
     decorated: decorators (classdef | funcdef)
     funcdef: 'def' NAME parameters ['->' test] ':' suite
     parameters: '(' [typedargslist] ')'
     typedargslist: (tfpdef ['=' test] (',' tfpdef ['=' test])* [','
            ['*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef] | '**' tfpdef]]
          |  '*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef] | '**' tfpdef)
     tfpdef: NAME [':' test]
     varargslist: (vfpdef ['=' test] (',' vfpdef ['=' test])* [','
            ['*' [vfpdef] (',' vfpdef ['=' test])* [',' '**' vfpdef] | '**' vfpdef]]
          |  '*' [vfpdef] (',' vfpdef ['=' test])* [',' '**' vfpdef] | '**' vfpdef)
     vfpdef: NAME

     stmt: simple_stmt | compound_stmt
     simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE
     small_stmt: (expr_stmt | del_stmt | pass_stmt | flow_stmt |
                  import_stmt | global_stmt | nonlocal_stmt | assert_stmt)
     expr_stmt: testlist_star_expr (augassign (yield_expr|testlist) |
                          ('=' (yield_expr|testlist_star_expr))*)
     testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']
     augassign: ('+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' |
                 '<<=' | '>>=' | '**=' | '//=')
     # For normal assignments, additional restrictions enforced by the interpreter
     del_stmt: 'del' exprlist
     pass_stmt: 'pass'
     flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
     break_stmt: 'break'
     continue_stmt: 'continue'
     return_stmt: 'return' [testlist]
     yield_stmt: yield_expr
     raise_stmt: 'raise' [test ['from' test]]
     import_stmt: import_name | import_from
     import_name: 'import' dotted_as_names
     # note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSIS
     import_from: ('from' (('.' | '...')* dotted_name | ('.' | '...')+)
                   'import' ('*' | '(' import_as_names ')' | import_as_names))
     import_as_name: NAME ['as' NAME]
     dotted_as_name: dotted_name ['as' NAME]
     import_as_names: import_as_name (',' import_as_name)* [',']
     dotted_as_names: dotted_as_name (',' dotted_as_name)*
     dotted_name: NAME ('.' NAME)*
     global_stmt: 'global' NAME (',' NAME)*
     nonlocal_stmt: 'nonlocal' NAME (',' NAME)*
     assert_stmt: 'assert' test [',' test]

     compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated
     if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
     while_stmt: 'while' test ':' suite ['else' ':' suite]
     for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]
     try_stmt: ('try' ':' suite
                ((except_clause ':' suite)+
                 ['else' ':' suite]
                 ['finally' ':' suite] |
                'finally' ':' suite))
     with_stmt: 'with' with_item (',' with_item)*  ':' suite
     with_item: test ['as' expr]
     # NB compile.c makes sure that the default except clause is last
     except_clause: 'except' [test ['as' NAME]]
     suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT

     test: or_test ['if' or_test 'else' test] | lambdef
     test_nocond: or_test | lambdef_nocond
     lambdef: 'lambda' [varargslist] ':' test
     lambdef_nocond: 'lambda' [varargslist] ':' test_nocond
     or_test: and_test ('or' and_test)*
     and_test: not_test ('and' not_test)*
     not_test: 'not' not_test | comparison
     comparison: expr (comp_op expr)*
     # <> isn't actually a valid comparison operator in Python. It's here for the
     # sake of a __future__ import described in PEP 401
     comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'
     star_expr: '*' expr
     expr: xor_expr ('|' xor_expr)*
     xor_expr: and_expr ('^' and_expr)*
     and_expr: shift_expr ('&' shift_expr)*
     shift_expr: arith_expr (('<<'|'>>') arith_expr)*
     arith_expr: term (('+'|'-') term)*
     term: factor (('*'|'/'|'%'|'//') factor)*
     factor: ('+'|'-'|'~') factor | power
     power: atom trailer* ['**' factor]
     atom: ('(' [yield_expr|testlist_comp] ')' |
            '[' [testlist_comp] ']' |
            '{' [dictorsetmaker] '}' |
            NAME | NUMBER | STRING+ | '...' | 'None' | 'True' | 'False')
     testlist_comp: (test|star_expr) ( comp_for | (',' (test|star_expr))* [','] )
     trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
     subscriptlist: subscript (',' subscript)* [',']
     subscript: test | [test] ':' [test] [sliceop]
     sliceop: ':' [test]
     exprlist: (expr|star_expr) (',' (expr|star_expr))* [',']
     testlist: test (',' test)* [',']
     dictorsetmaker: ( (test ':' test (comp_for | (',' test ':' test)* [','])) |
                       (test (comp_for | (',' test)* [','])) )

     classdef: 'class' NAME ['(' [arglist] ')'] ':' suite

     arglist: (argument ',')* (argument [',']
                              |'*' test (',' argument)* [',' '**' test]
                              |'**' test)
     # The reason that keywords are test nodes instead of NAME is that using NAME
     # results in an ambiguity. ast.c makes sure it's a NAME.
     argument: test [comp_for] | test '=' test  # Really [keyword '='] test
     comp_iter: comp_for | comp_if
     comp_for: 'for' exprlist 'in' or_test [comp_iter]
     comp_if: 'if' test_nocond [comp_iter]

     # not used in grammar, but may appear in "node" passed from Parser to Compiler
     encoding_decl: NAME

     yield_expr: 'yield' [yield_arg]
     yield_arg: 'from' test | testlist


File: python.info,  Node: The Python Standard Library,  Next: Extending and Embedding the Python Interpreter,  Prev: The Python Language Reference,  Up: Top

5 The Python Standard Library
*****************************

While *note The Python Language Reference: 9f2. describes the exact
syntax and semantics of the Python language, this library reference
manual describes the standard library that is distributed with Python.
It also describes some of the optional components that are commonly
included in Python distributions.

Python’s standard library is very extensive, offering a wide range of
facilities as indicated by the long table of contents listed below.  The
library contains built-in modules (written in C) that provide access to
system functionality such as file I/O that would otherwise be
inaccessible to Python programmers, as well as modules written in Python
that provide standardized solutions for many problems that occur in
everyday programming.  Some of these modules are explicitly designed to
encourage and enhance the portability of Python programs by abstracting
away platform-specifics into platform-neutral APIs.

The Python installers for the Windows platform usually includes the
entire standard library and often also include many additional
components.  For Unix-like operating systems Python is normally provided
as a collection of packages, so it may be necessary to use the packaging
tools provided with the operating system to obtain some or all of the
optional components.

In addition to the standard library, there is a growing collection of
several thousand components (from individual programs and modules to
packages and entire application development frameworks), available from
the Python Package Index(1).

* Menu:

* Introduction: Introduction<5>. 
* Built-in Functions:: 
* Built-in Constants:: 
* Built-in Types:: 
* Built-in Exceptions:: 
* Text Processing Services:: 
* Binary Data Services:: 
* Data Types:: 
* Numeric and Mathematical Modules:: 
* Functional Programming Modules:: 
* File and Directory Access:: 
* Data Persistence:: 
* Data Compression and Archiving:: 
* File Formats:: 
* Cryptographic Services:: 
* Generic Operating System Services:: 
* Concurrent Execution:: 
* Interprocess Communication and Networking:: 
* Internet Data Handling:: 
* Structured Markup Processing Tools:: 
* Internet Protocols and Support:: 
* Multimedia Services:: 
* Internationalization:: 
* Program Frameworks:: 
* Graphical User Interfaces with Tk:: 
* Development Tools:: 
* Debugging and Profiling:: 
* Software Packaging and Distribution:: 
* Python Runtime Services:: 
* Custom Python Interpreters:: 
* Importing Modules:: 
* Python Language Services:: 
* Miscellaneous Services:: 
* MS Windows Specific Services:: 
* Unix Specific Services:: 
* Superseded Modules:: 
* Undocumented Modules:: 

   ---------- Footnotes ----------

   (1) https://pypi.python.org/pypi


File: python.info,  Node: Introduction<5>,  Next: Built-in Functions,  Up: The Python Standard Library

5.1 Introduction
================

The "Python library" contains several different kinds of components.

It contains data types that would normally be considered part of the
"core" of a language, such as numbers and lists.  For these types, the
Python language core defines the form of literals and places some
constraints on their semantics, but does not fully define the semantics.
(On the other hand, the language core does define syntactic properties
like the spelling and priorities of operators.)

The library also contains built-in functions and exceptions — objects
that can be used by all Python code without the need of an *note import:
674. statement.  Some of these are defined by the core language, but
many are not essential for the core semantics and are only described
here.

The bulk of the library, however, consists of a collection of modules.
There are many ways to dissect this collection.  Some modules are
written in C and built in to the Python interpreter; others are written
in Python and imported in source form.  Some modules provide interfaces
that are highly specific to Python, like printing a stack trace; some
provide interfaces that are specific to particular operating systems,
such as access to specific hardware; others provide interfaces that are
specific to a particular application domain, like the World Wide Web.
Some modules are available in all versions and ports of Python; others
are only available when the underlying system supports or requires them;
yet others are available only when a particular configuration option was
chosen at the time when Python was compiled and installed.

This manual is organized "from the inside out:" it first describes the
built-in functions, data types and exceptions, and finally the modules,
grouped in chapters of related modules.

This means that if you start reading this manual from the start, and
skip to the next chapter when you get bored, you will get a reasonable
overview of the available modules and application areas that are
supported by the Python library.  Of course, you don’t `have' to read it
like a novel — you can also browse the table of contents (in front of
the manual), or look for a specific function, module or term in the
index (in the back).  And finally, if you enjoy learning about random
subjects, you choose a random page number (see module *note random: d8.)
and read a section or two.  Regardless of the order in which you read
the sections of this manual, it helps to start with chapter *note
Built-in Functions: 645, as the remainder of the manual assumes
familiarity with this material.

Let the show begin!


File: python.info,  Node: Built-in Functions,  Next: Built-in Constants,  Prev: Introduction<5>,  Up: The Python Standard Library

5.2 Built-in Functions
======================

The Python interpreter has a number of functions and types built into it
that are always available.  They are listed here in alphabetical order.

                                              Built-in Functions
                                              
-------------------------------------------------------------------------------------------------------------------
                                                                                          
*note abs(): aaa.       *note dict(): d7d.    *note help(): 157.     *note min(): 182.    *note setattr(): d7e.
                                                                                          
                                                                                          
*note all(): 804.       *note dir(): 7a8.     *note hex(): 6c9.      *note next(): 6c6.   *note slice(): 88e.
                                                                                          
                                                                                          
*note any(): 803.       *note divmod():       *note id(): 806.       *note object():      *note sorted(): 63e.
                        c40.                                         381.                 
                                                                     
                                                                                          
*note ascii(): 7c8.     *note enumerate():    *note input(): 6cf.    *note oct(): 6c8.    *note staticmethod():
                        869.                                                              3b1.
                                                                                          
                                                                                          
*note bin(): 69b.       *note eval(): 5d2.    *note int(): 185.      *note open(): 1a2.   *note str(): d7f.
                                                                                          
                                                                                          
*note bool(): 87a.      *note exec(): 6a0.    *note isinstance():    *note ord(): bfa.    *note sum(): 868.
                                              798.                                        
                                              
                                                                                          
*note bytearray():      *note filter():       *note issubclass():    *note pow(): 8e0.    *note super(): 311.
17a.                    686.                  799.                                        
                                              
                                                                                          
*note bytes(): 179.     *note float(): 327.   *note iter(): 79a.     *note print():       *note tuple(): d80.
                                                                     21c.                 
                                                                     
                                                                                          
*note callable():       *note format():       *note len(): 358.      *note property():    *note type(): 8c1.
56c.                    556.                                         3ac.                 
                                                                     
                                                                                          
*note chr(): bfb.       *note frozenset():    *note list(): d82.     *note range():       *note vars(): a88.
                        d81.                                         d83.                 
                                                                     
                                                                                          
*note classmethod():    *note getattr():      *note locals(): 7aa.   *note repr(): 3db.   *note zip(): 68a.
3af.                    55f.                                                              
                        
                                                                                          
*note compile(): 6fe.   *note globals():      *note map(): 685.      *note reversed():    *note __import__():
                        d84.                                         188.                 383.
                                                                                          
                                                                                          
*note complex(): 326.   *note hasattr():      *note max(): 183.      *note round():
                        55e.                                         6d1.
                                                                     
                                                                                          
*note delattr(): d85.   *note hash(): 39e.    *note memoryview():    *note set(): d87.
                                              d86.                   
                                              

 -- Function: abs (x)

     Return the absolute value of a number.  The argument may be an
     integer or a floating point number.  If the argument is a complex
     number, its magnitude is returned.

 -- Function: all (iterable)

     Return ‘True’ if all elements of the `iterable' are true (or if the
     iterable is empty).  Equivalent to:

          def all(iterable):
              for element in iterable:
                  if not element:
                      return False
              return True

 -- Function: any (iterable)

     Return ‘True’ if any element of the `iterable' is true.  If the
     iterable is empty, return ‘False’.  Equivalent to:

          def any(iterable):
              for element in iterable:
                  if element:
                      return True
              return False

 -- Function: ascii (object)

     As *note repr(): 3db, return a string containing a printable
     representation of an object, but escape the non-ASCII characters in
     the string returned by *note repr(): 3db. using ‘\x’, ‘\u’ or ‘\U’
     escapes.  This generates a string similar to that returned by *note
     repr(): 3db. in Python 2.

 -- Function: bin (x)

     Convert an integer number to a binary string.  The result is a
     valid Python expression.  If `x' is not a Python *note int: 185.
     object, it has to define an *note __index__(): 6ca. method that
     returns an integer.

 -- Class: bool ([x])

     Return a Boolean value, i.e.  one of ‘True’ or ‘False’.  `x' is
     converted using the standard *note truth testing procedure: d88.
     If `x' is false or omitted, this returns ‘False’; otherwise it
     returns ‘True’.  The *note bool: 87a. class is a subclass of *note
     int: 185. (see *note Numeric Types — int, float, complex: a12.).
     It cannot be subclassed further.  Its only instances are ‘False’
     and ‘True’ (see *note Boolean Values: d89.).

 -- Class: bytearray ([source[, encoding[, errors]]])

     Return a new array of bytes.  The *note bytearray: 17a. class is a
     mutable sequence of integers in the range 0 <= x < 256.  It has
     most of the usual methods of mutable sequences, described in *note
     Mutable Sequence Types: d8b, as well as most methods that the *note
     bytes: 179. type has, see *note Bytes and Bytearray Operations:
     d8c.

     The optional `source' parameter can be used to initialize the array
     in a few different ways:

        * If it is a `string', you must also give the `encoding' (and
          optionally, `errors') parameters; *note bytearray(): 17a. then
          converts the string to bytes using *note str.encode(): 690.

        * If it is an `integer', the array will have that size and will
          be initialized with null bytes.

        * If it is an object conforming to the `buffer' interface, a
          read-only buffer of the object will be used to initialize the
          bytes array.

        * If it is an `iterable', it must be an iterable of integers in
          the range ‘0 <= x < 256’, which are used as the initial
          contents of the array.

     Without an argument, an array of size 0 is created.

     See also *note Binary Sequence Types — bytes, bytearray,
     memoryview: d8d. and *note Bytearray Objects: d8e.
 -- Class: bytes ([source[, encoding[, errors]]])

     Return a new "bytes" object, which is an immutable sequence of
     integers in the range ‘0 <= x < 256’.  *note bytes: 179. is an
     immutable version of *note bytearray: 17a. – it has the same
     non-mutating methods and the same indexing and slicing behavior.

     Accordingly, constructor arguments are interpreted as for *note
     bytearray(): 17a.

     Bytes objects can also be created with literals, see *note String
     and Bytes literals: bbb.

     See also *note Binary Sequence Types — bytes, bytearray,
     memoryview: d8d, *note Bytes: d90, and *note Bytes and Bytearray
     Operations: d8c.

 -- Function: callable (object)

     Return *note True: 805. if the `object' argument appears callable,
     *note False: 3c8. if not.  If this returns true, it is still
     possible that a call fails, but if it is false, calling `object'
     will never succeed.  Note that classes are callable (calling a
     class returns a new instance); instances are callable if their
     class has a *note __call__(): c01. method.

     New in version 3.2: This function was first removed in Python 3.0
     and then brought back in Python 3.2.

 -- Function: chr (i)

     Return the string representing a character whose Unicode code point
     is the integer `i'.  For example, ‘chr(97)’ returns the string
     ‘'a'’.  This is the inverse of *note ord(): bfa.  The valid range
     for the argument is from 0 through 1,114,111 (0x10FFFF in base 16).
     *note ValueError: 321. will be raised if `i' is outside that range.

 -- Function: classmethod (function)

     Return a class method for `function'.

     A class method receives the class as implicit first argument, just
     like an instance method receives the instance.  To declare a class
     method, use this idiom:

          class C:
              @classmethod
              def f(cls, arg1, arg2, ...): ...

     The ‘@classmethod’ form is a function *note decorator: d62. – see
     the description of function definitions in *note Function
     definitions: a4b. for details.

     It can be called either on the class (such as ‘C.f()’) or on an
     instance (such as ‘C().f()’).  The instance is ignored except for
     its class.  If a class method is called for a derived class, the
     derived class object is passed as the implied first argument.

     Class methods are different than C++ or Java static methods.  If
     you want those, see *note staticmethod(): 3b1. in this section.

     For more information on class methods, consult the documentation on
     the standard type hierarchy in *note The standard type hierarchy:
     bf3.

 -- Function: compile (source, filename, mode, flags=0,
          dont_inherit=False, optimize=-1)

     Compile the `source' into a code or AST object.  Code objects can
     be executed by *note exec(): 6a0. or *note eval(): 5d2.  `source'
     can either be a normal string, a byte string, or an AST object.
     Refer to the *note ast: 8. module documentation for information on
     how to work with AST objects.

     The `filename' argument should give the file from which the code
     was read; pass some recognizable value if it wasn’t read from a
     file (‘'<string>'’ is commonly used).

     The `mode' argument specifies what kind of code must be compiled;
     it can be ‘'exec'’ if `source' consists of a sequence of
     statements, ‘'eval'’ if it consists of a single expression, or
     ‘'single'’ if it consists of a single interactive statement (in the
     latter case, expression statements that evaluate to something other
     than ‘None’ will be printed).

     The optional arguments `flags' and `dont_inherit' control which
     future statements (see PEP 236(1)) affect the compilation of
     `source'.  If neither is present (or both are zero) the code is
     compiled with those future statements that are in effect in the
     code that is calling *note compile(): 6fe.  If the `flags' argument
     is given and `dont_inherit' is not (or is zero) then the future
     statements specified by the `flags' argument are used in addition
     to those that would be used anyway.  If `dont_inherit' is a
     non-zero integer then the `flags' argument is it – the future
     statements in effect around the call to compile are ignored.

     Future statements are specified by bits which can be bitwise ORed
     together to specify multiple statements.  The bitfield required to
     specify a given feature can be found as the ‘compiler_flag’
     attribute on the ‘_Feature’ instance in the *note __future__: 0.
     module.

     The argument `optimize' specifies the optimization level of the
     compiler; the default value of ‘-1’ selects the optimization level
     of the interpreter as given by *note -O: 891. options.  Explicit
     levels are ‘0’ (no optimization; ‘__debug__’ is true), ‘1’ (asserts
     are removed, ‘__debug__’ is false) or ‘2’ (docstrings are removed
     too).

     This function raises *note SyntaxError: 319. if the compiled source
     is invalid, and *note TypeError: 309. if the source contains null
     bytes.

     If you want to parse Python code into its AST representation, see
     *note ast.parse(): 98a.

          Note: When compiling a string with multi-line code in
          ‘'single'’ or ‘'eval'’ mode, input must be terminated by at
          least one newline character.  This is to facilitate detection
          of incomplete and complete statements in the *note code: 1b.
          module.

     Changed in version 3.2: Allowed use of Windows and Mac newlines.
     Also input in ‘'exec'’ mode does not have to end in a newline
     anymore.  Added the `optimize' parameter.

 -- Class: complex ([real[, imag]])

     Return a complex number with the value `real' + `imag'*j or convert
     a string or number to a complex number.  If the first parameter is
     a string, it will be interpreted as a complex number and the
     function must be called without a second parameter.  The second
     parameter can never be a string.  Each argument may be any numeric
     type (including complex).  If `imag' is omitted, it defaults to
     zero and the constructor serves as a numeric conversion like *note
     int: 185. and *note float: 327.  If both arguments are omitted,
     returns ‘0j’.

          Note: When converting from a string, the string must not
          contain whitespace around the central ‘+’ or ‘-’ operator.
          For example, ‘complex('1+2j')’ is fine, but ‘complex('1 +
          2j')’ raises *note ValueError: 321.

     The complex type is described in *note Numeric Types — int, float,
     complex: a12.

 -- Function: delattr (object, name)

     This is a relative of *note setattr(): d7e.  The arguments are an
     object and a string.  The string must be the name of one of the
     object’s attributes.  The function deletes the named attribute,
     provided the object allows it.  For example, ‘delattr(x, 'foobar')’
     is equivalent to ‘del x.foobar’.

 -- Class: dict (**kwarg)

 -- Class: dict (mapping, **kwarg)

 -- Class: dict (iterable, **kwarg)

     Create a new dictionary.  The *note dict: 380. object is the
     dictionary class.  See *note dict: 380. and *note Mapping Types —
     dict: a40. for documentation about this class.

     For other containers see the built-in *note list: 397, *note set:
     5a4, and *note tuple: 84e. classes, as well as the *note
     collections: 1e. module.

 -- Function: dir ([object])

     Without arguments, return the list of names in the current local
     scope.  With an argument, attempt to return a list of valid
     attributes for that object.

     If the object has a method named *note __dir__(): 7a9, this method
     will be called and must return the list of attributes.  This allows
     objects that implement a custom *note __getattr__(): 560. or *note
     __getattribute__(): 561. function to customize the way *note dir():
     7a8. reports their attributes.

     If the object does not provide *note __dir__(): 7a9, the function
     tries its best to gather information from the object’s ‘__dict__’
     attribute, if defined, and from its type object.  The resulting
     list is not necessarily complete, and may be inaccurate when the
     object has a custom *note __getattr__(): 560.

     The default *note dir(): 7a8. mechanism behaves differently with
     different types of objects, as it attempts to produce the most
     relevant, rather than complete, information:

        * If the object is a module object, the list contains the names
          of the module’s attributes.

        * If the object is a type or class object, the list contains the
          names of its attributes, and recursively of the attributes of
          its bases.

        * Otherwise, the list contains the object’s attributes’ names,
          the names of its class’s attributes, and recursively of the
          attributes of its class’s base classes.

     The resulting list is sorted alphabetically.  For example:

          >>> import struct
          >>> dir()   # show the names in the module namespace
          ['__builtins__', '__name__', 'struct']
          >>> dir(struct)   # show the names in the struct module # doctest: +SKIP
          ['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__',
           '__initializing__', '__loader__', '__name__', '__package__',
           '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',
           'unpack', 'unpack_from']
          >>> class Shape:
          ...     def __dir__(self):
          ...         return ['area', 'perimeter', 'location']
          >>> s = Shape()
          >>> dir(s)
          ['area', 'location', 'perimeter']

          Note: Because *note dir(): 7a8. is supplied primarily as a
          convenience for use at an interactive prompt, it tries to
          supply an interesting set of names more than it tries to
          supply a rigorously or consistently defined set of names, and
          its detailed behavior may change across releases.  For
          example, metaclass attributes are not in the result list when
          the argument is a class.

 -- Function: divmod (a, b)

     Take two (non complex) numbers as arguments and return a pair of
     numbers consisting of their quotient and remainder when using
     integer division.  With mixed operand types, the rules for binary
     arithmetic operators apply.  For integers, the result is the same
     as ‘(a // b, a % b)’.  For floating point numbers the result is
     ‘(q, a % b)’, where `q' is usually ‘math.floor(a / b)’ but may be 1
     less than that.  In any case ‘q * b + a % b’ is very close to `a',
     if ‘a % b’ is non-zero it has the same sign as `b', and ‘0 <= abs(a
     % b) < abs(b)’.

 -- Function: enumerate (iterable, start=0)

     Return an enumerate object.  `iterable' must be a sequence, an
     *note iterator: d91, or some other object which supports iteration.
     The *note __next__(): 6c7. method of the iterator returned by *note
     enumerate(): 869. returns a tuple containing a count (from `start'
     which defaults to 0) and the values obtained from iterating over
     `iterable'.

          >>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
          >>> list(enumerate(seasons))
          [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
          >>> list(enumerate(seasons, start=1))
          [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]

     Equivalent to:

          def enumerate(sequence, start=0):
              n = start
              for elem in sequence:
                  yield n, elem
                  n += 1

 -- Function: eval (expression, globals=None, locals=None)

     The arguments are a string and optional globals and locals.  If
     provided, `globals' must be a dictionary.  If provided, `locals'
     can be any mapping object.

     The `expression' argument is parsed and evaluated as a Python
     expression (technically speaking, a condition list) using the
     `globals' and `locals' dictionaries as global and local namespace.
     If the `globals' dictionary is present and lacks ’__builtins__’,
     the current globals are copied into `globals' before `expression'
     is parsed.  This means that `expression' normally has full access
     to the standard *note builtins: 13. module and restricted
     environments are propagated.  If the `locals' dictionary is omitted
     it defaults to the `globals' dictionary.  If both dictionaries are
     omitted, the expression is executed in the environment where *note
     eval(): 5d2. is called.  The return value is the result of the
     evaluated expression.  Syntax errors are reported as exceptions.
     Example:

          >>> x = 1
          >>> eval('x+1')
          2

     This function can also be used to execute arbitrary code objects
     (such as those created by *note compile(): 6fe.).  In this case
     pass a code object instead of a string.  If the code object has
     been compiled with ‘'exec'’ as the `mode' argument, *note eval():
     5d2.’s return value will be ‘None’.

     Hints: dynamic execution of statements is supported by the *note
     exec(): 6a0. function.  The *note globals(): d84. and *note
     locals(): 7aa. functions returns the current global and local
     dictionary, respectively, which may be useful to pass around for
     use by *note eval(): 5d2. or *note exec(): 6a0.

     See *note ast.literal_eval(): 5d1. for a function that can safely
     evaluate strings with expressions containing only literals.

 -- Function: exec (object[, globals[, locals]])

     This function supports dynamic execution of Python code.  `object'
     must be either a string or a code object.  If it is a string, the
     string is parsed as a suite of Python statements which is then
     executed (unless a syntax error occurs).  (2) If it is a code
     object, it is simply executed.  In all cases, the code that’s
     executed is expected to be valid as file input (see the section
     "File input" in the Reference Manual).  Be aware that the *note
     return: 781. and *note yield: 21b. statements may not be used
     outside of function definitions even within the context of code
     passed to the *note exec(): 6a0. function.  The return value is
     ‘None’.

     In all cases, if the optional parts are omitted, the code is
     executed in the current scope.  If only `globals' is provided, it
     must be a dictionary, which will be used for both the global and
     the local variables.  If `globals' and `locals' are given, they are
     used for the global and local variables, respectively.  If
     provided, `locals' can be any mapping object.  Remember that at
     module level, globals and locals are the same dictionary.  If exec
     gets two separate objects as `globals' and `locals', the code will
     be executed as if it were embedded in a class definition.

     If the `globals' dictionary does not contain a value for the key
     ‘__builtins__’, a reference to the dictionary of the built-in
     module *note builtins: 13. is inserted under that key.  That way
     you can control what builtins are available to the executed code by
     inserting your own ‘__builtins__’ dictionary into `globals' before
     passing it to *note exec(): 6a0.

          Note: The built-in functions *note globals(): d84. and *note
          locals(): 7aa. return the current global and local dictionary,
          respectively, which may be useful to pass around for use as
          the second and third argument to *note exec(): 6a0.

          Note: The default `locals' act as described for function *note
          locals(): 7aa. below: modifications to the default `locals'
          dictionary should not be attempted.  Pass an explicit `locals'
          dictionary if you need to see effects of the code on `locals'
          after function *note exec(): 6a0. returns.

 -- Function: filter (function, iterable)

     Construct an iterator from those elements of `iterable' for which
     `function' returns true.  `iterable' may be either a sequence, a
     container which supports iteration, or an iterator.  If `function'
     is ‘None’, the identity function is assumed, that is, all elements
     of `iterable' that are false are removed.

     Note that ‘filter(function, iterable)’ is equivalent to the
     generator expression ‘(item for item in iterable if
     function(item))’ if function is not ‘None’ and ‘(item for item in
     iterable if item)’ if function is ‘None’.

     See *note itertools.filterfalse(): d92. for the complementary
     function that returns elements of `iterable' for which `function'
     returns false.

 -- Class: float ([x])

     Return a floating point number constructed from a number or string
     `x'.

     If the argument is a string, it should contain a decimal number,
     optionally preceded by a sign, and optionally embedded in
     whitespace.  The optional sign may be ‘'+'’ or ‘'-'’; a ‘'+'’ sign
     has no effect on the value produced.  The argument may also be a
     string representing a NaN (not-a-number), or a positive or negative
     infinity.  More precisely, the input must conform to the following
     grammar after leading and trailing whitespace characters are
     removed:

          sign           ::= "+" | "-"
          infinity       ::= "Infinity" | "inf"
          nan            ::= "nan"
          numeric_value  ::= floatnumber | infinity | nan
          numeric_string ::= [sign] numeric_value

     Here ‘floatnumber’ is the form of a Python floating-point literal,
     described in *note Floating point literals: bde.  Case is not
     significant, so, for example, "inf", "Inf", "INFINITY" and
     "iNfINity" are all acceptable spellings for positive infinity.

     Otherwise, if the argument is an integer or a floating point
     number, a floating point number with the same value (within
     Python’s floating point precision) is returned.  If the argument is
     outside the range of a Python float, an *note OverflowError: 325.
     will be raised.

     For a general Python object ‘x’, ‘float(x)’ delegates to
     ‘x.__float__()’.

     If no argument is given, ‘0.0’ is returned.

     Examples:

          >>> float('+1.23')
          1.23
          >>> float('   -12345\n')
          -12345.0
          >>> float('1e-003')
          0.001
          >>> float('+1E6')
          1000000.0
          >>> float('-Infinity')
          -inf

     The float type is described in *note Numeric Types — int, float,
     complex: a12.

 -- Function: format (value[, format_spec])

     Convert a `value' to a "formatted" representation, as controlled by
     `format_spec'.  The interpretation of `format_spec' will depend on
     the type of the `value' argument, however there is a standard
     formatting syntax that is used by most built-in types: *note Format
     Specification Mini-Language: c0f.

     The default `format_spec' is an empty string which usually gives
     the same effect as calling *note str(value): 178.

     A call to ‘format(value, format_spec)’ is translated to
     ‘type(value).__format__(value, format_spec)’ which bypasses the
     instance dictionary when searching for the value’s *note
     __format__(): 308. method.  A *note TypeError: 309. exception is
     raised if the method search reaches *note object: 381. and the
     `format_spec' is non-empty, or if either the `format_spec' or the
     return value are not strings.

     Changed in version 3.4: ‘object().__format__(format_spec)’ raises
     *note TypeError: 309. if `format_spec' is not an empty string.

 -- Class: frozenset ([iterable])

     Return a new *note frozenset: 63c. object, optionally with elements
     taken from `iterable'.  ‘frozenset’ is a built-in class.  See *note
     frozenset: 63c. and *note Set Types — set, frozenset: d98. for
     documentation about this class.

     For other containers see the built-in *note set: 5a4, *note list:
     397, *note tuple: 84e, and *note dict: 380. classes, as well as the
     *note collections: 1e. module.

 -- Function: getattr (object, name[, default])

     Return the value of the named attribute of `object'.  `name' must
     be a string.  If the string is the name of one of the object’s
     attributes, the result is the value of that attribute.  For
     example, ‘getattr(x, 'foobar')’ is equivalent to ‘x.foobar’.  If
     the named attribute does not exist, `default' is returned if
     provided, otherwise *note AttributeError: 320. is raised.

 -- Function: globals ()

     Return a dictionary representing the current global symbol table.
     This is always the dictionary of the current module (inside a
     function or method, this is the module where it is defined, not the
     module from which it is called).

 -- Function: hasattr (object, name)

     The arguments are an object and a string.  The result is ‘True’ if
     the string is the name of one of the object’s attributes, ‘False’
     if not.  (This is implemented by calling ‘getattr(object, name)’
     and seeing whether it raises an *note AttributeError: 320. or not.)

 -- Function: hash (object)

          Return the hash value of the object (if it has one).  Hash
          values are integers.  They are used to quickly compare
          dictionary keys during a dictionary lookup.  Numeric values
          that compare equal have the same hash value (even if they are
          of different types, as is the case for 1 and 1.0).

          Note: For object’s with custom *note __hash__(): 39f. methods,
          note that *note hash(): 39e. truncates the return value based
          on the bit width of the host machine.  See *note __hash__():
          39f. for details.

 -- Function: help ([object])

     Invoke the built-in help system.  (This function is intended for
     interactive use.)  If no argument is given, the interactive help
     system starts on the interpreter console.  If the argument is a
     string, then the string is looked up as the name of a module,
     function, class, method, keyword, or documentation topic, and a
     help page is printed on the console.  If the argument is any other
     kind of object, a help page on the object is generated.

     This function is added to the built-in namespace by the *note site:
     e6. module.

     Changed in version 3.4: Changes to *note pydoc: d5. and *note
     inspect: 9d. mean that the reported signatures for callables are
     now more comprehensive and consistent.

 -- Function: hex (x)

     Convert an integer number to a lowercase hexadecimal string
     prefixed with "0x", for example:

          >>> hex(255)
          '0xff'
          >>> hex(-42)
          '-0x2a'

     If x is not a Python *note int: 185. object, it has to define an
     __index__() method that returns an integer.

     See also *note int(): 185. for converting a hexadecimal string to
     an integer using a base of 16.

          Note: To obtain a hexadecimal string representation for a
          float, use the *note float.hex(): b0c. method.

 -- Function: id (object)

     Return the "identity" of an object.  This is an integer which is
     guaranteed to be unique and constant for this object during its
     lifetime.  Two objects with non-overlapping lifetimes may have the
     same *note id(): 806. value.

     `CPython implementation detail:' This is the address of the object
     in memory.

 -- Function: input ([prompt])

     If the `prompt' argument is present, it is written to standard
     output without a trailing newline.  The function then reads a line
     from input, converts it to a string (stripping a trailing newline),
     and returns that.  When EOF is read, *note EOFError: 6d0. is
     raised.  Example:

          >>> s = input('--> ')  # doctest: +SKIP
          --> Monty Python's Flying Circus
          >>> s  # doctest: +SKIP
          "Monty Python's Flying Circus"

     If the *note readline: da. module was loaded, then *note input():
     6cf. will use it to provide elaborate line editing and history
     features.

 -- Class: int (x=0)

 -- Class: int (x, base=10)

     Return an integer object constructed from a number or string `x',
     or return ‘0’ if no arguments are given.  If `x' is a number,
     return *note x.__int__(): 727.  For floating point numbers, this
     truncates towards zero.

     If `x' is not a number or if `base' is given, then `x' must be a
     string, *note bytes: 179, or *note bytearray: 17a. instance
     representing an *note integer literal: bd2. in radix `base'.
     Optionally, the literal can be preceded by ‘+’ or ‘-’ (with no
     space in between) and surrounded by whitespace.  A base-n literal
     consists of the digits 0 to n-1, with ‘a’ to ‘z’ (or ‘A’ to ‘Z’)
     having values 10 to 35.  The default `base' is 10.  The allowed
     values are 0 and 2-36.  Base-2, -8, and -16 literals can be
     optionally prefixed with ‘0b’/‘0B’, ‘0o’/‘0O’, or ‘0x’/‘0X’, as
     with integer literals in code.  Base 0 means to interpret exactly
     as a code literal, so that the actual base is 2, 8, 10, or 16, and
     so that ‘int('010', 0)’ is not legal, while ‘int('010')’ is, as
     well as ‘int('010', 8)’.

     The integer type is described in *note Numeric Types — int, float,
     complex: a12.

     Changed in version 3.4: If `base' is not an instance of *note int:
     185. and the `base' object has a *note base.__index__: 6ca. method,
     that method is called to obtain an integer for the base.  Previous
     versions used *note base.__int__: 727. instead of *note
     base.__index__: 6ca.

 -- Function: isinstance (object, classinfo)

     Return true if the `object' argument is an instance of the
     `classinfo' argument, or of a (direct, indirect or *note virtual:
     550.) subclass thereof.  If `object' is not an object of the given
     type, the function always returns false.  If `classinfo' is not a
     class (type object), it may be a tuple of type objects, or may
     recursively contain other such tuples (other sequence types are not
     accepted).  If `classinfo' is not a type or tuple of types and such
     tuples, a *note TypeError: 309. exception is raised.

 -- Function: issubclass (class, classinfo)

     Return true if `class' is a subclass (direct, indirect or *note
     virtual: 550.) of `classinfo'.  A class is considered a subclass of
     itself.  `classinfo' may be a tuple of class objects, in which case
     every entry in `classinfo' will be checked.  In any other case, a
     *note TypeError: 309. exception is raised.

 -- Function: iter (object[, sentinel])

     Return an *note iterator: d91. object.  The first argument is
     interpreted very differently depending on the presence of the
     second argument.  Without a second argument, `object' must be a
     collection object which supports the iteration protocol (the *note
     __iter__(): 79b. method), or it must support the sequence protocol
     (the *note __getitem__(): 88d. method with integer arguments
     starting at ‘0’).  If it does not support either of those
     protocols, *note TypeError: 309. is raised.  If the second
     argument, `sentinel', is given, then `object' must be a callable
     object.  The iterator created in this case will call `object' with
     no arguments for each call to its *note __next__(): 6c7. method; if
     the value returned is equal to `sentinel', *note StopIteration:
     7a5. will be raised, otherwise the value will be returned.

     See also *note Iterator Types: c31.

     One useful application of the second form of *note iter(): 79a. is
     to read lines of a file until a certain line is reached.  The
     following example reads a file until the *note readline(): d99.
     method returns an empty string:

          with open('mydata.txt') as fp:
              for line in iter(fp.readline, ''):
                  process_line(line)

 -- Function: len (s)

     Return the length (the number of items) of an object.  The argument
     may be a sequence (such as a string, bytes, tuple, list, or range)
     or a collection (such as a dictionary, set, or frozen set).

 -- Class: list ([iterable])

     Rather than being a function, *note list: 397. is actually a
     mutable sequence type, as documented in *note Lists: d9a. and *note
     Sequence Types — list, tuple, range: a5f.

 -- Function: locals ()

     Update and return a dictionary representing the current local
     symbol table.  Free variables are returned by *note locals(): 7aa.
     when it is called in function blocks, but not in class blocks.

          Note: The contents of this dictionary should not be modified;
          changes may not affect the values of local and free variables
          used by the interpreter.

 -- Function: map (function, iterable, ...)

     Return an iterator that applies `function' to every item of
     `iterable', yielding the results.  If additional `iterable'
     arguments are passed, `function' must take that many arguments and
     is applied to the items from all iterables in parallel.  With
     multiple iterables, the iterator stops when the shortest iterable
     is exhausted.  For cases where the function inputs are already
     arranged into argument tuples, see *note itertools.starmap(): 419.

 -- Function: max (iterable, *[, key, default])

 -- Function: max (arg1, arg2, *args[, key])

     Return the largest item in an iterable or the largest of two or
     more arguments.

     If one positional argument is provided, it should be an *note
     iterable: 5f6.  The largest item in the iterable is returned.  If
     two or more positional arguments are provided, the largest of the
     positional arguments is returned.

     There are two optional keyword-only arguments.  The `key' argument
     specifies a one-argument ordering function like that used for *note
     list.sort(): 63d.  The `default' argument specifies an object to
     return if the provided iterable is empty.  If the iterable is empty
     and `default' is not provided, a *note ValueError: 321. is raised.

     If multiple items are maximal, the function returns the first one
     encountered.  This is consistent with other sort-stability
     preserving tools such as ‘sorted(iterable, key=keyfunc,
     reverse=True)[0]’ and ‘heapq.nlargest(1, iterable, key=keyfunc)’.

     New in version 3.4: The `default' keyword-only argument.

 -- Function: memoryview (obj)

     Return a "memory view" object created from the given argument.  See
     *note Memory Views: d9b. for more information.

 -- Function: min (iterable, *[, key, default])

 -- Function: min (arg1, arg2, *args[, key])

     Return the smallest item in an iterable or the smallest of two or
     more arguments.

     If one positional argument is provided, it should be an *note
     iterable: 5f6.  The smallest item in the iterable is returned.  If
     two or more positional arguments are provided, the smallest of the
     positional arguments is returned.

     There are two optional keyword-only arguments.  The `key' argument
     specifies a one-argument ordering function like that used for *note
     list.sort(): 63d.  The `default' argument specifies an object to
     return if the provided iterable is empty.  If the iterable is empty
     and `default' is not provided, a *note ValueError: 321. is raised.

     If multiple items are minimal, the function returns the first one
     encountered.  This is consistent with other sort-stability
     preserving tools such as ‘sorted(iterable, key=keyfunc)[0]’ and
     ‘heapq.nsmallest(1, iterable, key=keyfunc)’.

     New in version 3.4: The `default' keyword-only argument.

 -- Function: next (iterator[, default])

     Retrieve the next item from the `iterator' by calling its *note
     __next__(): 6c7. method.  If `default' is given, it is returned if
     the iterator is exhausted, otherwise *note StopIteration: 7a5. is
     raised.

 -- Class: object

     Return a new featureless object.  *note object: 381. is a base for
     all classes.  It has the methods that are common to all instances
     of Python classes.  This function does not accept any arguments.

          Note: *note object: 381. does `not' have a *note __dict__:
          c07, so you can’t assign arbitrary attributes to an instance
          of the *note object: 381. class.

 -- Function: oct (x)

     Convert an integer number to an octal string.  The result is a
     valid Python expression.  If `x' is not a Python *note int: 185.
     object, it has to define an *note __index__(): 6ca. method that
     returns an integer.

 -- Function: open (file, mode='r', buffering=-1, encoding=None,
          errors=None, newline=None, closefd=True, opener=None)

     Open `file' and return a corresponding *note file object: 56a.  If
     the file cannot be opened, an *note OSError: 254. is raised.

     `file' is either a string or bytes object giving the pathname
     (absolute or relative to the current working directory) of the file
     to be opened or an integer file descriptor of the file to be
     wrapped.  (If a file descriptor is given, it is closed when the
     returned I/O object is closed, unless `closefd' is set to ‘False’.)

     `mode' is an optional string that specifies the mode in which the
     file is opened.  It defaults to ‘'r'’ which means open for reading
     in text mode.  Other common values are ‘'w'’ for writing
     (truncating the file if it already exists), ‘'x'’ for exclusive
     creation and ‘'a'’ for appending (which on `some' Unix systems,
     means that `all' writes append to the end of the file regardless of
     the current seek position).  In text mode, if `encoding' is not
     specified the encoding used is platform dependent:
     ‘locale.getpreferredencoding(False)’ is called to get the current
     locale encoding.  (For reading and writing raw bytes use binary
     mode and leave `encoding' unspecified.)  The available modes are:

     Character     Meaning
                   
     ----------------------------------------------------------------------------------
                   
     ‘'r'’         open for reading (default)
                   
                   
     ‘'w'’         open for writing, truncating the file first
                   
                   
     ‘'x'’         open for exclusive creation, failing if the file already exists
                   
                   
     ‘'a'’         open for writing, appending to the end of the file if it exists
                   
                   
     ‘'b'’         binary mode
                   
                   
     ‘'t'’         text mode (default)
                   
                   
     ‘'+'’         open a disk file for updating (reading and writing)
                   
                   
     ‘'U'’         *note universal newlines: 794. mode (deprecated)
                   

     The default mode is ‘'r'’ (open for reading text, synonym of
     ‘'rt'’).  For binary read-write access, the mode ‘'w+b'’ opens and
     truncates the file to 0 bytes.  ‘'r+b'’ opens the file without
     truncation.

     As mentioned in the *note Overview: d9c, Python distinguishes
     between binary and text I/O. Files opened in binary mode (including
     ‘'b'’ in the `mode' argument) return contents as *note bytes: 179.
     objects without any decoding.  In text mode (the default, or when
     ‘'t'’ is included in the `mode' argument), the contents of the file
     are returned as *note str: 178, the bytes having been first decoded
     using a platform-dependent encoding or using the specified
     `encoding' if given.

          Note: Python doesn’t depend on the underlying operating
          system’s notion of text files; all the processing is done by
          Python itself, and is therefore platform-independent.

     `buffering' is an optional integer used to set the buffering
     policy.  Pass 0 to switch buffering off (only allowed in binary
     mode), 1 to select line buffering (only usable in text mode), and
     an integer > 1 to indicate the size in bytes of a fixed-size chunk
     buffer.  When no `buffering' argument is given, the default
     buffering policy works as follows:

        * Binary files are buffered in fixed-size chunks; the size of
          the buffer is chosen using a heuristic trying to determine the
          underlying device’s "block size" and falling back on *note
          io.DEFAULT_BUFFER_SIZE: d9d.  On many systems, the buffer will
          typically be 4096 or 8192 bytes long.

        * "Interactive" text files (files for which *note isatty(): d9e.
          returns ‘True’) use line buffering.  Other text files use the
          policy described above for binary files.

     `encoding' is the name of the encoding used to decode or encode the
     file.  This should only be used in text mode.  The default encoding
     is platform dependent (whatever *note
     locale.getpreferredencoding(): d9f. returns), but any *note text
     encoding: da0. supported by Python can be used.  See the *note
     codecs: 1c. module for the list of supported encodings.

     `errors' is an optional string that specifies how encoding and
     decoding errors are to be handled–this cannot be used in binary
     mode.  A variety of standard error handlers are available (listed
     under *note Error Handlers: da1.), though any error handling name
     that has been registered with *note codecs.register_error(): 87c.
     is also valid.  The standard names include:

        * ‘'strict'’ to raise a *note ValueError: 321. exception if
          there is an encoding error.  The default value of ‘None’ has
          the same effect.

        * ‘'ignore'’ ignores errors.  Note that ignoring encoding errors
          can lead to data loss.

        * ‘'replace'’ causes a replacement marker (such as ‘'?'’) to be
          inserted where there is malformed data.

        * ‘'surrogateescape'’ will represent any incorrect bytes as code
          points in the Unicode Private Use Area ranging from U+DC80 to
          U+DCFF. These private code points will then be turned back
          into the same bytes when the ‘surrogateescape’ error handler
          is used when writing data.  This is useful for processing
          files in an unknown encoding.

        * ‘'xmlcharrefreplace'’ is only supported when writing to a
          file.  Characters not supported by the encoding are replaced
          with the appropriate XML character reference ‘&#nnn;’.

        * ‘'backslashreplace'’ (also only supported when writing)
          replaces unsupported characters with Python’s backslashed
          escape sequences.

     `newline' controls how *note universal newlines: 794. mode works
     (it only applies to text mode).  It can be ‘None’, ‘''’, ‘'\n'’,
     ‘'\r'’, and ‘'\r\n'’.  It works as follows:

        * When reading input from the stream, if `newline' is ‘None’,
          universal newlines mode is enabled.  Lines in the input can
          end in ‘'\n'’, ‘'\r'’, or ‘'\r\n'’, and these are translated
          into ‘'\n'’ before being returned to the caller.  If it is
          ‘''’, universal newlines mode is enabled, but line endings are
          returned to the caller untranslated.  If it has any of the
          other legal values, input lines are only terminated by the
          given string, and the line ending is returned to the caller
          untranslated.

        * When writing output to the stream, if `newline' is ‘None’, any
          ‘'\n'’ characters written are translated to the system default
          line separator, *note os.linesep: da2.  If `newline' is ‘''’
          or ‘'\n'’, no translation takes place.  If `newline' is any of
          the other legal values, any ‘'\n'’ characters written are
          translated to the given string.

     If `closefd' is ‘False’ and a file descriptor rather than a
     filename was given, the underlying file descriptor will be kept
     open when the file is closed.  If a filename is given `closefd' has
     no effect and must be ‘True’ (the default).

     A custom opener can be used by passing a callable as `opener'.  The
     underlying file descriptor for the file object is then obtained by
     calling `opener' with (`file', `flags').  `opener' must return an
     open file descriptor (passing *note os.open: 217. as `opener'
     results in functionality similar to passing ‘None’).

     The newly created file is *note non-inheritable: 170.

     The following example uses the *note dir_fd: 424. parameter of the
     *note os.open(): 217. function to open a file relative to a given
     directory:

          >>> import os
          >>> dir_fd = os.open('somedir', os.O_RDONLY)
          >>> def opener(path, flags):
          ...     return os.open(path, flags, dir_fd=dir_fd)
          ...
          >>> with open('spamspam.txt', 'w', opener=opener) as f:
          ...     print('This will be written to somedir/spamspam.txt', file=f)
          ...
          >>> os.close(dir_fd)  # don't leak a file descriptor

     The type of *note file object: 56a. returned by the *note open():
     1a2. function depends on the mode.  When *note open(): 1a2. is used
     to open a file in a text mode (‘'w'’, ‘'r'’, ‘'wt'’, ‘'rt'’, etc.),
     it returns a subclass of *note io.TextIOBase: 693. (specifically
     *note io.TextIOWrapper: 2fd.).  When used to open a file in a
     binary mode with buffering, the returned class is a subclass of
     *note io.BufferedIOBase: 3b9.  The exact class varies: in read
     binary mode, it returns a *note io.BufferedReader: 5c9.; in write
     binary and append binary modes, it returns a *note
     io.BufferedWriter: da3, and in read/write mode, it returns a *note
     io.BufferedRandom: da4.  When buffering is disabled, the raw
     stream, a subclass of *note io.RawIOBase: 3fe, *note io.FileIO:
     714, is returned.

     See also the file handling modules, such as, *note fileinput: 7e,
     *note io: 9e. (where *note open(): 1a2. is declared), *note os: c0,
     *note os.path: c1, *note tempfile: fe, and *note shutil: e4.

     Changed in version 3.3: The `opener' parameter was added.  The
     ‘'x'’ mode was added.  *note IOError: 360. used to be raised, it is
     now an alias of *note OSError: 254.  *note FileExistsError: 316. is
     now raised if the file opened in exclusive creation mode (‘'x'’)
     already exists.

     Changed in version 3.4: The file is now non-inheritable.

     Deprecated since version 3.4, will be removed in version 4.0: The
     ‘'U'’ mode.

 -- Function: ord (c)

     Given a string representing one Unicode character, return an
     integer representing the Unicode code point of that character.  For
     example, ‘ord('a')’ returns the integer ‘97’ and ‘ord('\u2020')’
     returns ‘8224’.  This is the inverse of *note chr(): bfb.

 -- Function: pow (x, y[, z])

     Return `x' to the power `y'; if `z' is present, return `x' to the
     power `y', modulo `z' (computed more efficiently than ‘pow(x, y) %
     z’).  The two-argument form ‘pow(x, y)’ is equivalent to using the
     power operator: ‘x**y’.

     The arguments must have numeric types.  With mixed operand types,
     the coercion rules for binary arithmetic operators apply.  For
     *note int: 185. operands, the result has the same type as the
     operands (after coercion) unless the second argument is negative;
     in that case, all arguments are converted to float and a float
     result is delivered.  For example, ‘10**2’ returns ‘100’, but
     ‘10**-2’ returns ‘0.01’.  If the second argument is negative, the
     third argument must be omitted.  If `z' is present, `x' and `y'
     must be of integer types, and `y' must be non-negative.

 -- Function: print (*objects, sep=' ', end='\n', file=sys.stdout,
          flush=False)

     Print `objects' to the text stream `file', separated by `sep' and
     followed by `end'.  `sep', `end' and `file', if present, must be
     given as keyword arguments.

     All non-keyword arguments are converted to strings like *note
     str(): 178. does and written to the stream, separated by `sep' and
     followed by `end'.  Both `sep' and `end' must be strings; they can
     also be ‘None’, which means to use the default values.  If no
     `objects' are given, *note print(): 21c. will just write `end'.

     The `file' argument must be an object with a ‘write(string)’
     method; if it is not present or ‘None’, *note sys.stdout: 1b0. will
     be used.  Since printed arguments are converted to text strings,
     *note print(): 21c. cannot be used with binary mode file objects.
     For these, use ‘file.write(...)’ instead.

     Whether output is buffered is usually determined by `file', but if
     the `flush' keyword argument is true, the stream is forcibly
     flushed.

     Changed in version 3.3: Added the `flush' keyword argument.

 -- Class: property (fget=None, fset=None, fdel=None, doc=None)

     Return a property attribute.

     `fget' is a function for getting an attribute value.  `fset' is a
     function for setting an attribute value.  `fdel' is a function for
     deleting an attribute value.  And `doc' creates a docstring for the
     attribute.

     A typical use is to define a managed attribute ‘x’:

          class C:
              def __init__(self):
                  self._x = None

              def getx(self):
                  return self._x

              def setx(self, value):
                  self._x = value

              def delx(self):
                  del self._x

              x = property(getx, setx, delx, "I'm the 'x' property.")

     If `c' is an instance of `C', ‘c.x’ will invoke the getter, ‘c.x =
     value’ will invoke the setter and ‘del c.x’ the deleter.

     If given, `doc' will be the docstring of the property attribute.
     Otherwise, the property will copy `fget'’s docstring (if it
     exists).  This makes it possible to create read-only properties
     easily using *note property(): 3ac. as a *note decorator: d62.:

          class Parrot:
              def __init__(self):
                  self._voltage = 100000

              @property
              def voltage(self):
                  """Get the current voltage."""
                  return self._voltage

     The ‘@property’ decorator turns the ‘voltage()’ method into a
     "getter" for a read-only attribute with the same name, and it sets
     the docstring for `voltage' to "Get the current voltage."

     A property object has ‘getter’, ‘setter’, and ‘deleter’ methods
     usable as decorators that create a copy of the property with the
     corresponding accessor function set to the decorated function.
     This is best explained with an example:

          class C:
              def __init__(self):
                  self._x = None

              @property
              def x(self):
                  """I'm the 'x' property."""
                  return self._x

              @x.setter
              def x(self, value):
                  self._x = value

              @x.deleter
              def x(self):
                  del self._x

     This code is exactly equivalent to the first example.  Be sure to
     give the additional functions the same name as the original
     property (‘x’ in this case.)

     The returned property object also has the attributes ‘fget’,
     ‘fset’, and ‘fdel’ corresponding to the constructor arguments.

 -- Function: range (stop)

 -- Function: range (start, stop[, step])

     Rather than being a function, *note range: 396. is actually an
     immutable sequence type, as documented in *note Ranges: da5. and
     *note Sequence Types — list, tuple, range: a5f.

 -- Function: repr (object)

     Return a string containing a printable representation of an object.
     For many types, this function makes an attempt to return a string
     that would yield an object with the same value when passed to *note
     eval(): 5d2, otherwise the representation is a string enclosed in
     angle brackets that contains the name of the type of the object
     together with additional information often including the name and
     address of the object.  A class can control what this function
     returns for its instances by defining a *note __repr__(): 5a3.
     method.

 -- Function: reversed (seq)

     Return a reverse *note iterator: d91.  `seq' must be an object
     which has a *note __reversed__(): c32. method or supports the
     sequence protocol (the *note __len__(): 84f. method and the *note
     __getitem__(): 88d. method with integer arguments starting at ‘0’).

 -- Function: round (number[, ndigits])

     Return the floating point value `number' rounded to `ndigits'
     digits after the decimal point.  If `ndigits' is omitted, it
     defaults to zero.  Delegates to ‘number.__round__(ndigits)’.

     For the built-in types supporting *note round(): 6d1, values are
     rounded to the closest multiple of 10 to the power minus `ndigits';
     if two multiples are equally close, rounding is done toward the
     even choice (so, for example, both ‘round(0.5)’ and ‘round(-0.5)’
     are ‘0’, and ‘round(1.5)’ is ‘2’).  The return value is an integer
     if called with one argument, otherwise of the same type as
     `number'.

          Note: The behavior of *note round(): 6d1. for floats can be
          surprising: for example, ‘round(2.675, 2)’ gives ‘2.67’
          instead of the expected ‘2.68’.  This is not a bug: it’s a
          result of the fact that most decimal fractions can’t be
          represented exactly as a float.  See *note Floating Point
          Arithmetic; Issues and Limitations: b08. for more information.

 -- Class: set ([iterable])

     Return a new *note set: 5a4. object, optionally with elements taken
     from `iterable'.  ‘set’ is a built-in class.  See *note set: 5a4.
     and *note Set Types — set, frozenset: d98. for documentation about
     this class.

     For other containers see the built-in *note frozenset: 63c, *note
     list: 397, *note tuple: 84e, and *note dict: 380. classes, as well
     as the *note collections: 1e. module.

 -- Function: setattr (object, name, value)

     This is the counterpart of *note getattr(): 55f.  The arguments are
     an object, a string and an arbitrary value.  The string may name an
     existing attribute or a new attribute.  The function assigns the
     value to the attribute, provided the object allows it.  For
     example, ‘setattr(x, 'foobar', 123)’ is equivalent to ‘x.foobar =
     123’.

 -- Class: slice (stop)

 -- Class: slice (start, stop[, step])

     Return a *note slice: da6. object representing the set of indices
     specified by ‘range(start, stop, step)’.  The `start' and `step'
     arguments default to ‘None’.  Slice objects have read-only data
     attributes ‘start’, ‘stop’ and ‘step’ which merely return the
     argument values (or their default).  They have no other explicit
     functionality; however they are used by Numerical Python and other
     third party extensions.  Slice objects are also generated when
     extended indexing syntax is used.  For example:
     ‘a[start:stop:step]’ or ‘a[start:stop, i]’.  See *note
     itertools.islice(): 813. for an alternate version that returns an
     iterator.

 -- Function: sorted (iterable[, key][, reverse])

     Return a new sorted list from the items in `iterable'.

     Has two optional arguments which must be specified as keyword
     arguments.

     `key' specifies a function of one argument that is used to extract
     a comparison key from each list element: ‘key=str.lower’.  The
     default value is ‘None’ (compare the elements directly).

     `reverse' is a boolean value.  If set to ‘True’, then the list
     elements are sorted as if each comparison were reversed.

     Use *note functools.cmp_to_key(): 581. to convert an old-style
     `cmp' function to a `key' function.

     The built-in *note sorted(): 63e. function is guaranteed to be
     stable.  A sort is stable if it guarantees not to change the
     relative order of elements that compare equal — this is helpful for
     sorting in multiple passes (for example, sort by department, then
     by salary grade).

     For sorting examples and a brief sorting tutorial, see Sorting
     HowTo(3).

 -- Function: staticmethod (function)

     Return a static method for `function'.

     A static method does not receive an implicit first argument.  To
     declare a static method, use this idiom:

          class C:
              @staticmethod
              def f(arg1, arg2, ...): ...

     The ‘@staticmethod’ form is a function *note decorator: d62. – see
     the description of function definitions in *note Function
     definitions: a4b. for details.

     It can be called either on the class (such as ‘C.f()’) or on an
     instance (such as ‘C().f()’).  The instance is ignored except for
     its class.

     Static methods in Python are similar to those found in Java or C++.
     Also see *note classmethod(): 3af. for a variant that is useful for
     creating alternate class constructors.

     For more information on static methods, consult the documentation
     on the standard type hierarchy in *note The standard type
     hierarchy: bf3.

 -- Class: str (object='')

 -- Class: str (object=b'', encoding='utf-8', errors='strict')

     Return a *note str: 178. version of `object'.  See *note str():
     178. for details.

     ‘str’ is the built-in string *note class: da7.  For general
     information about strings, see *note Text Sequence Type — str: a16.

 -- Function: sum (iterable[, start])

     Sums `start' and the items of an `iterable' from left to right and
     returns the total.  `start' defaults to ‘0’.  The `iterable'’s
     items are normally numbers, and the start value is not allowed to
     be a string.

     For some use cases, there are good alternatives to *note sum():
     868.  The preferred, fast way to concatenate a sequence of strings
     is by calling ‘''.join(sequence)’.  To add floating point values
     with extended precision, see *note math.fsum(): 7b7.  To
     concatenate a series of iterables, consider using *note
     itertools.chain(): da8.

 -- Function: super ([type[, object-or-type]])

     Return a proxy object that delegates method calls to a parent or
     sibling class of `type'.  This is useful for accessing inherited
     methods that have been overridden in a class.  The search order is
     same as that used by *note getattr(): 55f. except that the `type'
     itself is skipped.

     The *note __mro__: da9. attribute of the `type' lists the method
     resolution search order used by both *note getattr(): 55f. and
     *note super(): 311.  The attribute is dynamic and can change
     whenever the inheritance hierarchy is updated.

     If the second argument is omitted, the super object returned is
     unbound.  If the second argument is an object, ‘isinstance(obj,
     type)’ must be true.  If the second argument is a type,
     ‘issubclass(type2, type)’ must be true (this is useful for
     classmethods).

     There are two typical use cases for `super'.  In a class hierarchy
     with single inheritance, `super' can be used to refer to parent
     classes without naming them explicitly, thus making the code more
     maintainable.  This use closely parallels the use of `super' in
     other programming languages.

     The second use case is to support cooperative multiple inheritance
     in a dynamic execution environment.  This use case is unique to
     Python and is not found in statically compiled languages or
     languages that only support single inheritance.  This makes it
     possible to implement "diamond diagrams" where multiple base
     classes implement the same method.  Good design dictates that this
     method have the same calling signature in every case (because the
     order of calls is determined at runtime, because that order adapts
     to changes in the class hierarchy, and because that order can
     include sibling classes that are unknown prior to runtime).

     For both use cases, a typical superclass call looks like this:

          class C(B):
              def method(self, arg):
                  super().method(arg)    # This does the same thing as:
                                         # super(C, self).method(arg)

     Note that *note super(): 311. is implemented as part of the binding
     process for explicit dotted attribute lookups such as
     ‘super().__getitem__(name)’.  It does so by implementing its own
     *note __getattribute__(): 561. method for searching classes in a
     predictable order that supports cooperative multiple inheritance.
     Accordingly, *note super(): 311. is undefined for implicit lookups
     using statements or operators such as ‘super()[name]’.

     Also note that, aside from the zero argument form, *note super():
     311. is not limited to use inside methods.  The two argument form
     specifies the arguments exactly and makes the appropriate
     references.  The zero argument form only works inside a class
     definition, as the compiler fills in the necessary details to
     correctly retrieve the class being defined, as well as accessing
     the current instance for ordinary methods.

     For practical suggestions on how to design cooperative classes
     using *note super(): 311, see guide to using super()(4).

 -- Function: tuple ([iterable])

     Rather than being a function, *note tuple: 84e. is actually an
     immutable sequence type, as documented in *note Tuples: daa. and
     *note Sequence Types — list, tuple, range: a5f.

 -- Class: type (object)

 -- Class: type (name, bases, dict)

     With one argument, return the type of an `object'.  The return
     value is a type object and generally the same object as returned by
     *note object.__class__: c08.

     The *note isinstance(): 798. built-in function is recommended for
     testing the type of an object, because it takes subclasses into
     account.

     With three arguments, return a new type object.  This is
     essentially a dynamic form of the *note class: 6ce. statement.  The
     `name' string is the class name and becomes the *note __name__:
     dab. attribute; the `bases' tuple itemizes the base classes and
     becomes the *note __bases__: c05. attribute; and the `dict'
     dictionary is the namespace containing definitions for class body
     and becomes the *note __dict__: c07. attribute.  For example, the
     following two statements create identical *note type: 8c1. objects:

          >>> class X:
          ...     a = 1
          ...
          >>> X = type('X', (object,), dict(a=1))

     See also *note Type Objects: dac.

 -- Function: vars ([object])

     Return the *note __dict__: c07. attribute for a module, class,
     instance, or any other object with a ‘__dict__’ attribute.

     Objects such as modules and instances have an updateable ‘__dict__’
     attribute; however, other objects may have write restrictions on
     their ‘__dict__’ attributes (for example, classes use a dictproxy
     to prevent direct dictionary updates).

     Without an argument, *note vars(): a88. acts like *note locals():
     7aa.  Note, the locals dictionary is only useful for reads since
     updates to the locals dictionary are ignored.

 -- Function: zip (*iterables)

     Make an iterator that aggregates elements from each of the
     iterables.

     Returns an iterator of tuples, where the `i'-th tuple contains the
     `i'-th element from each of the argument sequences or iterables.
     The iterator stops when the shortest input iterable is exhausted.
     With a single iterable argument, it returns an iterator of
     1-tuples.  With no arguments, it returns an empty iterator.
     Equivalent to:

          def zip(*iterables):
              # zip('ABCD', 'xy') --> Ax By
              sentinel = object()
              iterators = [iter(it) for it in iterables]
              while iterators:
                  result = []
                  for it in iterators:
                      elem = next(it, sentinel)
                      if elem is sentinel:
                          return
                      result.append(elem)
                  yield tuple(result)

     The left-to-right evaluation order of the iterables is guaranteed.
     This makes possible an idiom for clustering a data series into
     n-length groups using ‘zip(*[iter(s)]*n)’.

     *note zip(): 68a. should only be used with unequal length inputs
     when you don’t care about trailing, unmatched values from the
     longer iterables.  If those values are important, use *note
     itertools.zip_longest(): 689. instead.

     *note zip(): 68a. in conjunction with the ‘*’ operator can be used
     to unzip a list:

          >>> x = [1, 2, 3]
          >>> y = [4, 5, 6]
          >>> zipped = zip(x, y)
          >>> list(zipped)
          [(1, 4), (2, 5), (3, 6)]
          >>> x2, y2 = zip(*zip(x, y))
          >>> x == list(x2) and y == list(y2)
          True

 -- Function: __import__ (name, globals=None, locals=None, fromlist=(),
          level=0)

          Note: This is an advanced function that is not needed in
          everyday Python programming, unlike *note
          importlib.import_module(): 52a.

     This function is invoked by the *note import: 674. statement.  It
     can be replaced (by importing the *note builtins: 13. module and
     assigning to ‘builtins.__import__’) in order to change semantics of
     the *note import: 674. statement, but doing so is `strongly'
     discouraged as it is usually simpler to use import hooks (see PEP
     302(5)) to attain the same goals and does not cause issues with
     code which assumes the default import implementation is in use.
     Direct use of *note __import__(): 383. is also discouraged in favor
     of *note importlib.import_module(): 52a.

     The function imports the module `name', potentially using the given
     `globals' and `locals' to determine how to interpret the name in a
     package context.  The `fromlist' gives the names of objects or
     submodules that should be imported from the module given by `name'.
     The standard implementation does not use its `locals' argument at
     all, and uses its `globals' only to determine the package context
     of the *note import: 674. statement.

     `level' specifies whether to use absolute or relative imports.  ‘0’
     (the default) means only perform absolute imports.  Positive values
     for `level' indicate the number of parent directories to search
     relative to the directory of the module calling *note __import__():
     383. (see PEP 328(6) for the details).

     When the `name' variable is of the form ‘package.module’, normally,
     the top-level package (the name up till the first dot) is returned,
     `not' the module named by `name'.  However, when a non-empty
     `fromlist' argument is given, the module named by `name' is
     returned.

     For example, the statement ‘import spam’ results in bytecode
     resembling the following code:

          spam = __import__('spam', globals(), locals(), [], 0)

     The statement ‘import spam.ham’ results in this call:

          spam = __import__('spam.ham', globals(), locals(), [], 0)

     Note how *note __import__(): 383. returns the toplevel module here
     because this is the object that is bound to a name by the *note
     import: 674. statement.

     On the other hand, the statement ‘from spam.ham import eggs,
     sausage as saus’ results in

          _temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)
          eggs = _temp.eggs
          saus = _temp.sausage

     Here, the ‘spam.ham’ module is returned from *note __import__():
     383.  From this object, the names to import are retrieved and
     assigned to their respective names.

     If you simply want to import a module (potentially within a
     package) by name, use *note importlib.import_module(): 52a.

     Changed in version 3.3: Negative values for `level' are no longer
     supported (which also changes the default value to 0).

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0236

   (2) Note that the parser only accepts the Unix-style end of line
convention.  If you are reading the code from a file, make sure to use
newline conversion mode to convert Windows or Mac-style newlines.

   (3) https://wiki.python.org/moin/HowTo/Sorting/

   (4) 
http://rhettinger.wordpress.com/2011/05/26/super-considered-super/

   (5) https://www.python.org/dev/peps/pep-0302

   (6) https://www.python.org/dev/peps/pep-0328


File: python.info,  Node: Built-in Constants,  Next: Built-in Types,  Prev: Built-in Functions,  Up: The Python Standard Library

5.3 Built-in Constants
======================

A small number of constants live in the built-in namespace.  They are:

 -- Data: False

     The false value of the *note bool: 87a. type.  Assignments to
     ‘False’ are illegal and raise a *note SyntaxError: 319.

 -- Data: True

     The true value of the *note bool: 87a. type.  Assignments to ‘True’
     are illegal and raise a *note SyntaxError: 319.

 -- Data: None

     The sole value of the type ‘NoneType’.  ‘None’ is frequently used
     to represent the absence of a value, as when default arguments are
     not passed to a function.  Assignments to ‘None’ are illegal and
     raise a *note SyntaxError: 319.

 -- Data: NotImplemented

     Special value which should be returned by the binary special
     methods (e.g.  *note __eq__(): 68d, *note __lt__(): 68c, *note
     __add__(): c2c, *note __rsub__(): c41, etc.)  to indicate that the
     operation is not implemented with respect to the other type; may be
     returned by the in-place binary special methods (e.g.  *note
     __imul__(): c30, *note __iand__(): c52, etc.)  for the same
     purpose.  Its truth value is true.

     Note: When ‘NotImplemented’ is returned, the interpreter will then
     try the reflected operation on the other type, or some other
     fallback, depending on the operator.  If all attempted operations
     return ‘NotImplemented’, the interpreter will raise an appropriate
     exception.

     See *note Implementing the arithmetic operations: bf5. for more
     details.

 -- Data: Ellipsis

     The same as ‘...’.  Special value used mostly in conjunction with
     extended slicing syntax for user-defined container data types.

 -- Data: __debug__

     This constant is true if Python was not started with an *note -O:
     891. option.  See also the *note assert: 890. statement.

     Note: The names *note None: 2c6, *note False: 3c8, *note True: 805.
     and *note __debug__: d26. cannot be reassigned (assignments to
     them, even as an attribute name, raise *note SyntaxError: 319.), so
     they can be considered "true" constants.

* Menu:

* Constants added by the site module:: 


File: python.info,  Node: Constants added by the site module,  Up: Built-in Constants

5.3.1 Constants added by the ‘site’ module
------------------------------------------

The *note site: e6. module (which is imported automatically during
startup, except if the *note -S: 53c. command-line option is given) adds
several constants to the built-in namespace.  They are useful for the
interactive interpreter shell and should not be used in programs.

 -- Data: quit (code=None)
 -- Data: exit (code=None)

     Objects that when printed, print a message like "Use quit() or
     Ctrl-D (i.e.  EOF) to exit", and when called, raise *note
     SystemExit: 6bf. with the specified exit code.

 -- Data: copyright
 -- Data: license
 -- Data: credits

     Objects that when printed, print a message like "Type license() to
     see the full license text", and when called, display the
     corresponding text in a pager-like fashion (one screen at a time).


File: python.info,  Node: Built-in Types,  Next: Built-in Exceptions,  Prev: Built-in Constants,  Up: The Python Standard Library

5.4 Built-in Types
==================

The following sections describe the standard types that are built into
the interpreter.

The principal built-in types are numerics, sequences, mappings, classes,
instances and exceptions.

Some collection classes are mutable.  The methods that add, subtract, or
rearrange their members in place, and don’t return a specific item,
never return the collection instance itself but ‘None’.

Some operations are supported by several object types; in particular,
practically all objects can be compared, tested for truth value, and
converted to a string (with the *note repr(): 3db. function or the
slightly different *note str(): 178. function).  The latter function is
implicitly used when an object is written by the *note print(): 21c.
function.

* Menu:

* Truth Value Testing:: 
* Boolean Operations: Boolean Operations --- and or not. and, or, not
* Comparisons: Comparisons<2>. 
* Numeric Types: Numeric Types --- int float complex. int, float, complex
* Iterator Types:: 
* Sequence Types: Sequence Types --- list tuple range. list, tuple, range
* Text Sequence Type: Text Sequence Type --- str. str
* Binary Sequence Types: Binary Sequence Types --- bytes bytearray memoryview. bytes, bytearray, memoryview
* Set Types: Set Types --- set frozenset. set, frozenset
* Mapping Types: Mapping Types --- dict. dict
* Context Manager Types:: 
* Other Built-in Types:: 
* Special Attributes:: 


File: python.info,  Node: Truth Value Testing,  Next: Boolean Operations --- and or not,  Up: Built-in Types

5.4.1 Truth Value Testing
-------------------------

Any object can be tested for truth value, for use in an *note if: 86d.
or *note while: a20. condition or as operand of the Boolean operations
below.  The following values are considered false:

   * ‘None’

   * ‘False’

   * zero of any numeric type, for example, ‘0’, ‘0.0’, ‘0j’.

   * any empty sequence, for example, ‘''’, ‘()’, ‘[]’.

   * any empty mapping, for example, ‘{}’.

   * instances of user-defined classes, if the class defines a *note
     __bool__(): 6cc. or *note __len__(): 84f. method, when that method
     returns the integer zero or *note bool: 87a. value ‘False’.  (1)

All other values are considered true — so objects of many types are
always true.

Operations and built-in functions that have a Boolean result always
return ‘0’ or ‘False’ for false and ‘1’ or ‘True’ for true, unless
otherwise stated.  (Important exception: the Boolean operations ‘or’ and
‘and’ always return one of their operands.)

   ---------- Footnotes ----------

   (1) Additional information on these special methods may be found in
the Python Reference Manual (*note Basic customization: c0c.).


File: python.info,  Node: Boolean Operations --- and or not,  Next: Comparisons<2>,  Prev: Truth Value Testing,  Up: Built-in Types

5.4.2 Boolean Operations — ‘and’, ‘or’, ‘not’
---------------------------------------------

These are the Boolean operations, ordered by ascending priority:

Operation         Result                                Notes
                                                        
--------------------------------------------------------------------
                                                        
‘x or y’          if `x' is false, then `y', else `x'   (1)
                                                        
                                                        
‘x and y’         if `x' is false, then `x', else `y'   (2)
                                                        
                                                        
‘not x’           if `x' is false, then ‘True’, else    (3)
                  ‘False’                               
                  

Notes:

  1. This is a short-circuit operator, so it only evaluates the second
     argument if the first one is *note False: 3c8.

  2. This is a short-circuit operator, so it only evaluates the second
     argument if the first one is *note True: 805.

  3. ‘not’ has a lower priority than non-Boolean operators, so ‘not a ==
     b’ is interpreted as ‘not (a == b)’, and ‘a == not b’ is a syntax
     error.


File: python.info,  Node: Comparisons<2>,  Next: Numeric Types --- int float complex,  Prev: Boolean Operations --- and or not,  Up: Built-in Types

5.4.3 Comparisons
-----------------

There are eight comparison operations in Python.  They all have the same
priority (which is higher than that of the Boolean operations).
Comparisons can be chained arbitrarily; for example, ‘x < y <= z’ is
equivalent to ‘x < y and y <= z’, except that `y' is evaluated only once
(but in both cases `z' is not evaluated at all when ‘x < y’ is found to
be false).

This table summarizes the comparison operations:

Operation        Meaning
                 
-----------------------------------------------
                 
‘<’              strictly less than
                 
                 
‘<=’             less than or equal
                 
                 
‘>’              strictly greater than
                 
                 
‘>=’             greater than or equal
                 
                 
‘==’             equal
                 
                 
‘!=’             not equal
                 
                 
‘is’             object identity
                 
                 
‘is not’         negated object identity
                 

Objects of different types, except different numeric types, never
compare equal.  Furthermore, some types (for example, function objects)
support only a degenerate notion of comparison where any two objects of
that type are unequal.  The ‘<’, ‘<=’, ‘>’ and ‘>=’ operators will raise
a *note TypeError: 309. exception when comparing a complex number with
another built-in numeric type, when the objects are of different types
that cannot be compared, or in other cases where there is no defined
ordering.

Non-identical instances of a class normally compare as non-equal unless
the class defines the *note __eq__(): 68d. method.

Instances of a class cannot be ordered with respect to other instances
of the same class, or other types of object, unless the class defines
enough of the methods *note __lt__(): 68c, *note __le__(): 70f, *note
__gt__(): 710, and *note __ge__(): 711. (in general, *note __lt__():
68c. and *note __eq__(): 68d. are sufficient, if you want the
conventional meanings of the comparison operators).

The behavior of the *note is: bf2. and *note is not: cf7. operators
cannot be customized; also they can be applied to any two objects and
never raise an exception.

Two more operations with the same syntactic priority, *note in: 6d5. and
*note not in: c33, are supported only by sequence types (below).


File: python.info,  Node: Numeric Types --- int float complex,  Next: Iterator Types,  Prev: Comparisons<2>,  Up: Built-in Types

5.4.4 Numeric Types — ‘int’, ‘float’, ‘complex’
-----------------------------------------------

There are three distinct numeric types: `integers', `floating point
numbers', and `complex numbers'.  In addition, Booleans are a subtype of
integers.  Integers have unlimited precision.  Floating point numbers
are usually implemented using ‘double’ in C; information about the
precision and internal representation of floating point numbers for the
machine on which your program is running is available in *note
sys.float_info: dc0.  Complex numbers have a real and imaginary part,
which are each a floating point number.  To extract these parts from a
complex number `z', use ‘z.real’ and ‘z.imag’.  (The standard library
includes additional numeric types, *note fractions: 82. that hold
rationals, and *note decimal: 34. that hold floating-point numbers with
user-definable precision.)

Numbers are created by numeric literals or as the result of built-in
functions and operators.  Unadorned integer literals (including hex,
octal and binary numbers) yield integers.  Numeric literals containing a
decimal point or an exponent sign yield floating point numbers.
Appending ‘'j'’ or ‘'J'’ to a numeric literal yields an imaginary number
(a complex number with a zero real part) which you can add to an integer
or float to get a complex number with real and imaginary parts.

Python fully supports mixed arithmetic: when a binary arithmetic
operator has operands of different numeric types, the operand with the
"narrower" type is widened to that of the other, where integer is
narrower than floating point, which is narrower than complex.
Comparisons between numbers of mixed type use the same rule.  (1) The
constructors *note int(): 185, *note float(): 327, and *note complex():
326. can be used to produce numbers of a specific type.

All numeric types (except complex) support the following operations,
sorted by ascending priority (all numeric operations have a higher
priority than comparison operations):

Operation                 Result                                Notes         Full documentation
                                                                              
-------------------------------------------------------------------------------------------------------
                                                                              
‘x + y’                   sum of `x' and `y'
                          
                                                                              
‘x - y’                   difference of `x' and `y'
                          
                                                                              
‘x * y’                   product of `x' and `y'
                          
                                                                              
‘x / y’                   quotient of `x' and `y'
                          
                                                                              
‘x // y’                  floored quotient of `x' and `y'       (1)
                                                                
                                                                              
‘x % y’                   remainder of ‘x / y’                  (2)
                                                                
                                                                              
‘-x’                      `x' negated
                          
                                                                              
‘+x’                      `x' unchanged
                          
                                                                              
‘abs(x)’                  absolute value or magnitude of `x'                  *note abs(): aaa.
                                                                              
                                                                              
‘int(x)’                  `x' converted to integer              (3)(6)        *note int(): 185.
                                                                              
                                                                              
‘float(x)’                `x' converted to floating point       (4)(6)        *note float(): 327.
                                                                              
                                                                              
‘complex(re, im)’         a complex number with real part       (6)           *note complex(): 326.
                          `re', imaginary part `im'.  `im'                    
                          defaults to zero.
                          
                                                                              
‘c.conjugate()’           conjugate of the complex number `c'
                          
                                                                              
‘divmod(x, y)’            the pair ‘(x // y, x % y)’            (2)           *note divmod(): c40.
                                                                              
                                                                              
‘pow(x, y)’               `x' to the power `y'                  (5)           *note pow(): 8e0.
                                                                              
                                                                              
‘x ** y’                  `x' to the power `y'                  (5)
                                                                

Notes:

  1. Also referred to as integer division.  The resultant value is a
     whole integer, though the result’s type is not necessarily int.
     The result is always rounded towards minus infinity: ‘1//2’ is ‘0’,
     ‘(-1)//2’ is ‘-1’, ‘1//(-2)’ is ‘-1’, and ‘(-1)//(-2)’ is ‘0’.

  2. Not for complex numbers.  Instead convert to floats using *note
     abs(): aaa. if appropriate.

  3. 
     Conversion from floating point to integer may round or truncate as
     in C; see functions *note math.floor(): 7a0. and *note math.ceil():
     7a1. for well-defined conversions.

  4. float also accepts the strings "nan" and "inf" with an optional
     prefix "+" or "-" for Not a Number (NaN) and positive or negative
     infinity.

  5. Python defines ‘pow(0, 0)’ and ‘0 ** 0’ to be ‘1’, as is common for
     programming languages.

  6. The numeric literals accepted include the digits ‘0’ to ‘9’ or any
     Unicode equivalent (code points with the ‘Nd’ property).

     See
     ‘http://www.unicode.org/Public/6.3.0/ucd/extracted/DerivedNumericType.txt’
     for a complete list of code points with the ‘Nd’ property.

All *note numbers.Real: bf8. types (*note int: 185. and *note float:
327.) also include the following operations:

Operation                Result                                   Notes
                                                                  
-------------------------------------------------------------------------------
                                                                  
‘math.trunc(x)’          `x' truncated to Integral
                         
                                                                  
‘round(x[, n])’          `x' rounded to n digits, rounding half
                         to even.  If n is omitted, it defaults
                         to 0.
                         
                                                                  
‘math.floor(x)’          the greatest integral float <= `x'
                         
                                                                  
‘math.ceil(x)’           the least integral float >= `x'
                         

For additional numeric operations see the *note math: ae. and *note
cmath: 19. modules.

* Menu:

* Bitwise Operations on Integer Types:: 
* Additional Methods on Integer Types:: 
* Additional Methods on Float:: 
* Hashing of numeric types:: 

   ---------- Footnotes ----------

   (1) As a consequence, the list ‘[1, 2]’ is considered equal to ‘[1.0,
2.0]’, and similarly for tuples.


File: python.info,  Node: Bitwise Operations on Integer Types,  Next: Additional Methods on Integer Types,  Up: Numeric Types --- int float complex

5.4.4.1 Bitwise Operations on Integer Types
...........................................

Bitwise operations only make sense for integers.  Negative numbers are
treated as their 2’s complement value (this assumes a sufficiently large
number of bits that no overflow occurs during the operation).

The priorities of the binary bitwise operations are all lower than the
numeric operations and higher than the comparisons; the unary operation
‘~’ has the same priority as the other unary numeric operations (‘+’ and
‘-’).

This table lists the bitwise operations sorted in ascending priority:

Operation        Result                               Notes
                                                      
---------------------------------------------------------------------
                                                      
‘x | y’          bitwise `or' of `x' and `y'
                 
                                                      
‘x ^ y’          bitwise `exclusive or' of `x' and
                 `y'
                 
                                                      
‘x & y’          bitwise `and' of `x' and `y'
                 
                                                      
‘x << n’         `x' shifted left by `n' bits         (1)(2)
                                                      
                                                      
‘x >> n’         `x' shifted right by `n' bits        (1)(3)
                                                      
                                                      
‘~x’             the bits of `x' inverted
                 

Notes:

  1. Negative shift counts are illegal and cause a *note ValueError:
     321. to be raised.

  2. A left shift by `n' bits is equivalent to multiplication by ‘pow(2,
     n)’ without overflow check.

  3. A right shift by `n' bits is equivalent to division by ‘pow(2, n)’
     without overflow check.


File: python.info,  Node: Additional Methods on Integer Types,  Next: Additional Methods on Float,  Prev: Bitwise Operations on Integer Types,  Up: Numeric Types --- int float complex

5.4.4.2 Additional Methods on Integer Types
...........................................

The int type implements the *note numbers.Integral: bf7. *note abstract
base class: 550.  In addition, it provides a few more methods:

 -- Method: int.bit_length ()

     Return the number of bits necessary to represent an integer in
     binary, excluding the sign and leading zeros:

          >>> n = -37
          >>> bin(n)
          '-0b100101'
          >>> n.bit_length()
          6

     More precisely, if ‘x’ is nonzero, then ‘x.bit_length()’ is the
     unique positive integer ‘k’ such that ‘2**(k-1) <= abs(x) < 2**k’.
     Equivalently, when ‘abs(x)’ is small enough to have a correctly
     rounded logarithm, then ‘k = 1 + int(log(abs(x), 2))’.  If ‘x’ is
     zero, then ‘x.bit_length()’ returns ‘0’.

     Equivalent to:

          def bit_length(self):
              s = bin(self)       # binary representation:  bin(-37) --> '-0b100101'
              s = s.lstrip('-0b') # remove leading zeros and minus sign
              return len(s)       # len('100101') --> 6

     New in version 3.1.

 -- Method: int.to_bytes (length, byteorder, *, signed=False)

     Return an array of bytes representing an integer.

          >>> (1024).to_bytes(2, byteorder='big')
          b'\x04\x00'
          >>> (1024).to_bytes(10, byteorder='big')
          b'\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00'
          >>> (-1024).to_bytes(10, byteorder='big', signed=True)
          b'\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00'
          >>> x = 1000
          >>> x.to_bytes((x.bit_length() // 8) + 1, byteorder='little')
          b'\xe8\x03'

     The integer is represented using `length' bytes.  An *note
     OverflowError: 325. is raised if the integer is not representable
     with the given number of bytes.

     The `byteorder' argument determines the byte order used to
     represent the integer.  If `byteorder' is ‘"big"’, the most
     significant byte is at the beginning of the byte array.  If
     `byteorder' is ‘"little"’, the most significant byte is at the end
     of the byte array.  To request the native byte order of the host
     system, use *note sys.byteorder: dc6. as the byte order value.

     The `signed' argument determines whether two’s complement is used
     to represent the integer.  If `signed' is ‘False’ and a negative
     integer is given, an *note OverflowError: 325. is raised.  The
     default value for `signed' is ‘False’.

     New in version 3.2.

 -- Class Method: int.from_bytes (bytes, byteorder, *, signed=False)

     Return the integer represented by the given array of bytes.

          >>> int.from_bytes(b'\x00\x10', byteorder='big')
          16
          >>> int.from_bytes(b'\x00\x10', byteorder='little')
          4096
          >>> int.from_bytes(b'\xfc\x00', byteorder='big', signed=True)
          -1024
          >>> int.from_bytes(b'\xfc\x00', byteorder='big', signed=False)
          64512
          >>> int.from_bytes([255, 0, 0], byteorder='big')
          16711680

     The argument `bytes' must either be a *note bytes-like object: 19f.
     or an iterable producing bytes.

     The `byteorder' argument determines the byte order used to
     represent the integer.  If `byteorder' is ‘"big"’, the most
     significant byte is at the beginning of the byte array.  If
     `byteorder' is ‘"little"’, the most significant byte is at the end
     of the byte array.  To request the native byte order of the host
     system, use *note sys.byteorder: dc6. as the byte order value.

     The `signed' argument indicates whether two’s complement is used to
     represent the integer.

     New in version 3.2.


File: python.info,  Node: Additional Methods on Float,  Next: Hashing of numeric types,  Prev: Additional Methods on Integer Types,  Up: Numeric Types --- int float complex

5.4.4.3 Additional Methods on Float
...................................

The float type implements the *note numbers.Real: bf8. *note abstract
base class: 550.  float also has the following additional methods.

 -- Method: float.as_integer_ratio ()

     Return a pair of integers whose ratio is exactly equal to the
     original float and with a positive denominator.  Raises *note
     OverflowError: 325. on infinities and a *note ValueError: 321. on
     NaNs.

 -- Method: float.is_integer ()

     Return ‘True’ if the float instance is finite with integral value,
     and ‘False’ otherwise:

          >>> (-2.0).is_integer()
          True
          >>> (3.2).is_integer()
          False

Two methods support conversion to and from hexadecimal strings.  Since
Python’s floats are stored internally as binary numbers, converting a
float to or from a `decimal' string usually involves a small rounding
error.  In contrast, hexadecimal strings allow exact representation and
specification of floating-point numbers.  This can be useful when
debugging, and in numerical work.

 -- Method: float.hex ()

     Return a representation of a floating-point number as a hexadecimal
     string.  For finite floating-point numbers, this representation
     will always include a leading ‘0x’ and a trailing ‘p’ and exponent.

 -- Class Method: float.fromhex (s)

     Class method to return the float represented by a hexadecimal
     string `s'.  The string `s' may have leading and trailing
     whitespace.

Note that *note float.hex(): b0c. is an instance method, while *note
float.fromhex(): dca. is a class method.

A hexadecimal string takes the form:

     [sign] ['0x'] integer ['.' fraction] ['p' exponent]

where the optional ‘sign’ may by either ‘+’ or ‘-’, ‘integer’ and
‘fraction’ are strings of hexadecimal digits, and ‘exponent’ is a
decimal integer with an optional leading sign.  Case is not significant,
and there must be at least one hexadecimal digit in either the integer
or the fraction.  This syntax is similar to the syntax specified in
section 6.4.4.2 of the C99 standard, and also to the syntax used in Java
1.5 onwards.  In particular, the output of *note float.hex(): b0c. is
usable as a hexadecimal floating-point literal in C or Java code, and
hexadecimal strings produced by C’s ‘%a’ format character or Java’s
‘Double.toHexString’ are accepted by *note float.fromhex(): dca.

Note that the exponent is written in decimal rather than hexadecimal,
and that it gives the power of 2 by which to multiply the coefficient.
For example, the hexadecimal string ‘0x3.a7p10’ represents the
floating-point number ‘(3 + 10./16 + 7./16**2) * 2.0**10’, or ‘3740.0’:

     >>> float.fromhex('0x3.a7p10')
     3740.0

Applying the reverse conversion to ‘3740.0’ gives a different
hexadecimal string representing the same number:

     >>> float.hex(3740.0)
     '0x1.d380000000000p+11'


File: python.info,  Node: Hashing of numeric types,  Prev: Additional Methods on Float,  Up: Numeric Types --- int float complex

5.4.4.4 Hashing of numeric types
................................

For numbers ‘x’ and ‘y’, possibly of different types, it’s a requirement
that ‘hash(x) == hash(y)’ whenever ‘x == y’ (see the *note __hash__():
39f. method documentation for more details).  For ease of implementation
and efficiency across a variety of numeric types (including *note int:
185, *note float: 327, *note decimal.Decimal: 3d4. and *note
fractions.Fraction: 5b8.) Python’s hash for numeric types is based on a
single mathematical function that’s defined for any rational number, and
hence applies to all instances of *note int: 185. and *note
fractions.Fraction: 5b8, and all finite instances of *note float: 327.
and *note decimal.Decimal: 3d4.  Essentially, this function is given by
reduction modulo ‘P’ for a fixed prime ‘P’.  The value of ‘P’ is made
available to Python as the ‘modulus’ attribute of *note sys.hash_info:
2c8.

`CPython implementation detail:' Currently, the prime used is ‘P = 2**31
- 1’ on machines with 32-bit C longs and ‘P = 2**61 - 1’ on machines
with 64-bit C longs.

Here are the rules in detail:

   - If ‘x = m / n’ is a nonnegative rational number and ‘n’ is not
     divisible by ‘P’, define ‘hash(x)’ as ‘m * invmod(n, P) % P’, where
     ‘invmod(n, P)’ gives the inverse of ‘n’ modulo ‘P’.

   - If ‘x = m / n’ is a nonnegative rational number and ‘n’ is
     divisible by ‘P’ (but ‘m’ is not) then ‘n’ has no inverse modulo
     ‘P’ and the rule above doesn’t apply; in this case define ‘hash(x)’
     to be the constant value ‘sys.hash_info.inf’.

   - If ‘x = m / n’ is a negative rational number define ‘hash(x)’ as
     ‘-hash(-x)’.  If the resulting hash is ‘-1’, replace it with ‘-2’.

   - The particular values ‘sys.hash_info.inf’, ‘-sys.hash_info.inf’ and
     ‘sys.hash_info.nan’ are used as hash values for positive infinity,
     negative infinity, or nans (respectively).  (All hashable nans have
     the same hash value.)

   - For a *note complex: 326. number ‘z’, the hash values of the real
     and imaginary parts are combined by computing ‘hash(z.real) +
     sys.hash_info.imag * hash(z.imag)’, reduced modulo
     ‘2**sys.hash_info.width’ so that it lies in
     ‘range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width -
     1))’.  Again, if the result is ‘-1’, it’s replaced with ‘-2’.

To clarify the above rules, here’s some example Python code, equivalent
to the built-in hash, for computing the hash of a rational number, *note
float: 327, or *note complex: 326.:

     import sys, math

     def hash_fraction(m, n):
         """Compute the hash of a rational number m / n.

         Assumes m and n are integers, with n positive.
         Equivalent to hash(fractions.Fraction(m, n)).

         """
         P = sys.hash_info.modulus
         # Remove common factors of P.  (Unnecessary if m and n already coprime.)
         while m % P == n % P == 0:
             m, n = m // P, n // P

         if n % P == 0:
             hash_ = sys.hash_info.inf
         else:
             # Fermat's Little Theorem: pow(n, P-1, P) is 1, so
             # pow(n, P-2, P) gives the inverse of n modulo P.
             hash_ = (abs(m) % P) * pow(n, P - 2, P) % P
         if m < 0:
             hash_ = -hash_
         if hash_ == -1:
             hash_ = -2
         return hash_

     def hash_float(x):
         """Compute the hash of a float x."""

         if math.isnan(x):
             return sys.hash_info.nan
         elif math.isinf(x):
             return sys.hash_info.inf if x > 0 else -sys.hash_info.inf
         else:
             return hash_fraction(*x.as_integer_ratio())

     def hash_complex(z):
         """Compute the hash of a complex number z."""

         hash_ = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)
         # do a signed reduction modulo 2**sys.hash_info.width
         M = 2**(sys.hash_info.width - 1)
         hash_ = (hash_ & (M - 1)) - (hash & M)
         if hash_ == -1:
             hash_ == -2
         return hash_


File: python.info,  Node: Iterator Types,  Next: Sequence Types --- list tuple range,  Prev: Numeric Types --- int float complex,  Up: Built-in Types

5.4.5 Iterator Types
--------------------

Python supports a concept of iteration over containers.  This is
implemented using two distinct methods; these are used to allow
user-defined classes to support iteration.  Sequences, described below
in more detail, always support the iteration methods.

One method needs to be defined for container objects to provide
iteration support:

 -- Method: container.__iter__ ()

     Return an iterator object.  The object is required to support the
     iterator protocol described below.  If a container supports
     different types of iteration, additional methods can be provided to
     specifically request iterators for those iteration types.  (An
     example of an object supporting multiple forms of iteration would
     be a tree structure which supports both breadth-first and
     depth-first traversal.)  This method corresponds to the *note
     tp_iter: 8bd. slot of the type structure for Python objects in the
     Python/C API.

The iterator objects themselves are required to support the following
two methods, which together form the `iterator protocol':

 -- Method: iterator.__iter__ ()

     Return the iterator object itself.  This is required to allow both
     containers and iterators to be used with the *note for: 688. and
     *note in: 6d5. statements.  This method corresponds to the *note
     tp_iter: 8bd. slot of the type structure for Python objects in the
     Python/C API.

 -- Method: iterator.__next__ ()

     Return the next item from the container.  If there are no further
     items, raise the *note StopIteration: 7a5. exception.  This method
     corresponds to the *note tp_iternext: 8be. slot of the type
     structure for Python objects in the Python/C API.

Python defines several iterator objects to support iteration over
general and specific sequence types, dictionaries, and other more
specialized forms.  The specific types are not important beyond their
implementation of the iterator protocol.

Once an iterator’s *note __next__(): 6c7. method raises *note
StopIteration: 7a5, it must continue to do so on subsequent calls.
Implementations that do not obey this property are deemed broken.

* Menu:

* Generator Types:: 


File: python.info,  Node: Generator Types,  Up: Iterator Types

5.4.5.1 Generator Types
.......................

Python’s *note generator: 374.s provide a convenient way to implement
the iterator protocol.  If a container object’s *note __iter__(): 79b.
method is implemented as a generator, it will automatically return an
iterator object (technically, a generator object) supplying the *note
__iter__(): 79b. and *note __next__(): ac7. methods.  More information
about generators can be found in *note the documentation for the yield
expression: cbf.


File: python.info,  Node: Sequence Types --- list tuple range,  Next: Text Sequence Type --- str,  Prev: Iterator Types,  Up: Built-in Types

5.4.6 Sequence Types — ‘list’, ‘tuple’, ‘range’
-----------------------------------------------

There are three basic sequence types: lists, tuples, and range objects.
Additional sequence types tailored for processing of *note binary data:
d8d. and *note text strings: a16. are described in dedicated sections.

* Menu:

* Common Sequence Operations:: 
* Immutable Sequence Types:: 
* Mutable Sequence Types:: 
* Lists: Lists<2>. 
* Tuples:: 
* Ranges:: 


File: python.info,  Node: Common Sequence Operations,  Next: Immutable Sequence Types,  Up: Sequence Types --- list tuple range

5.4.6.1 Common Sequence Operations
..................................

The operations in the following table are supported by most sequence
types, both mutable and immutable.  The *note collections.abc.Sequence:
dd5. ABC is provided to make it easier to correctly implement these
operations on custom sequence types.

This table lists the sequence operations sorted in ascending priority.
In the table, `s' and `t' are sequences of the same type, `n', `i', `j'
and `k' are integers and `x' is an arbitrary object that meets any type
and value restrictions imposed by `s'.

The ‘in’ and ‘not in’ operations have the same priorities as the
comparison operations.  The ‘+’ (concatenation) and ‘*’ (repetition)
operations have the same priority as the corresponding numeric
operations.

Operation                      Result                               Notes
                                                                    
-----------------------------------------------------------------------------------
                                                                    
‘x in s’                       ‘True’ if an item of `s' is equal    (1)
                               to `x', else ‘False’                 
                               
                                                                    
‘x not in s’                   ‘False’ if an item of `s' is equal   (1)
                               to `x', else ‘True’                  
                               
                                                                    
‘s + t’                        the concatenation of `s' and `t'     (6)(7)
                                                                    
                                                                    
‘s * n’ or ‘n * s’             `n' shallow copies of `s'            (2)(7)
                               concatenated                         
                               
                                                                    
‘s[i]’                         `i'th item of `s', origin 0          (3)
                                                                    
                                                                    
‘s[i:j]’                       slice of `s' from `i' to `j'         (3)(4)
                                                                    
                                                                    
‘s[i:j:k]’                     slice of `s' from `i' to `j' with    (3)(5)
                               step `k'                             
                               
                                                                    
‘len(s)’                       length of `s'
                               
                                                                    
‘min(s)’                       smallest item of `s'
                               
                                                                    
‘max(s)’                       largest item of `s'
                               
                                                                    
‘s.index(x[, i[, j]])’         index of the first occurrence of     (8)
                               `x' in `s' (at or after index `i'    
                               and before index `j')
                               
                                                                    
‘s.count(x)’                   total number of occurrences of `x'
                               in `s'
                               

Sequences of the same type also support comparisons.  In particular,
tuples and lists are compared lexicographically by comparing
corresponding elements.  This means that to compare equal, every element
must compare equal and the two sequences must be of the same type and
have the same length.  (For full details see *note Comparisons: cf6. in
the language reference.)

Notes:

  1. While the ‘in’ and ‘not in’ operations are used only for simple
     containment testing in the general case, some specialised sequences
     (such as *note str: 178, *note bytes: 179. and *note bytearray:
     17a.) also use them for subsequence testing:

          >>> "gg" in "eggs"
          True

  2. Values of `n' less than ‘0’ are treated as ‘0’ (which yields an
     empty sequence of the same type as `s').  Note also that the copies
     are shallow; nested structures are not copied.  This often haunts
     new Python programmers; consider:

          >>> lists = [[]] * 3
          >>> lists
          [[], [], []]
          >>> lists[0].append(3)
          >>> lists
          [[3], [3], [3]]

     What has happened is that ‘[[]]’ is a one-element list containing
     an empty list, so all three elements of ‘[[]] * 3’ are (pointers
     to) this single empty list.  Modifying any of the elements of
     ‘lists’ modifies this single list.  You can create a list of
     different lists this way:

          >>> lists = [[] for i in range(3)]
          >>> lists[0].append(3)
          >>> lists[1].append(5)
          >>> lists[2].append(7)
          >>> lists
          [[3], [5], [7]]

  3. If `i' or `j' is negative, the index is relative to the end of the
     string: ‘len(s) + i’ or ‘len(s) + j’ is substituted.  But note that
     ‘-0’ is still ‘0’.

  4. The slice of `s' from `i' to `j' is defined as the sequence of
     items with index `k' such that ‘i <= k < j’.  If `i' or `j' is
     greater than ‘len(s)’, use ‘len(s)’.  If `i' is omitted or ‘None’,
     use ‘0’.  If `j' is omitted or ‘None’, use ‘len(s)’.  If `i' is
     greater than or equal to `j', the slice is empty.

  5. The slice of `s' from `i' to `j' with step `k' is defined as the
     sequence of items with index ‘x = i + n*k’ such that ‘0 <= n <
     (j-i)/k’.  In other words, the indices are ‘i’, ‘i+k’, ‘i+2*k’,
     ‘i+3*k’ and so on, stopping when `j' is reached (but never
     including `j').  If `i' or `j' is greater than ‘len(s)’, use
     ‘len(s)’.  If `i' or `j' are omitted or ‘None’, they become "end"
     values (which end depends on the sign of `k').  Note, `k' cannot be
     zero.  If `k' is ‘None’, it is treated like ‘1’.

  6. Concatenating immutable sequences always results in a new object.
     This means that building up a sequence by repeated concatenation
     will have a quadratic runtime cost in the total sequence length.
     To get a linear runtime cost, you must switch to one of the
     alternatives below:

        * if concatenating *note str: 178. objects, you can build a list
          and use *note str.join(): dd6. at the end or else write to a
          *note io.StringIO: 1b1. instance and retrieve its value when
          complete

        * if concatenating *note bytes: 179. objects, you can similarly
          use *note bytes.join(): dd7. or *note io.BytesIO: 5a0, or you
          can do in-place concatenation with a *note bytearray: 17a.
          object.  *note bytearray: 17a. objects are mutable and have an
          efficient overallocation mechanism

        * if concatenating *note tuple: 84e. objects, extend a *note
          list: 397. instead

        * for other types, investigate the relevant class documentation

  7. Some sequence types (such as *note range: 396.) only support item
     sequences that follow specific patterns, and hence don’t support
     sequence concatenation or repetition.

  8. ‘index’ raises *note ValueError: 321. when `x' is not found in `s'.
     When supported, the additional arguments to the index method allow
     efficient searching of subsections of the sequence.  Passing the
     extra arguments is roughly equivalent to using ‘s[i:j].index(x)’,
     only without copying any data and with the returned index being
     relative to the start of the sequence rather than the start of the
     slice.


File: python.info,  Node: Immutable Sequence Types,  Next: Mutable Sequence Types,  Prev: Common Sequence Operations,  Up: Sequence Types --- list tuple range

5.4.6.2 Immutable Sequence Types
................................

The only operation that immutable sequence types generally implement
that is not also implemented by mutable sequence types is support for
the *note hash(): 39e. built-in.

This support allows immutable sequences, such as *note tuple: 84e.
instances, to be used as *note dict: 380. keys and stored in *note set:
5a4. and *note frozenset: 63c. instances.

Attempting to hash an immutable sequence that contains unhashable values
will result in *note TypeError: 309.


File: python.info,  Node: Mutable Sequence Types,  Next: Lists<2>,  Prev: Immutable Sequence Types,  Up: Sequence Types --- list tuple range

5.4.6.3 Mutable Sequence Types
..............................

The operations in the following table are defined on mutable sequence
types.  The *note collections.abc.MutableSequence: 398. ABC is provided
to make it easier to correctly implement these operations on custom
sequence types.

In the table `s' is an instance of a mutable sequence type, `t' is any
iterable object and `x' is an arbitrary object that meets any type and
value restrictions imposed by `s' (for example, *note bytearray: 17a.
only accepts integers that meet the value restriction ‘0 <= x <= 255’).

Operation                          Result                               Notes
                                                                        
--------------------------------------------------------------------------------------------------
                                                                        
‘s[i] = x’                         item `i' of `s' is replaced by `x'
                                   
                                                                        
‘s[i:j] = t’                       slice of `s' from `i' to `j' is
                                   replaced by the contents of the
                                   iterable `t'
                                   
                                                                        
‘del s[i:j]’                       same as ‘s[i:j] = []’
                                   
                                                                        
‘s[i:j:k] = t’                     the elements of ‘s[i:j:k]’ are       (1)
                                   replaced by those of `t'             
                                   
                                                                        
‘del s[i:j:k]’                     removes the elements of ‘s[i:j:k]’
                                   from the list
                                   
                                                                        
‘s.append(x)’                      appends `x' to the end of the
                                   sequence (same as
                                   ‘s[len(s):len(s)] = [x]’)
                                   
                                                                        
‘s.clear()’                        removes all items from ‘s’ (same     (5)
                                   as ‘del s[:]’)                       
                                   
                                                                        
‘s.copy()’                         creates a shallow copy of ‘s’        (5)
                                   (same as ‘s[:]’)                     
                                   
                                                                        
‘s.extend(t)’                      extends `s' with the contents of
                                   `t' (same as ‘s[len(s):len(s)] =
                                   t’)
                                   
                                                                        
‘s.insert(i, x)’                   inserts `x' into `s' at the index
                                   given by `i' (same as ‘s[i:i] =
                                   [x]’)
                                   
                                                                        
‘s.pop([i])’                       retrieves the item at `i' and also   (2)
                                   removes it from `s'                  
                                   
                                                                        
‘s.remove(x)’                      remove the first item from `s'       (3)
                                   where ‘s[i] == x’                    
                                   
                                                                        
‘s.reverse()’                      reverses the items of `s' in place   (4)
                                                                        

Notes:

  1. `t' must have the same length as the slice it is replacing.

  2. The optional argument `i' defaults to ‘-1’, so that by default the
     last item is removed and returned.

  3. ‘remove’ raises *note ValueError: 321. when `x' is not found in
     `s'.

  4. The ‘reverse()’ method modifies the sequence in place for economy
     of space when reversing a large sequence.  To remind users that it
     operates by side effect, it does not return the reversed sequence.

  5. ‘clear()’ and ‘copy()’ are included for consistency with the
     interfaces of mutable containers that don’t support slicing
     operations (such as *note dict: 380. and *note set: 5a4.)

     New in version 3.3: ‘clear()’ and ‘copy()’ methods.


File: python.info,  Node: Lists<2>,  Next: Tuples,  Prev: Mutable Sequence Types,  Up: Sequence Types --- list tuple range

5.4.6.4 Lists
.............

Lists are mutable sequences, typically used to store collections of
homogeneous items (where the precise degree of similarity will vary by
application).

 -- Class: list ([iterable])

     Lists may be constructed in several ways:

        * Using a pair of square brackets to denote the empty list: ‘[]’

        * Using square brackets, separating items with commas: ‘[a]’,
          ‘[a, b, c]’

        * Using a list comprehension: ‘[x for x in iterable]’

        * Using the type constructor: ‘list()’ or ‘list(iterable)’

     The constructor builds a list whose items are the same and in the
     same order as `iterable'’s items.  `iterable' may be either a
     sequence, a container that supports iteration, or an iterator
     object.  If `iterable' is already a list, a copy is made and
     returned, similar to ‘iterable[:]’.  For example, ‘list('abc')’
     returns ‘['a', 'b', 'c']’ and ‘list( (1, 2, 3) )’ returns ‘[1, 2,
     3]’.  If no argument is given, the constructor creates a new empty
     list, ‘[]’.

     Many other operations also produce lists, including the *note
     sorted(): 63e. built-in.

     Lists implement all of the *note common: dd3. and *note mutable:
     d8b. sequence operations.  Lists also provide the following
     additional method:

      -- Method: sort (*, key=None, reverse=None)

          This method sorts the list in place, using only ‘<’
          comparisons between items.  Exceptions are not suppressed - if
          any comparison operations fail, the entire sort operation will
          fail (and the list will likely be left in a partially modified
          state).

          *note sort(): 63d. accepts two arguments that can only be
          passed by keyword (*note keyword-only arguments: 2bc.):

          `key' specifies a function of one argument that is used to
          extract a comparison key from each list element (for example,
          ‘key=str.lower’).  The key corresponding to each item in the
          list is calculated once and then used for the entire sorting
          process.  The default value of ‘None’ means that list items
          are sorted directly without calculating a separate key value.

          The *note functools.cmp_to_key(): 581. utility is available to
          convert a 2.x style `cmp' function to a `key' function.

          `reverse' is a boolean value.  If set to ‘True’, then the list
          elements are sorted as if each comparison were reversed.

          This method modifies the sequence in place for economy of
          space when sorting a large sequence.  To remind users that it
          operates by side effect, it does not return the sorted
          sequence (use *note sorted(): 63e. to explicitly request a new
          sorted list instance).

          The *note sort(): 63d. method is guaranteed to be stable.  A
          sort is stable if it guarantees not to change the relative
          order of elements that compare equal — this is helpful for
          sorting in multiple passes (for example, sort by department,
          then by salary grade).

          `CPython implementation detail:' While a list is being sorted,
          the effect of attempting to mutate, or even inspect, the list
          is undefined.  The C implementation of Python makes the list
          appear empty for the duration, and raises *note ValueError:
          321. if it can detect that the list has been mutated during a
          sort.


File: python.info,  Node: Tuples,  Next: Ranges,  Prev: Lists<2>,  Up: Sequence Types --- list tuple range

5.4.6.5 Tuples
..............

Tuples are immutable sequences, typically used to store collections of
heterogeneous data (such as the 2-tuples produced by the *note
enumerate(): 869. built-in).  Tuples are also used for cases where an
immutable sequence of homogeneous data is needed (such as allowing
storage in a *note set: 5a4. or *note dict: 380. instance).

 -- Class: tuple ([iterable])

     Tuples may be constructed in a number of ways:

        * Using a pair of parentheses to denote the empty tuple: ‘()’

        * Using a trailing comma for a singleton tuple: ‘a,’ or ‘(a,)’

        * Separating items with commas: ‘a, b, c’ or ‘(a, b, c)’

        * Using the *note tuple(): 84e. built-in: ‘tuple()’ or
          ‘tuple(iterable)’

     The constructor builds a tuple whose items are the same and in the
     same order as `iterable'’s items.  `iterable' may be either a
     sequence, a container that supports iteration, or an iterator
     object.  If `iterable' is already a tuple, it is returned
     unchanged.  For example, ‘tuple('abc')’ returns ‘('a', 'b', 'c')’
     and ‘tuple( [1, 2, 3] )’ returns ‘(1, 2, 3)’.  If no argument is
     given, the constructor creates a new empty tuple, ‘()’.

     Note that it is actually the comma which makes a tuple, not the
     parentheses.  The parentheses are optional, except in the empty
     tuple case, or when they are needed to avoid syntactic ambiguity.
     For example, ‘f(a, b, c)’ is a function call with three arguments,
     while ‘f((a, b, c))’ is a function call with a 3-tuple as the sole
     argument.

     Tuples implement all of the *note common: dd3. sequence operations.

For heterogeneous collections of data where access by name is clearer
than access by index, *note collections.namedtuple(): 66b. may be a more
appropriate choice than a simple tuple object.

